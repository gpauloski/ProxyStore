{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#proxystore","title":"ProxyStore","text":"<p>ProxyStore provides pass-by-reference semantics for distributed Python applications through transparent object proxies. Moving data via proxies (1) decouples control flow from data flow, (2) enables producers to unilaterally (i.e., without the agreement of or awareness by the consumer) choose the best storage and communication channel for the data, and (3) perform just-in-time data movement directly between producer and consumer.</p> <p>ProxyStore's goals are to:</p> <ul> <li>Improve productivity. ProxyStore enables easy decoupling of   communication from the rest of the code, allowing developers to focus   on functionality and performance.</li> <li>Improve compatibility. Consumers of data can be agnostic to the   communication method because object proxies handle the communication   behind the scenes.</li> <li>Improve performance. Transport methods and object stores can be changed   at runtime to optimal choices for the given data without the consumers   being aware of the change.</li> </ul> <p>ProxyStore provides support for many third-party mediated communication methods out-of-the-box including Globus Transfer, KeyDB, and Redis. Custom communication methods built on Mochi, UCX, WebRTC, and ZeroMQ are provided for high-performance and multi-site applications.</p> <p>Read more about ProxyStore's concepts here. Complete documentation for ProxyStore is available at docs.proxystore.dev.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install proxystore\n$ pip install proxystore[all]\n</code></pre> <p>See the Installation guide for more information about the available extra install options. For local development, see the Contributing guide.</p> <p>Additional features are available in the <code>proxystore-extensions</code> package.</p>"},{"location":"#example","title":"Example","text":"<p>Getting started with ProxyStore requires a few lines of code.</p> <pre><code>from proxystore.connectors.redis import RedisConnector\nfrom proxystore.proxy import Proxy\nfrom proxystore.store import register_store\nfrom proxystore.store import Store\nstore = Store('my-store', RedisConnector('localhost', 6379))\n# Store the object and get a proxy. The proxy acts\n# like a reference to the object.\ndata = MyDataType(...)\nproxy = store.proxy(data)\nassert isinstance(proxy, Proxy)\ndef my_function(x: MyDataType) -&gt; ...:\n# x is resolved my-store on first use transparently to the\n# function. Then x behaves as an instance of MyDataType.\nassert isinstance(x, MyDataType)\nmy_function(proxy)  # Succeeds\n</code></pre> <p>Check out the Get Started guide to learn more!</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use ProxyStore or any of this code in your work, please cite the following paper. <pre><code>@misc{pauloski2023proxystore,\n    author = {J. Gregory Pauloski and Valerie Hayot-Sasson and Logan Ward and Nathaniel Hudson and Charlie Sabino and Matt Baughman and Kyle Chard and Ian Foster},\n    title = {{Accelerating Communications in Federated Applications with Transparent Object Proxies}},\n    archiveprefix = {arXiv},\n    eprint = {2305.09593},\n    primaryclass = {cs.DC},\n    year = {2023}\n}\n</code></pre></p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#integration-examples","title":"Integration Examples","text":"<p>Examples of integrating ProxyStore into distributed applications built on Globus Compute (formerly called funcX) and Parsl are on GitHub.</p>"},{"location":"examples/#benchmarks","title":"Benchmarks","text":"<p>ProxyStore benchmarks are maintained at github.com/proxystore/benchmarks. These benchmarks can be used as reference for ProxyStore usage or to test your own extensions for ProxyStore.</p>"},{"location":"get-started/","title":"Get Started","text":"<p>Figure 1: ProxyStore allows developers to communicate objects via proxies. Proxies act as lightweight references that resolve to a target object upon use. Communication via proxies gives applications the illusion that objects are moving through a specified path (e.g., through a network socket, cloud server, workflow engine, etc.) while the true path the data takes is different. Transporting the lightweight proxies through the application or systems can be far more efficient and reduce overheads.</p>"},{"location":"get-started/#overview","title":"Overview","text":"<p>ProxyStore provides a unique interface to object stores through transparent object proxies that is designed to simplify the use of object stores for transferring large objects in distributed applications.</p> <p>Proxies are used to intercept and redefine operations on a target object. A transparent proxy behaves identically to its target object because the proxy forwards all operations on itself to the target. A lazy proxy provides just-in-time resolution of the target object via a factory function. Factories return the target object when called, and a proxy, initialized with a factory, will delay calling the factory to retrieve the target object until the first time the proxy is accessed.</p> <p>ProxyStore uses lazy transparent object proxies as the interface to object stores. When an object is proxied, the object is placed in the specified object store, a factory containing the information needed to retrieve the object from the store is created, and a proxy, initialized with the factory, is returned. The resulting proxy is essentially a lightweight reference to the target that will resolve itself to the target and behave as the target once the proxy is first used. Thus, proxies can be used anywhere in-place of the true object and will resolve themselves without the program being aware.</p> <p>ProxyStore provides the proxy interface to a number of commonly used object stores as well as the <code>Proxy</code> and <code>Factory</code> building blocks to allow developers to create powerful just-in-time resolution functionality for Python objects.</p>"},{"location":"get-started/#usage","title":"Usage","text":"<p>ProxyStore is intended to be used via the <code>Store</code> interface which provide the <code>Store.proxy()</code> method for placing objects in stores and creating proxies that will resolve to the associated object in the store.</p> <p>A <code>Store</code> is initialized with a <code>Connector</code> which serves as the low-level interface to an byte-level object store. ProxyStore provides many <code>Connector</code> implementations and third-party code can provide custom implementations provided they meet the <code>Connector</code> protocol specification.</p> <p>The following example uses the <code>RedisConnector</code> to interface with an already running Redis server using proxies.</p> Basic ProxyStore Usage<pre><code>from proxystore.connectors.redis import RedisConnector\nfrom proxystore.store import get_store\nfrom proxystore.store import register_store\nfrom proxystore.store import Store\nstore = Store('my-store', RedisConnector(hostname='localhost', port=1234))\nregister_store(store)\nstore = get_store('my-store')  # (1)!\nkey = store.put(my_object)  # (2)!\nassert my_object == store.get(key)\np = store.proxy(my_object)  # (3)!\nassert isinstance(p, type(my_object))  # (4)!\n</code></pre> <ol> <li>A registered store can be retrieved by name.</li> <li>Stores have basic get/put functionality.</li> <li>Place an object in the store and return a proxy.</li> <li>The proxy, when used, will behave as the target.</li> </ol> <p>This proxy, <code>p</code>, can be cheaply serialized and communicated to any arbitrary Python process as if it were the target object itself. Once the proxy is used on the remote process, the underlying factory function will be executed to retrieve the target object from the Redis server.</p> <p>Using the <code>Store</code> store interface allows developers to write code without needing to worry about how data communication is handled and reduces the number of lines of code that need to be changed when adding or changing the communication methods.</p> <p>For example, if you want to execute a function and the input data may be passed directly, via a key to an object in Redis, or as a filepath to a serialized object on disk, you will need boilerplate code that looks like:</p> <pre><code>def my_function(input: MyDataType | str | ...) -&gt; None:\nif is_filepath(input_data):\ndata = read_and_deserialize(input)\nelif is_redis_key(input_data):\ndata = redis_client.get(input)\nelif is_other_communication_method(input_data):\n...\nelif isinstance(input, MyDataType):\ndata = input\nelse:\nraise ValueError(...)\n# Compute using the data\n</code></pre> <p>This function is hard to type and must be extended every time a new communication method is used. With proxies, all of the boilerplate code can be removed because the proxy will contain within itself all of the necessary code to resolve the object.</p> <pre><code>def my_function(input: MyDataType) -&gt; None:\nassert isinstance(input, MyDataType)  # (1)!\n# Compute using the data\n</code></pre> <ol> <li>Always true even if input is a proxy.</li> </ol> <p>In this model, only the producer of the data needs to be aware of which ProxyStore backend to use, and no modification to consumer code are ever required.</p> <p>How is this more efficient?</p> <p>The ProxyStore model can improve application performance in many ways:</p> <ol> <li>Unused proxies are not resolved so not resources/time were wasted on the    communication.</li> <li>Object communication always takes place between the producer, the store, and    the consumer meaning communication is not wasted on intermediate processes    which have a proxy but do not use it.</li> <li>Different backends can be used that are optimized for specific usage    patterns.</li> <li>Proxies have built-in caching for frequently used objects.</li> </ol> <p>See the Concepts to learn more!</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#base-install","title":"Base Install","text":"<p>We always recommend installing packages inside of your virtual environment of choice. E.g., <pre><code>$ python -m venv venv\n$ . venv/bin/activate\n</code></pre></p> <p>Once your virtual environment is activated, install ProxyStore with <code>pip</code>. <pre><code>$ pip install proxystore\n</code></pre></p>"},{"location":"installation/#extras-options","title":"Extras Options","text":"<p>The base installation is designed to be as lightweight as possible, but ProxyStore provides many features with extra dependencies that can be installed with the appropriate extras option.</p> Install Purpose <code>pip install proxystore[all]</code> Install all extras except <code>dev</code> and <code>docs</code> <code>pip install proxystore[endpoints]</code> Use ProxyStore Endpoints <code>pip install proxystore[redis]</code> Use the <code>RedisConnector</code> <code>pip install proxystore[zmq]</code> Use the <code>ZeroMQConnector</code> <code>pip install proxystore[dev]</code> Development dependencies <code>pip install proxystore[docs]</code> Documentation dependencies <p>Multiple extras options can be install at the same time.</p> <pre><code>$ pip install proxystore[endpoints,redis]\n</code></pre> <p>Or everything can be installed at once (this does not install the development packages).</p> <pre><code>$ pip install proxystore[all]\n</code></pre>"},{"location":"installation/#distributed-in-memory-connectors","title":"Distributed In-Memory Connectors","text":"<p>The <code>MargoConnector</code> and <code>UCXConnector</code> have additional manual installation steps to be completed before they can be used.</p> <ul> <li>Margo:<ul> <li>Install Mochi-Margo and the dependencies</li> <li>Install Py-Mochi-Margo</li> </ul> </li> <li>UCX:<ul> <li>Install UCX</li> <li>Install UCX-Py</li> </ul> </li> </ul>"},{"location":"installation/#proxystore-extensions","title":"ProxyStore Extensions","text":"<p>Additional features are available in the <code>proxystore-extensions</code> package (Repository and Docs). Features in the extensions package tend to be more experimental or have heavier dependencies. <pre><code>$ pip install proxystore-extensions\n</code></pre></p>"},{"location":"known-issues/","title":"Known Issues","text":""},{"location":"known-issues/#bugs","title":"Bugs","text":"<ul> <li>The <code>ZeroMQConnector</code> will raise a <code>_pickle.UnpicklingError: pickle data was truncated</code> error if the serialized data is larger than the chunk size (64 MiB by default).<ul> <li>Affected versions: <code>==0.4.1</code></li> <li>Fixed in <code>0.5.0</code> by PR #219.</li> </ul> </li> </ul>"},{"location":"known-issues/#compatibility","title":"Compatibility","text":"<ul> <li>ProxyStore Endpoints are not supported for   Python 3.7 on ARM-based Macs because   aiortc does not have the corresponding   wheels. The base ProxyStore package can still be installed on this   software/hardware configurations---just not with the <code>endpoints</code> extras.<ul> <li>Affected versions: <code>&gt;=0.4.0,&lt;0.6.0</code></li> <li>Python 3.7 support will be removed in <code>0.6.0</code>. See Issue #236.</li> </ul> </li> <li>Newer versions of UCX-Py   no longer support Python 3.7.<ul> <li>We test against and recommend using UCX-Py <code>0.30.00</code>.</li> <li>Affected versions: <code>&gt;=0.4.0,&lt;0.6.0</code></li> <li>Python 3.7 support will be removed in <code>0.6.0</code>. See Issue #236.</li> </ul> </li> </ul>"},{"location":"known-issues/#mypy","title":"MyPy","text":""},{"location":"known-issues/#implicit-re-exports","title":"Implicit re-exports","text":"<p>Examples throughout the documentation generally suggest importing <code>Store</code> like the following. example.py<pre><code>from proxystore.store import Store\n</code></pre></p> <p>MyPy will raise an attribute defined error if run with <code>--no-implicit-reexport</code>. <pre><code>$ mypy example.py --no-implicit-reexport\nexample.py:1: error: Module \"proxystore.store\" does not explicitly export attribute \"Store\"  [attr-defined]\n</code></pre></p> <p>This can be fixed by using the explicit import. <pre><code>from proxystore.store.base import Store\n</code></pre></p>"},{"location":"api/","title":"proxystore","text":"<code>proxystore/__init__.py</code> <p>ProxyStore is a library for decoupling object communication from code.</p> <p>Legacy Documentation: Documentation for ProxyStore versions older than v0.4.1 are hosted at proxystore.readthedocs.io/.</p>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>proxystore</li> <li>proxystore.connectors<ul> <li>connector</li> <li>dim<ul> <li>exceptions</li> <li>margo</li> <li>models</li> <li>ucx</li> <li>utils</li> <li>zmq</li> </ul> </li> <li>endpoint</li> <li>file</li> <li>globus</li> <li>local</li> <li>multi</li> <li>redis</li> </ul> </li> <li>proxystore.endpoint<ul> <li>cli</li> <li>client</li> <li>commands</li> <li>config</li> <li>constants</li> <li>endpoint</li> <li>exceptions</li> <li>messages</li> <li>serve</li> <li>storage</li> </ul> </li> <li>proxystore.factory</li> <li>proxystore.globus</li> <li>proxystore.p2p<ul> <li>chunks</li> <li>connection</li> <li>counter</li> <li>exceptions</li> <li>manager</li> <li>messages</li> <li>relay</li> <li>relay_client</li> <li>task</li> </ul> </li> <li>proxystore.proxy</li> <li>proxystore.serialize</li> <li>proxystore.store<ul> <li>base</li> <li>cache</li> <li>endpoint</li> <li>exceptions</li> <li>file</li> <li>globus</li> <li>local</li> <li>metrics</li> <li>multi</li> <li>redis</li> <li>utils</li> </ul> </li> <li>proxystore.timer</li> <li>proxystore.utils</li> <li>proxystore.warnings</li> </ul>"},{"location":"api/cli/","title":"CLI Reference","text":""},{"location":"api/cli/#cli-reference","title":"CLI Reference","text":"<p>This page provides documentation for our command line tools.</p>"},{"location":"api/cli/#proxystore-globus-auth","title":"proxystore-globus-auth","text":"<p>Perform Globus authentication for the Transfer service.</p> <p>Collections or scopes options can be strung together. E.g., request transfer scope for multiple collections with:</p> <p>$ proxystore-globus-auth -c UUID -c UUID -c UUID</p> <p>Usage:</p> <pre><code>proxystore-globus-auth [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--collection</code>, <code>-c</code> text Globus Collection UUID to request transfer scopes for. None <code>--scope</code>, <code>-s</code> text Additional scope to request. None <code>--delete</code> boolean Delete existing tokens. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint","title":"proxystore-endpoint","text":"<p>Manage and start ProxyStore Endpoints.</p> <p>Usage:</p> <pre><code>proxystore-endpoint [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--log-level</code> choice (<code>ERROR</code> | <code>WARNING</code> | <code>INFO</code> | <code>DEBUG</code>) Minimum logging level. <code>INFO</code> <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>configure: Configure a new endpoint.</li> <li>help: Show available commands and options.</li> <li>list: List all user endpoints.</li> <li>remove: Remove an endpoint.</li> <li>start: Start an endpoint.</li> <li>stop: Stop a detached endpoint.</li> <li>test: Execute test commands on an endpoint.</li> <li>version: Show the ProxyStore version.</li> </ul>"},{"location":"api/cli/#proxystore-endpoint-configure","title":"proxystore-endpoint configure","text":"<p>Configure a new endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint configure [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--port</code> integer Port to listen on. <code>8765</code> <code>--relay-server</code> text Optional relay server address. None <code>--peer-channels</code> integer Datachannels to use per peer connection. <code>1</code> <code>--persist</code> / <code>--no-persist</code> boolean Optionally persist data to a database. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-help","title":"proxystore-endpoint help","text":"<p>Show available commands and options.</p> <p>Usage:</p> <pre><code>proxystore-endpoint help [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-list","title":"proxystore-endpoint list","text":"<p>List all user endpoints.</p> <p>Usage:</p> <pre><code>proxystore-endpoint list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-remove","title":"proxystore-endpoint remove","text":"<p>Remove an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint remove [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-start","title":"proxystore-endpoint start","text":"<p>Start an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint start [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--detach</code> / <code>--no-detach</code> boolean Run as daemon. <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-stop","title":"proxystore-endpoint stop","text":"<p>Stop a detached endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint stop [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-test","title":"proxystore-endpoint test","text":"<p>Execute test commands on an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint test [OPTIONS] NAME COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--remote</code> text Optional UUID of remote endpoint to use. None <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>evict: Evict object from an endpoint.</li> <li>exists: Check if object exists in an endpoint.</li> <li>get: Get an object from an endpoint.</li> <li>put: Put an object in an endpoint.</li> </ul>"},{"location":"api/cli/#proxystore-endpoint-test-name-evict","title":"proxystore-endpoint test NAME evict","text":"<p>Evict object from an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint test NAME evict [OPTIONS] KEY\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-test-name-exists","title":"proxystore-endpoint test NAME exists","text":"<p>Check if object exists in an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint test NAME exists [OPTIONS] KEY\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-test-name-get","title":"proxystore-endpoint test NAME get","text":"<p>Get an object from an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint test NAME get [OPTIONS] KEY\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-test-name-put","title":"proxystore-endpoint test NAME put","text":"<p>Put an object in an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint test NAME put [OPTIONS] DATA\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-version","title":"proxystore-endpoint version","text":"<p>Show the ProxyStore version.</p> <p>Usage:</p> <pre><code>proxystore-endpoint version [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-relay","title":"proxystore-relay","text":"<p>Run a relay server instance.</p> <p>The relay server is used by clients to establish peer-to-peer WebRTC connections.</p> <p>Usage:</p> <pre><code>proxystore-relay [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--host</code> text Address to listen on. <code>0.0.0.0</code> <code>--port</code> integer Port to listen on. <code>8765</code> <code>--certfile</code> text Certificate file for serving with TLS. None <code>--keyfile</code> text Private key file associated with the certfile. None <code>--log-dir</code> text Write server logs to this directory. None <code>--log-level</code> choice (<code>CRITICAL</code> | <code>ERROR</code> | <code>WARNING</code> | <code>INFO</code> | <code>DEBUG</code>) Minimum logging level. <code>INFO</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/factory/","title":"proxystore.factory","text":"<code>proxystore/factory.py</code> <p>Factory implementations.</p> <p>Factories are callable classes that wrap up the functionality needed to resolve a proxy, where resolving is the process of retrieving the object from wherever it is stored such that the proxy can act as the object.</p>"},{"location":"api/factory/#proxystore.factory.Factory","title":"Factory","text":"<pre><code>Factory() -&gt; None\n</code></pre> <p>         Bases: <code>Generic[T]</code></p> <p>Abstract Factory Class.</p> <p>A factory is a callable object that when called, returns an object. The <code>Proxy</code> constructor takes an instance of a factory and calls the factory when the proxy does its just-in-time resolution.</p> Note <p>If a custom factory is not-pickleable, <code>__getnewargs_ex__</code> may need to be implemented. Writing custom pickling functions is also beneifical to ensure that a pickled factory does not contain the object itself, just what is needed to resolve the object to keep the final pickled factory as small as possible.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def __init__(self) -&gt; None:\nraise NotImplementedError\n</code></pre>"},{"location":"api/factory/#proxystore.factory.Factory.__call__","title":"__call__()","text":"<pre><code>__call__() -&gt; T\n</code></pre> <p>Alias <code>Factory.resolve()</code>.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def __call__(self) -&gt; T:\n\"\"\"Alias [`Factory.resolve()`][proxystore.factory.Factory.resolve].\"\"\"\nreturn self.resolve()\n</code></pre>"},{"location":"api/factory/#proxystore.factory.Factory.resolve","title":"resolve()","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Resolve and return object.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Resolve and return object.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"api/factory/#proxystore.factory.SimpleFactory","title":"SimpleFactory","text":"<pre><code>SimpleFactory(obj: T) -&gt; None\n</code></pre> <p>         Bases: <code>Factory[T]</code></p> <p>Simple Factory that stores object as class attribute.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T</code>)         \u2013 <p>Object to produce when factory is called.</p> </li> </ul> Source code in <code>proxystore/factory.py</code> <pre><code>def __init__(self, obj: T) -&gt; None:\nself._obj = obj\n</code></pre>"},{"location":"api/factory/#proxystore.factory.SimpleFactory.resolve","title":"resolve()","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Return the object.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Return the object.\"\"\"\nreturn self._obj\n</code></pre>"},{"location":"api/factory/#proxystore.factory.LambdaFactory","title":"LambdaFactory","text":"<pre><code>LambdaFactory(\ntarget: Callable[..., T], *args: Any, **kwargs: Any\n) -&gt; None\n</code></pre> <p>         Bases: <code>Factory[T]</code></p> <p>Factory that takes any callable object.</p> <p>Parameters:</p> <ul> <li> target             (<code>Callable[..., T]</code>)         \u2013 <p>Callable object (function, class, lambda) to be invoked when the factory is resolved.</p> </li> <li> args             (<code>Any</code>)         \u2013 <p>Argument tuple for target invocation.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Dictionary of keyword arguments for target invocation.</p> </li> </ul> Source code in <code>proxystore/factory.py</code> <pre><code>def __init__(\nself,\ntarget: Callable[..., T],\n*args: Any,\n**kwargs: Any,\n) -&gt; None:\nself._target = target\nself._args = args\nself._kwargs = kwargs\n</code></pre>"},{"location":"api/factory/#proxystore.factory.LambdaFactory.resolve","title":"resolve()","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Return the target object.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Return the target object.\"\"\"\nreturn self._target(*self._args, **self._kwargs)\n</code></pre>"},{"location":"api/globus/","title":"proxystore.globus","text":"<code>proxystore/globus.py</code> <p>Globus OAuth tools.</p> <p>ProxyStore provides the <code>proxystore-globus-auth</code> CLI tool to give consent to the ProxyStore Globus Application.</p> <pre><code># basic authentication\nproxystore-globus-auth\n# delete old tokens\nproxystore-globus-auth --delete\n# give consent for specific collections\nproxystore-globus-auth --collections COLLECTION_UUID COLLECTION_UUID ...\n# specify additional scopes\nproxystore-globus-auth --scopes SCOPE SCOPE ...\n</code></pre> <p>Based on Parsl's implementation and the Globus examples.</p>"},{"location":"api/globus/#proxystore.globus.GlobusAuthFileError","title":"GlobusAuthFileError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised if the Globus Auth token file cannot be read.</p>"},{"location":"api/globus/#proxystore.globus.load_tokens_from_file","title":"load_tokens_from_file()","text":"<pre><code>load_tokens_from_file(\nfilepath: str,\n) -&gt; dict[str, dict[str, Any]]\n</code></pre> <p>Load a set of saved tokens.</p> <p>Parameters:</p> <ul> <li> filepath             (<code>str</code>)         \u2013 <p>Filepath containing JSON tokens to load.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, dict[str, Any]]</code>         \u2013 <p>JSON data from tokens file.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def load_tokens_from_file(filepath: str) -&gt; dict[str, dict[str, Any]]:\n\"\"\"Load a set of saved tokens.\n    Args:\n        filepath: Filepath containing JSON tokens to load.\n    Returns:\n        JSON data from tokens file.\n    \"\"\"\nwith open(filepath) as f:\nreturn json.load(f)\n</code></pre>"},{"location":"api/globus/#proxystore.globus.save_tokens_to_file","title":"save_tokens_to_file()","text":"<pre><code>save_tokens_to_file(\nfilepath: str, tokens: globus_sdk.OAuthTokenResponse\n) -&gt; None\n</code></pre> <p>Save a set of tokens for later use.</p> <p>Parameters:</p> <ul> <li> filepath             (<code>str</code>)         \u2013 <p>Filepath to write tokens to.</p> </li> <li> tokens             (<code>globus_sdk.OAuthTokenResponse</code>)         \u2013 <p>Tokens returned by the Globus API.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def save_tokens_to_file(\nfilepath: str,\ntokens: globus_sdk.OAuthTokenResponse,\n) -&gt; None:\n\"\"\"Save a set of tokens for later use.\n    Args:\n        filepath: Filepath to write tokens to.\n        tokens: Tokens returned by the Globus API.\n    \"\"\"\nwith open(filepath, 'w') as f:\njson.dump(tokens.by_resource_server, f, indent=4)\n</code></pre>"},{"location":"api/globus/#proxystore.globus.authenticate","title":"authenticate()","text":"<pre><code>authenticate(\nclient_id: str,\nredirect_uri: str | None = None,\nrequested_scopes: Iterable[str] | None = None,\n) -&gt; globus_sdk.OAuthTokenResponse\n</code></pre> <p>Perform Native App auth flow.</p> <p>This will print a link to <code>auth.globus.org</code> where the user will continue the authentication process. Then the function will wait on the user to input the authorization code.</p> <p>Parameters:</p> <ul> <li> client_id             (<code>str</code>)         \u2013 <p>Globus app ID.</p> </li> <li> redirect_uri             (<code>str | None</code>)         \u2013 <p>The page to direct users to after authentication.</p> </li> <li> requested_scopes             (<code>Iterable[str] | None</code>)         \u2013 <p>Iterable of scopes on the token being requested.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>globus_sdk.OAuthTokenResponse</code>         \u2013 <p>Tokens returned by the Globus API.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def authenticate(\nclient_id: str,\nredirect_uri: str | None = None,\nrequested_scopes: Iterable[str] | None = None,\n) -&gt; globus_sdk.OAuthTokenResponse:\n\"\"\"Perform Native App auth flow.\n    This will print a link to `auth.globus.org` where the user will\n    continue the authentication process. Then the function will wait on\n    the user to input the authorization code.\n    Args:\n        client_id: Globus app ID.\n        redirect_uri: The page to direct users to after authentication.\n        requested_scopes: Iterable of scopes on the token being requested.\n    Returns:\n        Tokens returned by the Globus API.\n    \"\"\"\nclient = globus_sdk.NativeAppAuthClient(client_id=client_id)\nclient.oauth2_start_flow(\nredirect_uri=redirect_uri,\nrefresh_tokens=True,\nrequested_scopes=requested_scopes,\n)\nurl = client.oauth2_get_authorize_url()\nclick.secho('Please visit the following url to authenticate:', fg='cyan')\nclick.echo(url)\nauth_code = click.prompt(\nclick.style('Enter the auth code:', fg='cyan'),\nprompt_suffix=' ',\n)\nauth_code = auth_code.strip()\nreturn client.oauth2_exchange_code_for_tokens(auth_code)\n</code></pre>"},{"location":"api/globus/#proxystore.globus.get_authorizer","title":"get_authorizer()","text":"<pre><code>get_authorizer(\nclient_id: str, tokens_file: str\n) -&gt; globus_sdk.RefreshTokenAuthorizer\n</code></pre> <p>Get an authorizer for the Globus SDK.</p> <p>Parameters:</p> <ul> <li> client_id             (<code>str</code>)         \u2013 <p>Globus app ID.</p> </li> <li> tokens_file             (<code>str</code>)         \u2013 <p>Filepath to saved Globus Auth tokens.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>globus_sdk.RefreshTokenAuthorizer</code>         \u2013 <p>Authorizer than can be used with other parts of the Globus SDK.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>GlobusAuthFileError</code>           \u2013         <p>If <code>tokens_file</code> cannot be parsed.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def get_authorizer(\nclient_id: str,\ntokens_file: str,\n) -&gt; globus_sdk.RefreshTokenAuthorizer:\n\"\"\"Get an authorizer for the Globus SDK.\n    Args:\n        client_id: Globus app ID.\n        tokens_file: Filepath to saved Globus Auth tokens.\n    Returns:\n        Authorizer than can be used with other parts of the Globus SDK.\n    Raises:\n        GlobusAuthFileError: If `tokens_file` cannot be parsed.\n    \"\"\"\ntry:\ntokens = load_tokens_from_file(tokens_file)\nexcept OSError as e:\nraise GlobusAuthFileError(\nf'Error loading tokens from {tokens_file}: {e}.',\n) from e\ntransfer_tokens = tokens['transfer.api.globus.org']\nauth_client = globus_sdk.NativeAppAuthClient(client_id=client_id)\nreturn globus_sdk.RefreshTokenAuthorizer(\ntransfer_tokens['refresh_token'],\nauth_client,\naccess_token=transfer_tokens['access_token'],\nexpires_at=transfer_tokens['expires_at_seconds'],\non_refresh=functools.partial(save_tokens_to_file, tokens_file),\n)\n</code></pre>"},{"location":"api/globus/#proxystore.globus.proxystore_authenticate","title":"proxystore_authenticate()","text":"<pre><code>proxystore_authenticate(\nproxystore_dir: str | None = None,\ncollections: list[str] | None = None,\nadditional_scopes: list[str] | None = None,\n) -&gt; str\n</code></pre> <p>Perform auth flow for ProxyStore native app.</p> <p>This is a wrapper around <code>authenticate()</code> which stores tokens in the ProxyStore home directory and requests the appropriate scopes for ProxyStore.</p> Alert <p>Globus Connect Server v5 uses consents rather than activations so users need to consent to the Transfer service accessing the specific mapped collection on behalf of the user. Read more here.</p> <p>Parameters:</p> <ul> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> <li> collections             (<code>list[str] | None</code>)         \u2013 <p>Globus Collection UUIDs to request transfer scopes for.</p> </li> <li> additional_scopes             (<code>list[str] | None</code>)         \u2013 <p>Extra scopes to include in the authorization request.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Path to saved tokens file.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def proxystore_authenticate(\nproxystore_dir: str | None = None,\ncollections: list[str] | None = None,\nadditional_scopes: list[str] | None = None,\n) -&gt; str:\n\"\"\"Perform auth flow for ProxyStore native app.\n    This is a wrapper around [`authenticate()`][proxystore.globus.authenticate]\n    which stores tokens in the ProxyStore home directory and requests the\n    appropriate scopes for ProxyStore.\n    Alert:\n        Globus Connect Server v5 uses consents rather than activations so\n        users need to consent to the Transfer service accessing the\n        specific mapped collection on behalf of the user. Read more\n        [here](https://docs.globus.org/globus-connect-server/migrating-to-v5.4/application-migration/#activation_is_replaced_by_consent){target=_blank}.\n    Args:\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n        collections: Globus Collection UUIDs to request transfer scopes for.\n        additional_scopes: Extra scopes to include in the authorization\n            request.\n    Returns:\n        Path to saved tokens file.\n    \"\"\"\nproxystore_dir = home_dir() if proxystore_dir is None else proxystore_dir\ntokens_file = os.path.join(proxystore_dir, _TOKENS_FILE)\nos.makedirs(proxystore_dir, exist_ok=True)\nscopes = _get_proxystore_scopes(collections, additional_scopes)\ntokens = authenticate(\nclient_id=_APPLICATION_ID,\nredirect_uri=_REDIRECT_URI,\nrequested_scopes=scopes,\n)\nsave_tokens_to_file(tokens_file, tokens)\nreturn tokens_file\n</code></pre>"},{"location":"api/globus/#proxystore.globus.get_proxystore_authorizer","title":"get_proxystore_authorizer()","text":"<pre><code>get_proxystore_authorizer(\nproxystore_dir: str | None = None,\n) -&gt; globus_sdk.RefreshTokenAuthorizer\n</code></pre> <p>Get an authorizer for the ProxyStore native app.</p> <p><code>proxystore_authenticate()</code> or the CLI <code>proxystore-globus-auth</code> should be performed prior to calling this function to ensure tokens have been acquired.</p> <p>Parameters:</p> <ul> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>globus_sdk.RefreshTokenAuthorizer</code>         \u2013 <p>Authorizer than can be used with other parts of the Globus SDK.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def get_proxystore_authorizer(\nproxystore_dir: str | None = None,\n) -&gt; globus_sdk.RefreshTokenAuthorizer:\n\"\"\"Get an authorizer for the ProxyStore native app.\n    [`proxystore_authenticate()`][proxystore.globus.proxystore_authenticate]\n    or the CLI `#!bash proxystore-globus-auth` should be performed prior to\n    calling this function to ensure tokens have been acquired.\n    Args:\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Authorizer than can be used with other parts of the Globus SDK.\n    \"\"\"\nproxystore_dir = home_dir() if proxystore_dir is None else proxystore_dir\ntokens_file = os.path.join(proxystore_dir, _TOKENS_FILE)\nreturn get_authorizer(client_id=_APPLICATION_ID, tokens_file=tokens_file)\n</code></pre>"},{"location":"api/globus/#proxystore.globus.cli","title":"cli()","text":"<pre><code>cli(\ncollection: list[str], scope: list[str], delete: bool\n) -&gt; None\n</code></pre> <p>Perform Globus authentication for the Transfer service.</p> <p>Collections or scopes options can be strung together. E.g., request transfer scope for multiple collections with:</p> <p>$ proxystore-globus-auth -c UUID -c UUID -c UUID</p> Source code in <code>proxystore/globus.py</code> <pre><code>@click.command()\n@click.option(\n'--collection',\n'-c',\nmetavar='UUID',\nmultiple=True,\nhelp='Globus Collection UUID to request transfer scopes for.',\n)\n@click.option(\n'--scope',\n'-s',\nmetavar='SCOPE',\nmultiple=True,\nhelp='Additional scope to request.',\n)\n@click.option(\n'--delete',\nis_flag=True,\ndefault=False,\nhelp='Delete existing tokens.',\n)\ndef cli(collection: list[str], scope: list[str], delete: bool) -&gt; None:\n\"\"\"Perform Globus authentication for the Transfer service.\n    Collections or scopes options can be strung together. E.g.,\n    request transfer scope for multiple collections with:\n    $ proxystore-globus-auth -c UUID -c UUID -c UUID\n    \"\"\"\nif delete:\ntokens_file = os.path.join(home_dir(), _TOKENS_FILE)\nfp = click.format_filename(tokens_file)\nif os.path.exists(tokens_file):\nos.remove(tokens_file)\nclick.echo(f'Deleted tokens file: {fp}')\nreturn\nelse:\nclick.echo(f'Tokens file does not exist: {fp}')\nraise SystemExit(1)\ntry:\nget_proxystore_authorizer()\nexcept GlobusAuthFileError:\ntokens_file = proxystore_authenticate(\ncollections=collection,\nadditional_scopes=scope,\n)\nget_proxystore_authorizer()\nclick.echo(f'Tokens saved to: {click.format_filename(tokens_file)}')\nelse:\nclick.echo(\n'Globus authorization is already completed.\\n\\n'\n'To re-authenticate, delete your tokens and try again.\\n'\n'  $ proxystore-globus-auth --delete',\n)\n</code></pre>"},{"location":"api/legacy-docs/","title":"Legacy Docs","text":"<p>Legacy documentation for ProxyStore versions prior to v0.4.1 can be found at proxystore.readthedocs.io.</p>"},{"location":"api/proxy/","title":"proxystore.proxy","text":"<code>proxystore/proxy.py</code> <p>Proxy implementation and helpers.</p>"},{"location":"api/proxy/#proxystore.proxy.Proxy","title":"Proxy","text":"<pre><code>Proxy(factory: FactoryType[T]) -&gt; None\n</code></pre> <p>         Bases: <code>slots.Proxy</code>, <code>Generic[T]</code></p> <p>Lazy Object Proxy.</p> <p>An extension of the Proxy from lazy-object-proxy with modified pickling behavior.</p> <p>An object proxy acts as a thin wrapper around a Python object, i.e. the proxy behaves identically to the underlying object. The proxy is initialized with a callable factory object. The factory returns the underlying object when called, i.e. 'resolves' the proxy. The does just-in-time resolution, i.e., the proxy does not call the factory until the first access to the proxy (hence, the lazy aspect of the proxy).</p> <p>The factory contains the mechanisms to appropriately resolve the object, e.g., which in the case for ProxyStore means requesting the correct object from the backend store.</p> <pre><code>x = np.array([1, 2, 3])\nf = ps.factory.SimpleFactory(x)\np = ps.proxy.Proxy(f)\nassert isinstance(p, np.ndarray)\nassert np.array_equal(p, [1, 2, 3])\n</code></pre> Note <p>The <code>factory</code>, by default, is only ever called once during the lifetime of a proxy instance.</p> Note <p>When a proxy instance is pickled, only the <code>factory</code> is pickled, not the wrapped object. Thus, proxy instances can be pickled and passed around cheaply, and once the proxy is unpickled and used, the <code>factory</code> will be called again to resolve the object.</p> Warning <p>A proxy of a singleton type (e.g., <code>True</code>, <code>False</code>, and <code>None</code>) will not behave exactly as a singleton type would. This is because the proxy itself is not a singleton.</p> <pre><code>&gt;&gt;&gt; from proxystore.proxy import Proxy\n&gt;&gt;&gt; p = Proxy(lambda: True)\n&gt;&gt;&gt; p == True\nTrue\n&gt;&gt;&gt; p is True\nFalse\n</code></pre> Warning <p>Python bindings to other languages (e.g., C, C++) may throw type errors when receiving a <code>Proxy</code> instance. Casting the proxy or extracting the target object may be needed.</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; from proxystore.proxy import Proxy\n&gt;&gt;&gt; s = 'mystring'\n&gt;&gt;&gt; p = Proxy(lambda: s)\n&gt;&gt;&gt; io.StringIO(p)\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: initial_value must be str or None, not Proxy\n&gt;&gt;&gt; io.StringIO(str(p))  # succeeds\n</code></pre> <p>Parameters:</p> <ul> <li> factory             (<code>FactoryType[T]</code>)         \u2013 <p>Callable object that returns the underlying object when called.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If <code>factory</code> is not callable.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def __init__(self, factory: FactoryType[T]) -&gt; None:\nif not callable(factory):\nraise TypeError('factory must be callable')\nsuper().__init__(factory)\n</code></pre>"},{"location":"api/proxy/#proxystore.proxy.ProxyLocker","title":"ProxyLocker","text":"<pre><code>ProxyLocker(proxy: Proxy[T]) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[T]</code></p> <p>Proxy locker that prevents resolution of wrapped proxies.</p> <p>The class prevents unintended access to a wrapped proxy to ensure a proxy is not resolved. The wrapped proxy can be retrieved with <code>proxy = ProxyLocker(proxy).unlock()</code>.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>Proxy[T]</code>)         \u2013 <p>Proxy to lock.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def __init__(self, proxy: Proxy[T]) -&gt; None:\nself._proxy = proxy\n</code></pre>"},{"location":"api/proxy/#proxystore.proxy.ProxyLocker.unlock","title":"unlock()","text":"<pre><code>unlock() -&gt; Proxy[T]\n</code></pre> <p>Retrieve the locked proxy.</p> <p>Returns:</p> <ul> <li> <code>Proxy[T]</code>         \u2013 <p>Proxy object.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def unlock(self) -&gt; Proxy[T]:\n\"\"\"Retrieve the locked proxy.\n    Returns:\n        Proxy object.\n    \"\"\"\nreturn super().__getattribute__('_proxy')\n</code></pre>"},{"location":"api/proxy/#proxystore.proxy.extract","title":"extract()","text":"<pre><code>extract(proxy: proxystore.proxy.Proxy[T]) -&gt; T\n</code></pre> <p>Return object wrapped by proxy.</p> <p>If the proxy has not been resolved yet, this will force the proxy to be resolved prior.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>proxystore.proxy.Proxy[T]</code>)         \u2013 <p>Proxy instance to extract from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code>         \u2013 <p>Object wrapped by proxy.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def extract(proxy: proxystore.proxy.Proxy[T]) -&gt; T:\n\"\"\"Return object wrapped by proxy.\n    If the proxy has not been resolved yet, this will force\n    the proxy to be resolved prior.\n    Args:\n        proxy: Proxy instance to extract from.\n    Returns:\n        Object wrapped by proxy.\n    \"\"\"\nreturn proxy.__wrapped__\n</code></pre>"},{"location":"api/proxy/#proxystore.proxy.is_resolved","title":"is_resolved()","text":"<pre><code>is_resolved(proxy: proxystore.proxy.Proxy[T]) -&gt; bool\n</code></pre> <p>Check if a proxy is resolved.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>proxystore.proxy.Proxy[T]</code>)         \u2013 <p>Proxy instance to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p><code>True</code> if <code>proxy</code> is resolved (i.e., the <code>factory</code> has been called)         and <code>False</code> otherwise.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def is_resolved(proxy: proxystore.proxy.Proxy[T]) -&gt; bool:\n\"\"\"Check if a proxy is resolved.\n    Args:\n        proxy: Proxy instance to check.\n    Returns:\n        `True` if `proxy` is resolved (i.e., the `factory` has been called) \\\n        and `False` otherwise.\n    \"\"\"\nreturn proxy.__resolved__\n</code></pre>"},{"location":"api/proxy/#proxystore.proxy.resolve","title":"resolve()","text":"<pre><code>resolve(proxy: proxystore.proxy.Proxy[T]) -&gt; None\n</code></pre> <p>Force a proxy to resolve itself.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>proxystore.proxy.Proxy[T]</code>)         \u2013 <p>Proxy instance to force resolve.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def resolve(proxy: proxystore.proxy.Proxy[T]) -&gt; None:\n\"\"\"Force a proxy to resolve itself.\n    Args:\n        proxy: Proxy instance to force resolve.\n    \"\"\"\nproxy.__wrapped__  # noqa: B018\n</code></pre>"},{"location":"api/serialize/","title":"proxystore.serialize","text":"<code>proxystore/serialize.py</code> <p>Serialization functions.</p>"},{"location":"api/serialize/#proxystore.serialize.SerializationError","title":"SerializationError","text":"<p>         Bases: <code>Exception</code></p> <p>Base Serialization Exception.</p>"},{"location":"api/serialize/#proxystore.serialize.serialize","title":"serialize()","text":"<pre><code>serialize(obj: Any) -&gt; bytes\n</code></pre> <p>Serialize object.</p> <p>Objects are serialized using pickle (protocol 4) except for bytes or str objects. If pickle fails, cloudpickle is used as a fallback.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>Object to serialize.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>         \u2013 <p>Bytes that can be passed to         <code>deserialize()</code>.</p> </li> </ul> Source code in <code>proxystore/serialize.py</code> <pre><code>def serialize(obj: Any) -&gt; bytes:\n\"\"\"Serialize object.\n    Objects are serialized using\n    [pickle](https://docs.python.org/3/library/pickle.html){target=_blank}\n    (protocol 4) except for [bytes][] or [str][] objects.\n    If pickle fails,\n    [cloudpickle](https://github.com/cloudpipe/cloudpickle){target=_blank}\n    is used as a fallback.\n    Args:\n        obj: Object to serialize.\n    Returns:\n        Bytes that can be passed to \\\n        [`deserialize()`][proxystore.serialize.deserialize].\n    \"\"\"\nif isinstance(obj, bytes):\nidentifier = b'01\\n'\nelif isinstance(obj, str):\nidentifier = b'02\\n'\nobj = obj.encode()\nelse:\n# Use cloudpickle if pickle fails\ntry:\nidentifier = b'03\\n'\n# Pickle protocol 4 is available in Python 3.7 and later but not\n# the default in Python 3.7 so manually specify it.\nobj = pickle.dumps(obj, protocol=4)\nexcept Exception:\nidentifier = b'04\\n'\nobj = cloudpickle.dumps(obj)\nassert isinstance(identifier, bytes)\nassert isinstance(obj, bytes)\nreturn identifier + obj\n</code></pre>"},{"location":"api/serialize/#proxystore.serialize.deserialize","title":"deserialize()","text":"<pre><code>deserialize(data: bytes) -&gt; Any\n</code></pre> <p>Deserialize object.</p> <p>Parameters:</p> <ul> <li> data             (<code>bytes</code>)         \u2013 <p>Bytes produced by <code>serialize()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>         \u2013 <p>The deserialized object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>data</code> is not of type <code>bytes</code>.</p> </li> <li> <code>SerializationError</code>           \u2013         <p>If the identifier of <code>data</code> is missing or invalid. The identifier is prepended to the string in <code>serialize()</code> to indicate which serialization method was used (e.g., no serialization, pickle, etc.).</p> </li> </ul> Source code in <code>proxystore/serialize.py</code> <pre><code>def deserialize(data: bytes) -&gt; Any:\n\"\"\"Deserialize object.\n    Args:\n        data: Bytes produced by\n            [`serialize()`][proxystore.serialize.serialize].\n    Returns:\n        The deserialized object.\n    Raises:\n        ValueError: If `data` is not of type `bytes`.\n        SerializationError: If the identifier of `data` is missing or\n            invalid. The identifier is prepended to the string in\n            [`serialize()`][proxystore.serialize.serialize] to indicate which\n            serialization method was used (e.g., no serialization, pickle,\n            etc.).\n    \"\"\"\nif not isinstance(data, bytes):\nraise ValueError(\nf'Expected data to be of type bytes, not {type(data)}.',\n)\nidentifier, separator, data = data.partition(b'\\n')\nif separator == b'' or len(identifier) != len(b'00'):\nraise SerializationError(\n'Data does not have required identifier for deserialization.',\n)\nif identifier == b'01':\nreturn data\nelif identifier == b'02':\nreturn data.decode()\nelif identifier == b'03':\nreturn pickle.loads(data)\nelif identifier == b'04':\nreturn cloudpickle.loads(data)\nelse:\nraise SerializationError(\nf'Unknown identifier {identifier!r} for deserialization,',\n)\n</code></pre>"},{"location":"api/timer/","title":"proxystore.timer","text":"<code>proxystore/timer.py</code> <p>Timing utilities.</p>"},{"location":"api/timer/#proxystore.timer.Timer","title":"Timer","text":"<pre><code>Timer() -&gt; None\n</code></pre> <p>Performance timer with nanosecond precision.</p> Example <pre><code>from proxystore.timer import Timer\nwith Timer() as timer:\n...\nprint(timer.elapsed_ms)\n</code></pre> Example <pre><code>from proxystore.timer import Timer\ntimer = Timer()\ntimer.start()\n...\ntimer.stop()\nprint(timer.elapsed_ms)\n</code></pre> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013         <p>If the elapsed time is accessed before the timer is stopped or the context block is exited.</p> </li> </ul> Source code in <code>proxystore/timer.py</code> <pre><code>def __init__(self) -&gt; None:\nself._start = 0\nself._end = 0\nself._running = False\n</code></pre>"},{"location":"api/timer/#proxystore.timer.Timer.elapsed_ns","title":"elapsed_ns  <code>property</code>","text":"<pre><code>elapsed_ns: int\n</code></pre> <p>Elapsed time in nanoseconds.</p>"},{"location":"api/timer/#proxystore.timer.Timer.elapsed_ms","title":"elapsed_ms  <code>property</code>","text":"<pre><code>elapsed_ms: float\n</code></pre> <p>Elapsed time in milliseconds.</p>"},{"location":"api/timer/#proxystore.timer.Timer.elapsed_s","title":"elapsed_s  <code>property</code>","text":"<pre><code>elapsed_s: float\n</code></pre> <p>Elapsed time in seconds.</p>"},{"location":"api/timer/#proxystore.timer.Timer.start","title":"start()","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the timer.</p> Source code in <code>proxystore/timer.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start the timer.\"\"\"\nself._running = True\nself._start = time.perf_counter_ns()\n</code></pre>"},{"location":"api/timer/#proxystore.timer.Timer.stop","title":"stop()","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the timer.</p> Source code in <code>proxystore/timer.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Stop the timer.\"\"\"\nself._end = time.perf_counter_ns()\nself._running = False\n</code></pre>"},{"location":"api/utils/","title":"proxystore.utils","text":"<code>proxystore/utils.py</code> <p>General purpose utility functions.</p>"},{"location":"api/utils/#proxystore.utils.chunk_bytes","title":"chunk_bytes()","text":"<pre><code>chunk_bytes(\ndata: bytes, chunk_size: int\n) -&gt; Generator[bytes, None, None]\n</code></pre> <p>Yield chunks of binary data.</p> <p>Parameters:</p> <ul> <li> data             (<code>bytes</code>)         \u2013 <p>Data to be chunked.</p> </li> <li> chunk_size             (<code>int</code>)         \u2013 <p>Chunk size in bytes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Generator[bytes, None, None]</code>         \u2013 <p>Generator that yields chunks of bytes.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def chunk_bytes(\ndata: bytes,\nchunk_size: int,\n) -&gt; Generator[bytes, None, None]:\n\"\"\"Yield chunks of binary data.\n    Args:\n        data: Data to be chunked.\n        chunk_size: Chunk size in bytes.\n    Returns:\n        Generator that yields chunks of bytes.\n    \"\"\"\nlength = len(data)\nfor index in range(0, length, chunk_size):\nyield data[index : min(index + chunk_size, length)]\n</code></pre>"},{"location":"api/utils/#proxystore.utils.get_class_path","title":"get_class_path()","text":"<pre><code>get_class_path(cls: type[Any]) -&gt; str\n</code></pre> <p>Get the fully qualified path of a type.</p> Example <pre><code>&gt;&gt;&gt; from proxystore.connectors.connector import Connector\n&gt;&gt;&gt; get_class_path(Connector)\n'proxystore.connectors.connector.Connector'\n</code></pre> <p>Parameters:</p> <ul> <li> cls             (<code>type[Any]</code>)         \u2013 <p>Class type to get fully qualified path of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Fully qualified path of <code>cls</code>.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def get_class_path(cls: type[Any]) -&gt; str:\n\"\"\"Get the fully qualified path of a type.\n    Example:\n        ```python\n        &gt;&gt;&gt; from proxystore.connectors.connector import Connector\n        &gt;&gt;&gt; get_class_path(Connector)\n        'proxystore.connectors.connector.Connector'\n        ```\n    Args:\n        cls: Class type to get fully qualified path of.\n    Returns:\n        Fully qualified path of `cls`.\n    \"\"\"\nreturn f'{cls.__module__}.{cls.__qualname__}'\n</code></pre>"},{"location":"api/utils/#proxystore.utils.import_class","title":"import_class()","text":"<pre><code>import_class(path: str) -&gt; type[Any]\n</code></pre> <p>Import class via its fully qualified path.</p> Example <pre><code>&gt;&gt;&gt; import_class('proxystore.connectors.connector.Connector')\n&lt;class 'proxystore.connectors.connector.Connector'&gt;\n</code></pre> <p>Parameters:</p> <ul> <li> path             (<code>str</code>)         \u2013 <p>Fully qualified path of class to import.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Any]</code>         \u2013 <p>Imported class.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ImportError</code>           \u2013         <p>If a class at the <code>path</code> is not found.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def import_class(path: str) -&gt; type[Any]:\n\"\"\"Import class via its fully qualified path.\n    Example:\n        ```python\n        &gt;&gt;&gt; import_class('proxystore.connectors.connector.Connector')\n        &lt;class 'proxystore.connectors.connector.Connector'&gt;\n        ```\n    Args:\n        path: Fully qualified path of class to import.\n    Returns:\n        Imported class.\n    Raises:\n        ImportError: If a class at the `path` is not found.\n    \"\"\"\nmodule_path, _, name = path.rpartition('.')\nif len(module_path) == 0:\nraise ImportError(\nf'Class path must contain at least one module. Got {path}',\n)\nmodule = importlib.import_module(module_path)\nreturn getattr(module, name)\n</code></pre>"},{"location":"api/utils/#proxystore.utils.home_dir","title":"home_dir()","text":"<pre><code>home_dir() -&gt; str\n</code></pre> <p>Return the absolute path to the proxystore home directory.</p> <p>If set, <code>$PROXYSTORE_HOME</code> is preferred. Otherwise, <code>$XDG_DATA_HOME/proxystore</code> is returned where <code>$XDG_DATA_HOME</code> defaults to <code>$HOME/.local/share</code> if unset.</p> Source code in <code>proxystore/utils.py</code> <pre><code>def home_dir() -&gt; str:\n\"\"\"Return the absolute path to the proxystore home directory.\n    If set, `$PROXYSTORE_HOME` is preferred. Otherwise,\n    `$XDG_DATA_HOME/proxystore` is returned where `$XDG_DATA_HOME` defaults\n    to `$HOME/.local/share` if unset.\n    \"\"\"\npath = os.environ.get('PROXYSTORE_HOME')\nif path is None:\nprefix = os.environ.get('XDG_DATA_HOME') or os.path.expanduser(\n'~/.local/share',\n)\npath = os.path.join(prefix, 'proxystore')\nreturn os.path.abspath(path)\n</code></pre>"},{"location":"api/utils/#proxystore.utils.hostname","title":"hostname()","text":"<pre><code>hostname() -&gt; str\n</code></pre> <p>Return current hostname.</p> Source code in <code>proxystore/utils.py</code> <pre><code>def hostname() -&gt; str:\n\"\"\"Return current hostname.\"\"\"\nreturn socket.gethostname()\n</code></pre>"},{"location":"api/utils/#proxystore.utils.bytes_to_readable","title":"bytes_to_readable()","text":"<pre><code>bytes_to_readable(size: int, precision: int = 3) -&gt; str\n</code></pre> <p>Convert bytes to human readable value.</p> Note <p>This method uses base-10 values for KB, MB, GB, etc. instead of base-2 values (i.e., KiB, MiB, GiB, etc.).</p> <p>Parameters:</p> <ul> <li> size             (<code>int</code>)         \u2013 <p>Byte value to make readable.</p> </li> <li> precision             (<code>int</code>)         \u2013 <p>Number of decimal places.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>String with human readable number of bytes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If size is negative.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def bytes_to_readable(size: int, precision: int = 3) -&gt; str:\n\"\"\"Convert bytes to human readable value.\n    Note:\n        This method uses base-10 values for KB, MB, GB, etc. instead of\n        base-2 values (i.e., KiB, MiB, GiB, etc.).\n    Args:\n        size: Byte value to make readable.\n        precision: Number of decimal places.\n    Returns:\n        String with human readable number of bytes.\n    Raises:\n        ValueError: If size is negative.\n    \"\"\"\nkb = int(1e3)\nmb = int(1e6)\ngb = int(1e9)\ntb = int(1e12)\nsize_ = float(size)\nif 0 &lt;= size &lt; kb:\nsuffix = 'B'\nelif kb &lt;= size &lt; mb:\nsuffix = 'KB'\nsize_ /= kb\nelif mb &lt;= size &lt; gb:\nsuffix = 'MB'\nsize_ /= mb\nelif gb &lt;= size &lt; tb:\nsuffix = 'GB'\nsize_ /= gb\nelif tb &lt;= size:\nsuffix = 'TB'\nsize_ /= tb\nelse:\nraise ValueError(f'Size ({size}) cannot be negative.')\nvalue = str(round(size_, precision))\nvalue = value.rstrip('0').rstrip('.')\nreturn f'{value} {suffix}'\n</code></pre>"},{"location":"api/utils/#proxystore.utils.readable_to_bytes","title":"readable_to_bytes()","text":"<pre><code>readable_to_bytes(size: str) -&gt; int\n</code></pre> <p>Convert string with bytes units to the integer value of bytes.</p> Example <pre><code>&gt;&gt;&gt; readable_to_bytes('1.2 KB')\n1200\n&gt;&gt;&gt; readable_to_bytes('0.6 MiB')\n629146\n</code></pre> <p>Parameters:</p> <ul> <li> size             (<code>str</code>)         \u2013 <p>String to parse for bytes size.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Integer number of bytes parsed from the string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the input string contains more than two parts (i.e., a value and a unit).</p> </li> <li> <code>ValueError</code>           \u2013         <p>If the unit is not one of KB, MB, GB, TB, KiB, MiB, GiB, or TiB.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If the value cannot be cast to a float.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def readable_to_bytes(size: str) -&gt; int:\n\"\"\"Convert string with bytes units to the integer value of bytes.\n    Example:\n        ```python\n        &gt;&gt;&gt; readable_to_bytes('1.2 KB')\n        1200\n        &gt;&gt;&gt; readable_to_bytes('0.6 MiB')\n        629146\n        ```\n    Args:\n        size: String to parse for bytes size.\n    Returns:\n        Integer number of bytes parsed from the string.\n    Raises:\n        ValueError: If the input string contains more than two parts (i.e., a\n            value and a unit).\n        ValueError: If the unit is not one of KB, MB, GB, TB, KiB, MiB, GiB,\n            or TiB.\n        ValueError: If the value cannot be cast to a float.\n    \"\"\"\nunits_to_bytes = {\n'b': 1,\n'kb': int(1e3),\n'mb': int(1e6),\n'gb': int(1e9),\n'tb': int(1e12),\n'kib': int(2**10),\n'mib': int(2**20),\n'gib': int(2**30),\n'tib': int(2**40),\n}\n# Try casting size to value (will only work if no units)\ntry:\nreturn int(float(size))\nexcept ValueError:\npass\n# Ensure space between value and unit\nsize = re.sub(r'([a-zA-Z]+)', r' \\1', size.strip())\nparts = [s.strip() for s in size.split()]\nif len(parts) != 2:\nraise ValueError(\n'Input string \"{size}\" must contain only a value and a unit.',\n)\nvalue, unit = parts\ntry:\nvalue_size = decimal.Decimal(value)\nexcept decimal.InvalidOperation as e:\nraise ValueError(f'Unable to interpret \"{value}\" as a float.') from e\ntry:\nunit_size = units_to_bytes[unit.lower()]\nexcept KeyError as e:\nraise ValueError(f'Unknown unit type {unit}.') from e\nreturn int(value_size * unit_size)\n</code></pre>"},{"location":"api/warnings/","title":"proxystore.warnings","text":"<code>proxystore/warnings.py</code> <p>Warning types.</p>"},{"location":"api/warnings/#proxystore.warnings.ExperimentalWarning","title":"ExperimentalWarning","text":"<p>         Bases: <code>Warning</code></p> <p>ProxyStore experimental feature warning.</p>"},{"location":"api/connectors/","title":"proxystore.connectors","text":"<code>proxystore/connectors/__init__.py</code> <p>Connector implementations.</p> <p>A <code>Connector</code> is an interface to a mediated communication channel or object store. Connectors operate on low-level bytes and are used by the <code>Store</code> to store and get serialized Python objects.</p> <p>Third-party code can provide custom connectors by implementing the <code>Connector</code> protocol. (Note: because <code>Connector</code> is a <code>Protocol</code>, custom connectors do not need to inherit from <code>Connector</code>.)</p> Example <pre><code>from proxystore.connectors.file import FileConnector\nconnector = FileConnector('./data-store')\nkey = connector.put(b'hello')\nconnector.get(key)\n&gt;&gt;&gt; b'hello'\nconnector.evict(key)\nconnector.exists(key)\n&gt;&gt;&gt; False\nconnector.close()\n</code></pre> Tip <p>All of the <code>Connector</code> implementations in this module can be used as context managers. Context manager support is not a required component of the <code>Connector</code> protocol. It is simply provided for convenience with the native implementations. <pre><code>from proxystore.connectors.file import FileConnector\nwith FileConnector('./data-store') as connector:\n# connector.close() will be automatically called when the\n# context manager is exited\n...\n</code></pre></p>"},{"location":"api/connectors/connector/","title":"proxystore.connectors.connector","text":"<code>proxystore/connectors/connector.py</code> <p>Connector protocol.</p>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector","title":"Connector","text":"<p>         Bases: <code>Protocol[KeyT]</code></p> <p>Connector protocol for interfacing with external object storage.</p> <p>The Connector protocol defines the interface for interacting with a byte-level object store.</p>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>Connector configuration.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    Returns:\n        Connector configuration.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; Connector[Any]\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Connector[Any]</code>         \u2013 <p>Connector instance.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; Connector[Any]:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    Returns:\n        Connector instance.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.evict","title":"evict()","text":"<pre><code>evict(key: KeyT) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def evict(self, key: KeyT) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.exists","title":"exists()","text":"<pre><code>exists(key: KeyT) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def exists(self, key: KeyT) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.get","title":"get()","text":"<pre><code>get(key: KeyT) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def get(self, key: KeyT) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[KeyT]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[KeyT]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def get_batch(self, keys: Sequence[KeyT]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; KeyT\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>KeyT</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def put(self, obj: bytes) -&gt; KeyT:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[KeyT]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[KeyT]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[KeyT]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/endpoint/","title":"proxystore.connectors.endpoint","text":"<code>proxystore/connectors/endpoint.py</code> <p>Endpoint connector implementation.</p>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnectorError","title":"EndpointConnectorError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception resulting from request to Endpoint.</p>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointKey","title":"EndpointKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to object in an Endpoint.</p> <p>Attributes:</p> <ul> <li> object_id             (<code>str</code>)         \u2013 <p>Unique object ID.</p> </li> <li> endpoint_id             (<code>str | None</code>)         \u2013 <p>Endpoint UUID where object is stored.</p> </li> </ul>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector","title":"EndpointConnector","text":"<pre><code>EndpointConnector(\nendpoints: Sequence[str | UUID],\nproxystore_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>Connector to ProxyStore Endpoints.</p> Warning <p>Specifying a custom <code>proxystore_dir</code> can cause problems if the <code>proxystore_dir</code> is not the same on all systems that a proxy created by this store could end up on. It is recommended to leave the <code>proxystore_dir</code> unspecified so the correct default directory will be used.</p> <p>Parameters:</p> <ul> <li> endpoints             (<code>Sequence[str | UUID]</code>)         \u2013 <p>Sequence of valid and running endpoint UUIDs to use. At least one of these endpoints must be accessible by this process.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If endpoints is an empty list.</p> </li> <li> <code>EndpointConnectorError</code>           \u2013         <p>If unable to connect to one of the endpoints provided.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def __init__(\nself,\nendpoints: Sequence[str | UUID],\nproxystore_dir: str | None = None,\n) -&gt; None:\nif len(endpoints) == 0:\nraise ValueError('At least one endpoint must be specified.')\nself.endpoints: list[UUID] = [\ne if isinstance(e, UUID) else UUID(e, version=4) for e in endpoints\n]\nself.proxystore_dir = proxystore_dir\n# Maintain single session for connection pooling persistence to\n# speed up repeat requests to same endpoint.\nself._session = requests.Session()\n# Find the first locally accessible endpoint to use as our\n# home endpoint\navailable_endpoints = get_configs(\nhome_dir() if self.proxystore_dir is None else self.proxystore_dir,\n)\nfound_endpoint: EndpointConfig | None = None\nfor endpoint in available_endpoints:\nif endpoint.uuid in self.endpoints:\nlogger.debug(f'Attempting connection to {endpoint.uuid}')\nresponse = self._session.get(\nf'http://{endpoint.host}:{endpoint.port}/endpoint',\n)\nif response.status_code == 200:\nuuid = response.json()['uuid']\nif str(endpoint.uuid) == uuid:\nlogger.debug(\nf'Connection to {endpoint.uuid} successful, using '\n'as local endpoint',\n)\nfound_endpoint = endpoint\nbreak\nelse:\nlogger.debug(\nf'Connection to {endpoint.uuid} returned '\n'different UUID',\n)\nelse:\nlogger.debug(f'Connection to {endpoint.uuid} failed')\nif found_endpoint is None:\nself._session.close()\nraise EndpointConnectorError(\n'Failed to find endpoint configuration matching one of the '\n'provided endpoint UUIDs.',\n)\nself.endpoint_uuid = found_endpoint.uuid\nself.endpoint_host = found_endpoint.host\nself.endpoint_port = found_endpoint.port\nself.address = f'http://{self.endpoint_host}:{self.endpoint_port}'\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\"\"\"\nself._session.close()\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {\n'endpoints': [str(ep) for ep in self.endpoints],\n'proxystore_dir': self.proxystore_dir,\n}\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; EndpointConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; EndpointConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.evict","title":"evict()","text":"<pre><code>evict(key: EndpointKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>EndpointKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def evict(self, key: EndpointKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\ntry:\nclient.evict(\nself.address,\nkey.object_id,\nkey.endpoint_id,\nsession=self._session,\n)\nexcept requests.exceptions.RequestException as e:\nraise EndpointConnectorError(\nf'Evict failed with error code {e.response.status_code}.',\n) from e\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.exists","title":"exists()","text":"<pre><code>exists(key: EndpointKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>EndpointKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def exists(self, key: EndpointKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\ntry:\nreturn client.exists(\nself.address,\nkey.object_id,\nkey.endpoint_id,\nsession=self._session,\n)\nexcept requests.exceptions.RequestException as e:\nraise EndpointConnectorError(\nf'Exists failed with error code {e.response.status_code}.',\n) from e\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.get","title":"get()","text":"<pre><code>get(key: EndpointKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>EndpointKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def get(self, key: EndpointKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\ntry:\nreturn client.get(\nself.address,\nkey.object_id,\nkey.endpoint_id,\nsession=self._session,\n)\nexcept requests.exceptions.RequestException as e:\nraise EndpointConnectorError(\nf'Get failed with error code {e.response.status_code}.',\n) from e\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(\nkeys: Sequence[EndpointKey],\n) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[EndpointKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def get_batch(self, keys: Sequence[EndpointKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; EndpointKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EndpointKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def put(self, obj: bytes) -&gt; EndpointKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = EndpointKey(\nobject_id=str(uuid.uuid4()),\nendpoint_id=str(self.endpoint_uuid),\n)\ntry:\nclient.put(\nself.address,\nkey.object_id,\nobj,\nkey.endpoint_id,\nsession=self._session,\n)\nexcept requests.exceptions.RequestException as e:\nraise EndpointConnectorError(\nf'Put failed with error code {e.response.status_code}.',\n) from e\nreturn key\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[EndpointKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[EndpointKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[EndpointKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\nreturn [self.put(obj) for obj in objs]\n</code></pre>"},{"location":"api/connectors/file/","title":"proxystore.connectors.file","text":"<code>proxystore/connectors/file.py</code> <p>File system connector implementation.</p>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileKey","title":"FileKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in a file system directory.</p> <p>Attributes:</p> <ul> <li> filename             (<code>str</code>)         \u2013 <p>Unique object filename.</p> </li> </ul>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector","title":"FileConnector","text":"<pre><code>FileConnector(store_dir: str) -&gt; None\n</code></pre> <p>Connector to shared file system.</p> <p>Parameters:</p> <ul> <li> store_dir             (<code>str</code>)         \u2013 <p>Path to directory to store data in. Note this directory will be deleted upon closing the store.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def __init__(self, store_dir: str) -&gt; None:\nself.store_dir = os.path.abspath(store_dir)\nif not os.path.exists(self.store_dir):\nos.makedirs(self.store_dir, exist_ok=True)\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Warning <p>This will delete the <code>store_dir</code> directory.</p> Warning <p>This method should only be called at the end of the program when the connector will no longer be used, for example once all proxies have been resolved.</p> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\n    Warning:\n        This will delete the `store_dir` directory.\n    Warning:\n        This method should only be called at the end of the program\n        when the connector will no longer be used, for example once all\n        proxies have been resolved.\n    \"\"\"\nshutil.rmtree(self.store_dir)\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {'store_dir': self.store_dir}\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; FileConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; FileConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.evict","title":"evict()","text":"<pre><code>evict(key: FileKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>FileKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def evict(self, key: FileKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\npath = os.path.join(self.store_dir, key.filename)\nif os.path.exists(path):\nos.remove(path)\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.exists","title":"exists()","text":"<pre><code>exists(key: FileKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>FileKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def exists(self, key: FileKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\npath = os.path.join(self.store_dir, key.filename)\nreturn os.path.exists(path)\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.get","title":"get()","text":"<pre><code>get(key: FileKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>FileKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def get(self, key: FileKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\npath = os.path.join(self.store_dir, key.filename)\nif os.path.exists(path):\nwith open(path, 'rb') as f:\ndata = f.read()\nreturn data\nreturn None\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[FileKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[FileKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def get_batch(self, keys: Sequence[FileKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; FileKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FileKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def put(self, obj: bytes) -&gt; FileKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = FileKey(filename=str(uuid.uuid4()))\npath = os.path.join(self.store_dir, key.filename)\nwith open(path, 'wb', buffering=0) as f:\nf.write(obj)\nreturn key\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[FileKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[FileKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[FileKey]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[FileKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    \"\"\"\nreturn [self.put(obj) for obj in objs]\n</code></pre>"},{"location":"api/connectors/globus/","title":"proxystore.connectors.globus","text":"<code>proxystore/connectors/globus.py</code> <p>Globus transfer connector implementation.</p>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoint","title":"GlobusEndpoint","text":"<pre><code>GlobusEndpoint(\nuuid: str,\nendpoint_path: str,\nlocal_path: str | None,\nhost_regex: str | Pattern[str],\n) -&gt; None\n</code></pre> <p>Globus endpoint representation.</p> <p>Parameters:</p> <ul> <li> uuid             (<code>str</code>)         \u2013 <p>UUID of Globus endpoint.</p> </li> <li> endpoint_path             (<code>str</code>)         \u2013 <p>Path within endpoint to directory to use for storing objects.</p> </li> <li> local_path             (<code>str | None</code>)         \u2013 <p>Local path (as seen by the host filesystem) that corresponds to the directory specified by <code>endpoint_path</code>.</p> </li> <li> host_regex             (<code>str | Pattern[str]</code>)         \u2013 <p>String that matches the host where the Globus endpoint exists or regex pattern than can be used to match the host. The host pattern is needed so that proxies can figure out what the local endpoint is when they are resolved.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def __init__(\nself,\nuuid: str,\nendpoint_path: str,\nlocal_path: str | None,\nhost_regex: str | Pattern[str],\n) -&gt; None:\nif not isinstance(uuid, str):\nraise TypeError('uuid must be a str.')\nif not isinstance(endpoint_path, str):\nraise TypeError('endpoint_path must be a str.')\nif not isinstance(local_path, str):\nraise TypeError('local_path must be a str.')\nif not (\nisinstance(host_regex, str) or isinstance(host_regex, Pattern)\n):\nraise TypeError('host_regex must be a str or re.Pattern.')\nself.uuid = uuid\nself.endpoint_path = endpoint_path\nself.local_path = local_path\nself.host_regex = host_regex\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoints","title":"GlobusEndpoints","text":"<pre><code>GlobusEndpoints(\nendpoints: Collection[GlobusEndpoint],\n) -&gt; None\n</code></pre> <p>A collection of Globus endpoints.</p> <p>Parameters:</p> <ul> <li> endpoints             (<code>Collection[GlobusEndpoint]</code>)         \u2013 <p>Iterable of <code>GlobusEndpoints</code> instances.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>endpoints</code> has length 0 or if multiple endpoints with             the same UUID are provided.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def __init__(self, endpoints: Collection[GlobusEndpoint]) -&gt; None:\nif len(endpoints) == 0:\nraise ValueError(\n'GlobusEndpoints must be passed at least one GlobusEndpoint '\n'object',\n)\nself._endpoints: dict[str, GlobusEndpoint] = {}\nfor endpoint in endpoints:\nif endpoint.uuid in self._endpoints:\nraise ValueError(\n'Cannot pass multiple GlobusEndpoint objects with the '\n'same Globus endpoint UUID.',\n)\nself._endpoints[endpoint.uuid] = endpoint\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoints.from_dict","title":"from_dict()  <code>classmethod</code>","text":"<pre><code>from_dict(\njson_object: dict[str, dict[str, str]]\n) -&gt; GlobusEndpoints\n</code></pre> <p>Construct an endpoints collection from a dictionary.</p> Example <pre><code>{\n\"endpoint-uuid-1\": {\n\"host_regex\": \"host1-regex\",\n\"endpoint_path\": \"/path/to/endpoint/dir\",\n\"local_path\": \"/path/to/local/dir\"\n},\n\"endpoint-uuid-2\": {\n\"host_regex\": \"host2-regex\",\n\"endpoint_path\": \"/path/to/endpoint/dir\",\n\"local_path\": \"/path/to/local/dir\"\n}\n}\n</code></pre> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>@classmethod\ndef from_dict(\ncls: type[GlobusEndpoints],\njson_object: dict[str, dict[str, str]],\n) -&gt; GlobusEndpoints:\n\"\"\"Construct an endpoints collection from a dictionary.\n    Example:\n        ```python\n        {\n          \"endpoint-uuid-1\": {\n            \"host_regex\": \"host1-regex\",\n            \"endpoint_path\": \"/path/to/endpoint/dir\",\n            \"local_path\": \"/path/to/local/dir\"\n          },\n          \"endpoint-uuid-2\": {\n            \"host_regex\": \"host2-regex\",\n            \"endpoint_path\": \"/path/to/endpoint/dir\",\n            \"local_path\": \"/path/to/local/dir\"\n          }\n        }\n        ```\n    \"\"\"  # noqa: D412\nendpoints = []\nfor ep_uuid, params in json_object.items():\nendpoints.append(\nGlobusEndpoint(\nuuid=ep_uuid,\nendpoint_path=params['endpoint_path'],\nlocal_path=params['local_path'],\nhost_regex=params['host_regex'],\n),\n)\nreturn GlobusEndpoints(endpoints)\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoints.from_json","title":"from_json()  <code>classmethod</code>","text":"<pre><code>from_json(json_file: str) -&gt; GlobusEndpoints\n</code></pre> <p>Construct a GlobusEndpoints object from a json file.</p> <p>The <code>dict</code> read from the JSON file will be passed to <code>from_dict()</code> and should match the format expected by <code>from_dict()</code>.</p> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>@classmethod\ndef from_json(cls, json_file: str) -&gt; GlobusEndpoints:\n\"\"\"Construct a GlobusEndpoints object from a json file.\n    The `dict` read from the JSON file will be passed to\n    [`from_dict()`][proxystore.store.globus.GlobusEndpoints.from_dict] and\n    should match the format expected by\n    [`from_dict()`][proxystore.store.globus.GlobusEndpoints.from_dict].\n    \"\"\"\nwith open(json_file) as f:\ndata = f.read()\nreturn cls.from_dict(json.loads(data))\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoints.dict","title":"dict()","text":"<pre><code>dict() -&gt; dict[str, dict[str, str]]\n</code></pre> <p>Convert the GlobusEndpoints to a dict.</p> <p>Note that the <code>GlobusEndpoints</code> object can be reconstructed by passing the <code>dict</code> to. <code>from_dict()</code>.</p> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def dict(self) -&gt; dict[str, dict[str, str]]:\n\"\"\"Convert the GlobusEndpoints to a dict.\n    Note that the\n    [`GlobusEndpoints`][proxystore.store.globus.GlobusEndpoints]\n    object can be reconstructed by passing the `dict` to.\n    [`from_dict()`][proxystore.store.globus.GlobusEndpoints.from_dict].\n    \"\"\"\ndata = {}\nfor endpoint in self:\ndata[endpoint.uuid] = {\n'endpoint_path': endpoint.endpoint_path,\n'local_path': endpoint.local_path,\n'host_regex': endpoint.host_regex.pattern\nif isinstance(endpoint.host_regex, Pattern)\nelse endpoint.host_regex,\n}\nreturn data\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoints.get_by_host","title":"get_by_host()","text":"<pre><code>get_by_host(host: str) -&gt; GlobusEndpoint\n</code></pre> <p>Get endpoint by host.</p> <p>Searches the endpoints for a endpoint who's <code>host_regex</code> matches <code>host</code>.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>Host to match.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GlobusEndpoint</code>         \u2013 <p>Globus endpoint.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>host</code> does not match any of the endpoints.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def get_by_host(self, host: str) -&gt; GlobusEndpoint:\n\"\"\"Get endpoint by host.\n    Searches the endpoints for a endpoint who's `host_regex` matches\n    `host`.\n    Args:\n        host: Host to match.\n    Returns:\n        Globus endpoint.\n    Raises:\n        ValueError: If `host` does not match any of the endpoints.\n    \"\"\"\nfor endpoint in self._endpoints.values():\nif re.fullmatch(endpoint.host_regex, host) is not None:\nreturn endpoint\nraise ValueError(f'Cannot find endpoint matching host {host}')\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusKey","title":"GlobusKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to object transferred with Globus.</p> <p>Attributes:</p> <ul> <li> filename             (<code>str</code>)         \u2013 <p>Unique object filename.</p> </li> <li> task_id             (<code>str</code>)         \u2013 <p>Globus transfer task ID for the file.</p> </li> </ul>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusKey.__eq__","title":"__eq__()","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> <p>Match keys by filename only.</p> <p>This is a hack around the fact that the task_id is not created until after the filename is so there can be a state where the task_id is empty.</p> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Match keys by filename only.\n    This is a hack around the fact that the task_id is not created until\n    after the filename is so there can be a state where the task_id\n    is empty.\n    \"\"\"\nif isinstance(other, tuple):\nreturn self[0] == other[0]\nreturn False\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector","title":"GlobusConnector","text":"<pre><code>GlobusConnector(\nendpoints: GlobusEndpoints\n| list[GlobusEndpoint]\n| dict[str, dict[str, str]],\npolling_interval: int = 1,\nsync_level: int\n| Literal[\n\"exists\", \"size\", \"mtime\", \"checksum\"\n] = \"mtime\",\ntimeout: int = 60,\n) -&gt; None\n</code></pre> <p>Globus transfer connector.</p> <p>The <code>GlobusConnector</code> is similar to a <code>FileConnector</code> in that objects are saved to disk but allows for the transfer of objects between two remote file systems. The two directories on the separate file systems are kept in sync via Globus transfers. The <code>GlobusConnector</code> is useful when moving data between hosts that have a Globus endpoint but may have restrictions that prevent the use of other store backends (e.g., ports cannot be opened for using a <code>RedisConnector</code>.</p> Note <p>To use Globus for data transfer, Globus authentication needs to be performed otherwise an error will be raised. Authentication can be performed on the command line with <code>proxystore-globus-auth</code>. Authentication only needs to be performed once per system.</p> <p>Parameters:</p> <ul> <li> endpoints             (<code>GlobusEndpoints | list[GlobusEndpoint] | dict[str, dict[str, str]]</code>)         \u2013 <p>Globus endpoints to keep in sync. If passed as a <code>dict</code>, the dictionary must match the format expected by <code>GlobusEndpoints.from_dict()</code>.</p> </li> <li> polling_interval             (<code>int</code>)         \u2013 <p>Interval in seconds to check if Globus tasks have finished.</p> </li> <li> sync_level             (<code>int | Literal['exists', 'size', 'mtime', 'checksum']</code>)         \u2013 <p>Globus transfer sync level.</p> </li> <li> timeout             (<code>int</code>)         \u2013 <p>Timeout in seconds for waiting on Globus tasks.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>GlobusAuthFileError</code>           \u2013         <p>If the Globus authentication file cannot be found.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If <code>endpoints</code> is of an incorrect type.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If the <code>len(endpoints) != 2</code> because this implementation can currently only keep two endpoints in sync.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def __init__(\nself,\nendpoints: GlobusEndpoints\n| list[GlobusEndpoint]\n| dict[str, dict[str, str]],\npolling_interval: int = 1,\nsync_level: int\n| Literal['exists', 'size', 'mtime', 'checksum'] = 'mtime',\ntimeout: int = 60,\n) -&gt; None:\nif isinstance(endpoints, GlobusEndpoints):\nself.endpoints = endpoints\nelif isinstance(endpoints, list):\nself.endpoints = GlobusEndpoints(endpoints)\nelif isinstance(endpoints, dict):\nself.endpoints = GlobusEndpoints.from_dict(endpoints)\nelse:\nraise ValueError(\n'endpoints must be of type GlobusEndpoints or a list of '\nf'GlobusEndpoint. Got {type(endpoints)}.',\n)\nif len(endpoints) != 2:\nraise ValueError(\n'ProxyStore only supports two endpoints at a time',\n)\nself.polling_interval = polling_interval\nself.sync_level = sync_level\nself.timeout = timeout\ntry:\nauthorizer = get_proxystore_authorizer()\nexcept GlobusAuthFileError as e:\nraise GlobusAuthFileError(\n'Error loading Globus auth tokens. Complete the '\n'authentication process with the proxystore-globus-auth tool.',\n) from e\nself._transfer_client = globus_sdk.TransferClient(\nauthorizer=authorizer,\n)\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Warning <p>This will delete the directory at <code>local_path</code> on each endpoint.</p> Warning <p>This method should only be called at the end of the program when the store will no longer be used, for example once all proxies have been resolved.</p> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\n    Warning:\n        This will delete the directory at `local_path` on each endpoint.\n    Warning:\n        This method should only be called at the end of the program when\n        the store will no longer be used, for example once all proxies\n        have been resolved.\n    \"\"\"\nfor endpoint in self.endpoints:\ndelete_task = globus_sdk.DeleteData(\nself._transfer_client,\nendpoint=endpoint.uuid,\nrecursive=True,\n)\ndelete_task['notify_on_succeeded'] = False\ndelete_task['notify_on_failed'] = False\ndelete_task['notify_on_inactive'] = False\ndelete_task.add_item(endpoint.endpoint_path)\ntdata = _submit_transfer_action(self._transfer_client, delete_task)\nself._wait_on_tasks(tdata['task_id'])\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {\n'endpoints': self.endpoints.dict(),\n'polling_interval': self.polling_interval,\n'sync_level': self.sync_level,\n'timeout': self.timeout,\n}\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; GlobusConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; GlobusConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.evict","title":"evict()","text":"<pre><code>evict(key: GlobusKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>GlobusKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def evict(self, key: GlobusKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nif not self.exists(key):\nreturn\npath = self._get_filepath(key.filename)\nos.remove(path)\nself._transfer_files(key.filename, delete=True)\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.exists","title":"exists()","text":"<pre><code>exists(key: GlobusKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> Note <p>If the corresponding Globus transfer is still in progress, this method will wait to make sure the transfers is successful.</p> <p>Parameters:</p> <ul> <li> key             (<code>GlobusKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def exists(self, key: GlobusKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Note:\n        If the corresponding Globus transfer is still in progress, this\n        method will wait to make sure the transfers is successful.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nif not self._validate_task_id(key.task_id):\nreturn False\nself._wait_on_tasks(key.task_id)\nreturn os.path.exists(self._get_filepath(key.filename))\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.get","title":"get()","text":"<pre><code>get(key: GlobusKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>GlobusKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def get(self, key: GlobusKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nif not self.exists(key):\nreturn None\npath = self._get_filepath(key.filename)\nwith open(path, 'rb') as f:\nreturn f.read()\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[GlobusKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[GlobusKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def get_batch(self, keys: Sequence[GlobusKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; GlobusKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GlobusKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def put(self, obj: bytes) -&gt; GlobusKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nfilename = str(uuid.uuid4())\npath = self._get_filepath(filename)\nos.makedirs(os.path.dirname(path), exist_ok=True)\nwith open(path, 'wb', buffering=0) as f:\nf.write(obj)\ntask_id = self._transfer_files(filename)\nreturn GlobusKey(filename=filename, task_id=task_id)\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[GlobusKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[GlobusKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[GlobusKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\nfilenames = [str(uuid.uuid4()) for _ in objs]\nfor filename, obj in zip(filenames, objs):\npath = self._get_filepath(filename)\nos.makedirs(os.path.dirname(path), exist_ok=True)\nwith open(path, 'wb', buffering=0) as f:\nf.write(obj)\ntask_id = self._transfer_files(filenames)\nreturn [\nGlobusKey(filename=filename, task_id=task_id)\nfor filename in filenames\n]\n</code></pre>"},{"location":"api/connectors/local/","title":"proxystore.connectors.local","text":"<code>proxystore/connectors/local.py</code> <p>In-process local storage connector implementation.</p>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalKey","title":"LocalKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects store in a <code>LocalConnector</code>.</p> <p>Attributes:</p> <ul> <li> id             (<code>str</code>)         \u2013 <p>Unique object ID.</p> </li> </ul>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector","title":"LocalConnector","text":"<pre><code>LocalConnector(\nstore_dict: dict[LocalKey, bytes] | None = None\n) -&gt; None\n</code></pre> <p>Connector that store objects in the local process's memory.</p> Warning <p>This connector exists primarily for testing purposes.</p> <p>Parameters:</p> <ul> <li> store_dict             (<code>dict[LocalKey, bytes] | None</code>)         \u2013 <p>Dictionary to store data in. If not specified, a new empty dict will be generated.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def __init__(\nself,\nstore_dict: dict[LocalKey, bytes] | None = None,\n) -&gt; None:\nself._store: dict[LocalKey, bytes] = {}\nif store_dict is not None:\nself._store = store_dict\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\"\"\"\npass\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {'store_dict': self._store}\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; LocalConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; LocalConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.evict","title":"evict()","text":"<pre><code>evict(key: LocalKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>LocalKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def evict(self, key: LocalKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nif key in self._store:\ndel self._store[key]\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.exists","title":"exists()","text":"<pre><code>exists(key: LocalKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>LocalKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def exists(self, key: LocalKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nreturn key in self._store\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.get","title":"get()","text":"<pre><code>get(key: LocalKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>LocalKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def get(self, key: LocalKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nreturn self._store.get(key, None)\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[LocalKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[LocalKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def get_batch(self, keys: Sequence[LocalKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; LocalKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LocalKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def put(self, obj: bytes) -&gt; LocalKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = LocalKey(str(uuid.uuid4()))\nself._store[key] = obj\nreturn key\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[LocalKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[LocalKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[LocalKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\nreturn [self.put(obj) for obj in objs]\n</code></pre>"},{"location":"api/connectors/multi/","title":"proxystore.connectors.multi","text":"<code>proxystore/connectors/multi.py</code> <p>Multi-connector implementation.</p>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.ConnectorPolicyConfig","title":"ConnectorPolicyConfig  <code>module-attribute</code>","text":"<pre><code>ConnectorPolicyConfig = Tuple[\nstr, Dict[str, Any], PolicyDict\n]\n</code></pre> <p>Type of the configuration for a connector and policy pair.</p> <p>Element zero is the fully qualified path of the connector type, element one is the connector's configuration dictionary, and element two is the policy in dictionary form.</p>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.PolicyDict","title":"PolicyDict","text":"<p>         Bases: <code>TypedDict</code></p> <p>JSON compatible representation of a <code>Policy</code>.</p>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.Policy","title":"Policy  <code>dataclass</code>","text":"<p>Policy that allows validating a set of constraints.</p> <p>Attributes:</p> <ul> <li> priority             (<code>int</code>)         \u2013 <p>Priority for breaking ties between policies (higher is preferred).</p> </li> <li> host_pattern             (<code>Iterable[str] | str | None</code>)         \u2013 <p>Pattern or iterable of patterns of valid hostnames. The hostname returned by <code>hostname()</code> is matched against <code>host_pattern</code> using <code>re.fullmatch()</code>. If <code>host_pattern</code> is an iterable, at least one of the patterns must match the hostname.</p> </li> <li> min_size_bytes             (<code>int</code>)         \u2013 <p>Minimum size in bytes allowed.</p> </li> <li> max_size_bytes             (<code>int</code>)         \u2013 <p>Maximum size in bytes allowed.</p> </li> <li> subset_tags             (<code>list[str]</code>)         \u2013 <p>Subset tags. See <code>is_valid()</code> for more details.</p> </li> <li> superset_tags             (<code>list[str]</code>)         \u2013 <p>Superset tags. See <code>is_valid()</code> for more details.</p> </li> </ul>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.Policy.is_valid","title":"is_valid()","text":"<pre><code>is_valid(\n*,\nsize_bytes: int | None = None,\nsubset_tags: Iterable[str] | None = None,\nsuperset_tags: Iterable[str] | None = None\n) -&gt; bool\n</code></pre> <p>Check if set of contstraints is valid for this policy.</p> Note <p>All arguments are optional keyword arguments that default to <code>None</code>. If left as the default, that constraint will not be checked against the policy.</p> <p>Parameters:</p> <ul> <li> size_bytes             (<code>int | None</code>)         \u2013 <p>Object size in bytes.</p> </li> <li> subset_tags             (<code>Iterable[str] | None</code>)         \u2013 <p>Set of tags that must be a subset of the Policy's <code>subset_tags</code> to be valid.</p> </li> <li> superset_tags             (<code>Iterable[str] | None</code>)         \u2013 <p>Set of tags that must be a superset of the Policy's <code>superset_tags</code> to be valid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the provided constraints are valid for the policy.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def is_valid(\nself,\n*,\nsize_bytes: int | None = None,\nsubset_tags: Iterable[str] | None = None,\nsuperset_tags: Iterable[str] | None = None,\n) -&gt; bool:\n\"\"\"Check if set of contstraints is valid for this policy.\n    Note:\n        All arguments are optional keyword arguments that default to\n        `None`. If left as the default, that constraint will not be\n        checked against the policy.\n    Args:\n        size_bytes: Object size in bytes.\n        subset_tags: Set of tags that must be a subset\n            of the Policy's `subset_tags` to be valid.\n        superset_tags: Set of tags that must be a superset\n            of the Policy's `superset_tags` to be valid.\n    Returns:\n        If the provided constraints are valid for the policy.\n    \"\"\"\nif size_bytes is not None and (\nsize_bytes &lt; self.min_size_bytes\nor size_bytes &gt; self.max_size_bytes\n):\nreturn False\nif subset_tags is not None and not set(subset_tags).issubset(\nself.subset_tags,\n):\nreturn False\nif superset_tags is not None and not set(superset_tags).issuperset(\nself.superset_tags,\n):\nreturn False\nreturn self.is_valid_on_host()\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.Policy.is_valid_on_host","title":"is_valid_on_host()","text":"<pre><code>is_valid_on_host() -&gt; bool\n</code></pre> <p>Check if this policy is valid on the current host.</p> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def is_valid_on_host(self) -&gt; bool:\n\"\"\"Check if this policy is valid on the current host.\"\"\"\nif self.host_pattern is None:\nreturn True\npatterns: Iterable[str]\nif isinstance(self.host_pattern, str):\npatterns = [self.host_pattern]\nelse:\npatterns = self.host_pattern\nhostname = utils.hostname()\nreturn any(re.fullmatch(p, hostname) for p in patterns)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.Policy.as_dict","title":"as_dict()","text":"<pre><code>as_dict() -&gt; PolicyDict\n</code></pre> <p>Convert the Policy to a JSON compatible dict.</p> Example <pre><code>&gt;&gt;&gt; policy = Policy(...)\n&gt;&gt;&gt; policy_dict = policy.as_dict()\n&gt;&gt;&gt; Policy(**policy_dict) == policy\nTrue\n</code></pre> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def as_dict(self) -&gt; PolicyDict:\n\"\"\"Convert the Policy to a JSON compatible dict.\n    Example:\n        ```python\n        &gt;&gt;&gt; policy = Policy(...)\n        &gt;&gt;&gt; policy_dict = policy.as_dict()\n        &gt;&gt;&gt; Policy(**policy_dict) == policy\n        True\n        ```\n    \"\"\"\n# We could use dataclasses.asdict(self) but this gives us the benefit\n# of typing on the return dict.\nhost_pattern = (\nself.host_pattern\nif isinstance(self.host_pattern, str) or self.host_pattern is None\nelse list(self.host_pattern)\n)\nreturn PolicyDict(\npriority=self.priority,\nhost_pattern=host_pattern,\nmin_size_bytes=self.min_size_bytes,\nmax_size_bytes=self.max_size_bytes,\nsubset_tags=self.subset_tags,\nsuperset_tags=self.superset_tags,\n)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnectorError","title":"MultiConnectorError","text":"<p>         Bases: <code>Exception</code></p> <p>Exceptions raised by the <code>MultiConnector</code>.</p>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiKey","title":"MultiKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in <code>MultiConnector</code>.</p> <p>Attributes:</p> <ul> <li> connector_name             (<code>str</code>)         \u2013 <p>Name of connector that the associated object is stored in.</p> </li> <li> connector_key             (<code>Any</code>)         \u2013 <p>Key associated with the object.</p> </li> </ul>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector","title":"MultiConnector","text":"<pre><code>MultiConnector(\nconnectors: dict[str, tuple[Connector[Any], Policy]],\ndormant_connectors: dict[str, ConnectorPolicyConfig]\n| None = None,\n) -&gt; None\n</code></pre> <p>Policy based manager for a <code>Connector</code> collection.</p> Example <pre><code>from proxystore.connectors.file import FileConnector\nfrom proxystore.connectors.multi import Policy\nfrom proxystore.connectors.multi import MultiConnector\nfrom proxystore.connectors.redis import RedisConnector\nfile_connector = FileConnector(...)\nredis_connector = RedisConnector(...)\nconnectors = {\n'small': (file_connector, Policy(max_size_bytes=1000000)),\n'large': (redis_connector, Policy(min_size_bytes=1000000)),\n}\nconnector = MultiConnector(connector)\n</code></pre> Note <p>Methods of this class will raise <code>MultiConnectorError</code> if they are passed an invalid key where a key could be invalid because the connector which created the key is not known by this class instance or because the corresponding connector is dormant.</p> <p>Parameters:</p> <ul> <li> connectors             (<code>dict[str, tuple[Connector[Any], Policy]]</code>)         \u2013 <p>Mapping of names to tuples of a <code>Connector</code> and <code>Policy</code>.</p> </li> <li> dormant_connectors             (<code>dict[str, ConnectorPolicyConfig] | None</code>)         \u2013 <p>Mapping of names to tuples containing the configuration of a dormant connector. A dormant connector is a connector that is unused in this process, but could potentially be initialized and used on another process. For example, because the <code>host_pattern</code> of the policy does not match the current host. It is not recommended to create dormant connector configurations yourself. Rather, create your connectors and use the <code>host_pattern</code> of the policy to determine when a connector should be dormant.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def __init__(\nself,\nconnectors: dict[str, tuple[Connector[Any], Policy]],\ndormant_connectors: dict[str, ConnectorPolicyConfig] | None = None,\n) -&gt; None:\nself.connectors = {\nname: _ConnectorPolicy(connector, policy)\nfor name, (connector, policy) in connectors.items()\n}\nself.dormant_connectors = dormant_connectors\nnames = list(self.connectors.keys())\nself.connectors_by_priority = sorted(\nnames,\nkey=lambda name: self.connectors[name].policy.priority,\nreverse=True,\n)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Warning <p>This will call <code>close()</code> on all managed connectors.</p> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\n    Warning:\n        This will call `close()` on all managed connectors.\n    \"\"\"\nfor connector, _ in self.connectors.values():\nconnector.close()\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, ConnectorPolicyConfig]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def config(self) -&gt; dict[str, ConnectorPolicyConfig]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nconfigs: dict[str, ConnectorPolicyConfig] = (\nself.dormant_connectors\nif self.dormant_connectors is not None\nelse {}\n)\nconfigs.update(\n{\nname: (\nget_class_path(type(connector)),\nconnector.config(),\npolicy.as_dict(),\n)\nfor name, (connector, policy) in self.connectors.items()\n},\n)\nreturn configs\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(\nconfig: dict[str, ConnectorPolicyConfig]\n) -&gt; MultiConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, ConnectorPolicyConfig]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>@classmethod\ndef from_config(\ncls,\nconfig: dict[str, ConnectorPolicyConfig],\n) -&gt; MultiConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nconnectors: dict[str, tuple[Connector[Any], Policy]] = {}\ndormant_connectors: dict[str, ConnectorPolicyConfig] = {}\nfor name, (conn_path, conn_config, policy_dict) in config.items():\npolicy = Policy(**policy_dict)\nif policy.is_valid_on_host():\nconnector_type = import_class(conn_path)\nconnector = connector_type.from_config(conn_config)\nconnectors[name] = (connector, policy)\nelse:\ndormant_connectors[name] = config[name]\nreturn cls(\nconnectors=connectors,\ndormant_connectors=dormant_connectors,\n)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.evict","title":"evict()","text":"<pre><code>evict(key: MultiKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>MultiKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def evict(self, key: MultiKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nconnector = self._connector_from_key(key)\nconnector.evict(key.connector_key)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.exists","title":"exists()","text":"<pre><code>exists(key: MultiKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>MultiKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def exists(self, key: MultiKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nconnector = self._connector_from_key(key)\nreturn connector.exists(key.connector_key)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.get","title":"get()","text":"<pre><code>get(key: MultiKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>MultiKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def get(self, key: MultiKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nconnector = self._connector_from_key(key)\nreturn connector.get(key.connector_key)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[MultiKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[MultiKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def get_batch(self, keys: Sequence[MultiKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.put","title":"put()","text":"<pre><code>put(\nobj: bytes,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n) -&gt; MultiKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> <li> subset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a subset of a connector's policy <code>subset_tags</code> to match.</p> </li> <li> superset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a superset of a connectors's policy <code>superset_tags</code> to match.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MultiKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MultiConnectorError</code>           \u2013         <p>If no connector policy matches the arguments.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def put(\nself,\nobj: bytes,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n) -&gt; MultiKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n        subset_tags: Iterable of tags that must be a subset\n            of a connector's policy `subset_tags` to match.\n        superset_tags: Iterable of tags that must be a superset\n            of a connectors's policy `superset_tags` to match.\n    Returns:\n        Key which can be used to retrieve the object.\n    Raises:\n        MultiConnectorError: If no connector policy matches the arguments.\n    \"\"\"\nfor connector_name in self.connectors_by_priority:\nconnector, policy = self.connectors[connector_name]\nif policy.is_valid(\nsize_bytes=len(obj),\nsubset_tags=subset_tags,\nsuperset_tags=superset_tags,\n):\nkey = connector.put(obj)\nreturn MultiKey(\nconnector_name=connector_name,\nconnector_key=key,\n)\nraise MultiConnectorError(\n'No connector policy was suitable for the constraints: '\nf'subset_tags={subset_tags}, superset_tags={superset_tags}.',\n)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(\nobjs: Sequence[bytes],\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n) -&gt; list[MultiKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> Warning <p>This method calls <code>put()</code> individually for each item in the batch so items in the batch can potentially be placed in different connectors.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> <li> subset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a subset of a connector's policy <code>subset_tags</code> to match.</p> </li> <li> superset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a superset of a connectors's policy <code>superset_tags</code> to match.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[MultiKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MultiConnectorError</code>           \u2013         <p>If no connector policy matches the arguments.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def put_batch(\nself,\nobjs: Sequence[bytes],\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n) -&gt; list[MultiKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Warning:\n        This method calls\n        [`put()`][proxystore.connectors.multi.MultiConnector] individually\n        for each item in the batch so items in the batch can potentially\n        be placed in different connectors.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n        subset_tags: Iterable of tags that must be a subset\n            of a connector's policy `subset_tags` to match.\n        superset_tags: Iterable of tags that must be a superset\n            of a connectors's policy `superset_tags` to match.\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    Raises:\n        MultiConnectorError: If no connector policy matches the arguments.\n    \"\"\"\nreturn [\nself.put(obj, subset_tags=subset_tags, superset_tags=superset_tags)\nfor obj in objs\n]\n</code></pre>"},{"location":"api/connectors/redis/","title":"proxystore.connectors.redis","text":"<code>proxystore/connectors/redis.py</code> <p>Redis connector implementation.</p>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisKey","title":"RedisKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects store in a Redis server.</p> <p>Attributes:</p> <ul> <li> redis_key             (<code>str</code>)         \u2013 <p>Unique object ID.</p> </li> </ul>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector","title":"RedisConnector","text":"<pre><code>RedisConnector(hostname: str, port: int) -&gt; None\n</code></pre> <p>Redis server connector.</p> <p>Parameters:</p> <ul> <li> hostname             (<code>str</code>)         \u2013 <p>Redis server hostname.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Redis server port.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def __init__(self, hostname: str, port: int) -&gt; None:\nself.hostname = hostname\nself.port = port\nself._redis_client = redis.StrictRedis(host=hostname, port=port)\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\"\"\"\npass\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {'hostname': self.hostname, 'port': self.port}\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; RedisConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; RedisConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.evict","title":"evict()","text":"<pre><code>evict(key: RedisKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>RedisKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def evict(self, key: RedisKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nself._redis_client.delete(key.redis_key)\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.exists","title":"exists()","text":"<pre><code>exists(key: RedisKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>RedisKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def exists(self, key: RedisKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nreturn bool(self._redis_client.exists(key.redis_key))\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.get","title":"get()","text":"<pre><code>get(key: RedisKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>RedisKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def get(self, key: RedisKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nreturn self._redis_client.get(key.redis_key)\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[RedisKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[RedisKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def get_batch(self, keys: Sequence[RedisKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn self._redis_client.mget([key.redis_key for key in keys])\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; RedisKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RedisKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def put(self, obj: bytes) -&gt; RedisKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = RedisKey(redis_key=str(uuid.uuid4()))\nself._redis_client.set(key.redis_key, obj)\nreturn key\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[RedisKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[RedisKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[RedisKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\nkeys = [RedisKey(redis_key=str(uuid.uuid4())) for _ in objs]\nself._redis_client.mset(\n{key.redis_key: obj for key, obj in zip(keys, objs)},\n)\nreturn keys\n</code></pre>"},{"location":"api/connectors/dim/","title":"proxystore.connectors.dim","text":"<code>proxystore/connectors/dim/__init__.py</code> <p>Distributed in-memory store connectors.</p>"},{"location":"api/connectors/dim/exceptions/","title":"proxystore.connectors.dim.exceptions","text":"<code>proxystore/connectors/dim/exceptions.py</code> <p>Exception types.</p>"},{"location":"api/connectors/dim/exceptions/#proxystore.connectors.dim.exceptions.ServerTimeoutError","title":"ServerTimeoutError","text":"<p>         Bases: <code>Exception</code></p> <p>Error indicating client timed out while trying to connect to server.</p>"},{"location":"api/connectors/dim/margo/","title":"proxystore.connectors.dim.margo","text":"<code>proxystore/connectors/dim/margo.py</code> <p>Margo RPC-based distributed in-memory connector implementation.</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol","title":"Protocol","text":"<p>         Bases: <code>Enum</code></p> <p>Available Mercury plugins and transports.</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.OFI_TCP","title":"OFI_TCP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OFI_TCP = 'ofi+tcp'\n</code></pre> <p>libfabric tcp provider (TCP/IP)</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.OFI_VERBS","title":"OFI_VERBS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OFI_VERBS = 'ofi+verbs'\n</code></pre> <p>libfabric Verbs provider (InfiniBand or RoCE)</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.OFI_GNI","title":"OFI_GNI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OFI_GNI = 'ofi+gni'\n</code></pre> <p>libfabric GNI provider (Cray Aries)</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.UCX_TCP","title":"UCX_TCP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UCX_TCP = 'ucx+tcp'\n</code></pre> <p>UCX TCP/IP</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.UCX_VERBS","title":"UCX_VERBS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UCX_VERBS = 'ucx+verbs'\n</code></pre> <p>UCX Verbs</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.SM_SHM","title":"SM_SHM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SM_SHM = 'sm+shm'\n</code></pre> <p>Shared memory shm</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.BMI_TCP","title":"BMI_TCP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BMI_TCP = 'bmi+tcp'\n</code></pre> <p>BMI tcp module (TCP/IP)</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector","title":"MargoConnector","text":"<pre><code>MargoConnector(\nport: int,\nprotocol: Protocol | str,\naddress: str | None = None,\ninterface: str | None = None,\ntimeout: float = 1,\nforce_spawn_server: bool = False,\n) -&gt; None\n</code></pre> <p>Margo RPC-based distributed in-memory connector.</p> Note <p>The first instance of this connector created on a process will spawn a <code>MargoServer</code> that will store data. Hence, this connector just acts as an interface to that server.</p> <p>Parameters:</p> <ul> <li> port             (<code>int</code>)         \u2013 <p>The desired port for the spawned server.</p> </li> <li> protocol             (<code>Protocol | str</code>)         \u2013 <p>The communication protocol to use.</p> </li> <li> address             (<code>str | None</code>)         \u2013 <p>The network IP to use for transfer. Has precedence over <code>interface</code> if both are provided.</p> </li> <li> interface             (<code>str | None</code>)         \u2013 <p>The network interface to use. <code>addr</code> has precedence over this attribute if both are provided.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Timeout in seconds to try connecting to a local server before spawning one.</p> </li> <li> force_spawn_server             (<code>bool</code>)         \u2013 <p>Force spawn a server rather than waiting to check if one is already running.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013         <p>If a local server cannot be connected to within <code>timeout</code> seconds, and a new local server does not respond within <code>timeout</code> seconds after being started.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def __init__(\nself,\nport: int,\nprotocol: Protocol | str,\naddress: str | None = None,\ninterface: str | None = None,\ntimeout: float = 1,\nforce_spawn_server: bool = False,\n) -&gt; None:\n# Py-Mochi-Margo is not a required dependency and requires the user\n# to install it themselves.\nif pymargo_import_error is not None:  # pragma: no cover\nraise pymargo_import_error\nself._address = address\nself._interface = interface\nself.port = port\nself.protocol = (\nprotocol if isinstance(protocol, str) else protocol.value\n)\nself.timeout = timeout\nself.force_spawn_server = force_spawn_server\nself.engine = Engine(\nself.protocol,\nmode=pymargo.client,\nuse_progress_thread=True,\n)\nif self._address is not None:\nself.address = self._address\nelif self._interface is not None:  # pragma: darwin no cover\nself.address = get_ip_address(self._interface)\nelse:\neng_url = str(self.engine.addr())\nself.address = eng_url.split(':')[1].split('/')[2]\nself.url = f'{self.protocol}://{self.address}:{self.port}'\nself._rpcs = {\n'evict': self.engine.register('evict'),\n'exists': self.engine.register('exists'),\n'get': self.engine.register('get'),\n'put': self.engine.register('put'),\n}\nserver_available = False\nif not force_spawn_server:\ntry:\nlogger.info(\nf'Connecting to local server (address={self.url})...',\n)\nwait_for_server(\nself.protocol,\nself.address,\nself.port,\nself.timeout,\n)\nlogger.info(\nf'Connected to local server (address={self.url})',\n)\nserver_available = True\nexcept ServerTimeoutError:\nlogger.info(\n'Failed to connect to local server '\nf'(address={self.url}, timeout={self.timeout})',\n)\nself.server: multiprocessing.context.SpawnProcess | None\nif not server_available or force_spawn_server:\nself.server = spawn_server(\nself.protocol,\nself.address,\nself.port,\nspawn_timeout=self.timeout,\n)\nlogger.info(f'Spawned local server (address={self.url})')\nelse:\nself.server = None\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.close","title":"close()","text":"<pre><code>close(kill_server: bool = True) -&gt; None\n</code></pre> <p>Close the connector.</p> <p>Parameters:</p> <ul> <li> kill_server             (<code>bool</code>)         \u2013 <p>Whether to kill the server process. If this instance did not spawn the local node's server process, this is a no-op.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def close(self, kill_server: bool = True) -&gt; None:\n\"\"\"Close the connector.\n    Args:\n        kill_server: Whether to kill the server process. If this instance\n            did not spawn the local node's server process, this is a\n            no-op.\n    \"\"\"\nif kill_server and self.server is not None:\nself.engine.lookup(self.url).shutdown()\nself.server.join()\nlogger.info(\n'Terminated local server on connector close '\nf'(pid={self.server.pid})',\n)\nself.engine.finalize()\nlogger.info('Closed Margo connector')\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {\n'address': self._address,\n'interface': self._interface,\n'port': self.port,\n'protocol': self.protocol,\n'timeout': self.timeout,\n'force_spawn_server': self.force_spawn_server,\n}\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; MargoConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; MargoConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.evict","title":"evict()","text":"<pre><code>evict(key: DIMKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def evict(self, key: DIMKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nrpc = RPC(operation='evict', key=key)\nself._send_rpcs([rpc])\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.exists","title":"exists()","text":"<pre><code>exists(key: DIMKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def exists(self, key: DIMKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nrpc = RPC(operation='exists', key=key)\n(response,) = self._send_rpcs([rpc])\nassert response.exists is not None\nreturn response.exists\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.get","title":"get()","text":"<pre><code>get(key: DIMKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def get(self, key: DIMKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nbuff = bytearray(key.size)\nblk = self.engine.create_bulk(buff, bulk.write_only)\nrpc = RPC(operation='get', key=key, data=blk)\n(result,) = self._send_rpcs([rpc])\nif result.exists:\nreturn bytes(buff)\nreturn None\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[DIMKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[DIMKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def get_batch(self, keys: Sequence[DIMKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nrpcs: list[RPC] = []\nbuffers: list[bytearray] = []\nfor key in keys:\nbuff = bytearray(key.size)\nblk = self.engine.create_bulk(buff, bulk.write_only)\nbuffers.append(buff)\nrpcs.append(RPC(operation='get', key=key, data=blk))\nresponses = self._send_rpcs(rpcs)\nreturn [\nbytes(b) if responses[i].exists else None\nfor i, b in enumerate(buffers)\n]\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; DIMKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DIMKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def put(self, obj: bytes) -&gt; DIMKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = DIMKey(\ndim_type='margo',\nobj_id=str(uuid.uuid4()),\nsize=len(obj),\npeer_host=self.address,\npeer_port=self.port,\n)\nblk = self.engine.create_bulk(obj, bulk.read_only)\nrpc = RPC(operation='put', key=key, data=blk)\nself._send_rpcs([rpc])\nreturn key\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[DIMKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DIMKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[DIMKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\nkeys = [\nDIMKey(\ndim_type='margo',\nobj_id=str(uuid.uuid4()),\nsize=len(obj),\npeer_host=self.address,\npeer_port=self.port,\n)\nfor obj in objs\n]\nrpcs: list[RPC] = []\nfor key, obj in zip(keys, objs):\nblk = self.engine.create_bulk(obj, bulk.read_only)\nrpcs.append(RPC(operation='put', key=key, data=blk))\nself._send_rpcs(rpcs)\nreturn keys\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoServer","title":"MargoServer","text":"<pre><code>MargoServer(engine: Engine) -&gt; None\n</code></pre> <p>MargoServer implementation.</p> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def __init__(self, engine: Engine) -&gt; None:\nself.data: dict[str, bytes] = {}\nself.engine = engine\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoServer.evict","title":"evict()","text":"<pre><code>evict(\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: DIMKey,\n) -&gt; None\n</code></pre> <p>Remove key from local dictionary.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>Bulk</code>)         \u2013 <p>The buffer that will store shared data.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data to be received.</p> </li> <li> key             (<code>DIMKey</code>)         \u2013 <p>The data's key.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def evict(\nself,\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: DIMKey,\n) -&gt; None:\n\"\"\"Remove key from local dictionary.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\nself.data.pop(key.obj_id, None)\nresponse = RPCResponse(operation='evict', key=key)\nhandle.respond(serialize(response))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoServer.exists","title":"exists()","text":"<pre><code>exists(\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: DIMKey,\n) -&gt; None\n</code></pre> <p>Check if key exists within local dictionary.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>Bulk</code>)         \u2013 <p>The buffer that will store shared data.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data to be received.</p> </li> <li> key             (<code>DIMKey</code>)         \u2013 <p>The data's key.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def exists(\nself,\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: DIMKey,\n) -&gt; None:\n\"\"\"Check if key exists within local dictionary.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\nexists = key.obj_id in self.data\nresponse = RPCResponse(operation='exists', key=key, exists=exists)\nhandle.respond(serialize(response))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoServer.get","title":"get()","text":"<pre><code>get(\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: DIMKey,\n) -&gt; None\n</code></pre> <p>Return data at a given key back to the client.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>Bulk</code>)         \u2013 <p>The buffer that will store shared data.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data to be received.</p> </li> <li> key             (<code>DIMKey</code>)         \u2013 <p>The data's key.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def get(\nself,\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: DIMKey,\n) -&gt; None:\n\"\"\"Return data at a given key back to the client.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\nlocal_array = self.data.get(key.obj_id, None)\nif local_array is not None:\nlocal_bulk = self.engine.create_bulk(local_array, bulk.read_only)\nself.engine.transfer(\nbulk.push,\nhandle.get_addr(),\nbulk_str,\n0,\nlocal_bulk,\n0,\nbulk_size,\n)\nresponse = RPCResponse(operation='get', key=key, exists=True)\nelse:\nresponse = RPCResponse(operation='get', key=key, exists=False)\nhandle.respond(serialize(response))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoServer.put","title":"put()","text":"<pre><code>put(\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: DIMKey,\n) -&gt; None\n</code></pre> <p>Obtain data from the client and store it in local dictionary.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>Bulk</code>)         \u2013 <p>The buffer containing the data to be shared.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data being transferred.</p> </li> <li> key             (<code>DIMKey</code>)         \u2013 <p>The data key.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def put(\nself,\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: DIMKey,\n) -&gt; None:\n\"\"\"Obtain data from the client and store it in local dictionary.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer containing the data to be shared.\n        bulk_size: The size of the data being transferred.\n        key: The data key.\n    \"\"\"\nlocal_buffer = bytearray(bulk_size)\nlocal_bulk = self.engine.create_bulk(local_buffer, bulk.write_only)\nself.engine.transfer(\nbulk.pull,\nhandle.get_addr(),\nbulk_str,\n0,\nlocal_bulk,\n0,\nbulk_size,\n)\nself.data[key.obj_id] = local_buffer\nresponse = RPCResponse(operation='put', key=key)\nhandle.respond(serialize(response))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.start_server","title":"start_server()","text":"<pre><code>start_server(url: str) -&gt; None\n</code></pre> <p>Start and wait on a Margo server.</p> <p>Parameters:</p> <ul> <li> url             (<code>str</code>)         \u2013 <p>URL of the engine that will be started. Should take the form <code>{protocol}://{host}:{port}</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def start_server(url: str) -&gt; None:\n\"\"\"Start and wait on a Margo server.\n    Args:\n        url: URL of the engine that will be started. Should take\n            the form `{protocol}://{host}:{port}`.\n    \"\"\"\nserver_engine = Engine(url)\nserver_engine.on_finalize(_when_finalize)\nserver_engine.enable_remote_shutdown()\nreceiver = MargoServer(server_engine)\nserver_engine.register('evict', receiver.evict)\nserver_engine.register('exists', receiver.exists)\nserver_engine.register('get', receiver.get)\nserver_engine.register('put', receiver.put)\nserver_engine.wait_for_finalize()\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.spawn_server","title":"spawn_server()","text":"<pre><code>spawn_server(\nprotocol: str,\naddress: str,\nport: int,\n*,\nspawn_timeout: float = 5.0,\nkill_timeout: float | None = 1.0\n) -&gt; multiprocessing.context.SpawnProcess\n</code></pre> <p>Spawn a local server running in a separate process.</p> Note <p>An <code>atexit</code> callback is registered which will terminate the spawned server process when the calling process exits.</p> <p>Parameters:</p> <ul> <li> protocol             (<code>str</code>)         \u2013 <p>Communication protocol.</p> </li> <li> address             (<code>str</code>)         \u2013 <p>Host IP of the server to wait on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port of the server to wait on.</p> </li> <li> spawn_timeout             (<code>float</code>)         \u2013 <p>Max time in seconds to wait for the server to start.</p> </li> <li> kill_timeout             (<code>float | None</code>)         \u2013 <p>Max time in seconds to wait for the server to shutdown on exit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>multiprocessing.context.SpawnProcess</code>         \u2013 <p>The process that the server is running in.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def spawn_server(\nprotocol: str,\naddress: str,\nport: int,\n*,\nspawn_timeout: float = 5.0,\nkill_timeout: float | None = 1.0,\n) -&gt; multiprocessing.context.SpawnProcess:\n\"\"\"Spawn a local server running in a separate process.\n    Note:\n        An `atexit` callback is registered which will terminate the spawned\n        server process when the calling process exits.\n    Args:\n        protocol: Communication protocol.\n        address: Host IP of the server to wait on.\n        port: Port of the server to wait on.\n        spawn_timeout: Max time in seconds to wait for the server to start.\n        kill_timeout: Max time in seconds to wait for the server to shutdown\n            on exit.\n    Returns:\n        The process that the server is running in.\n    \"\"\"\nurl = f'{protocol}://{address}:{port}'\nctx = multiprocessing.get_context('spawn')\nserver_process = ctx.Process(\ntarget=start_server,\nargs=(url,),\n)\nserver_process.start()\ndef _kill_on_exit() -&gt; None:  # pragma: no cover\nif server_process.is_alive():\nserver_process.terminate()\nserver_process.join(timeout=kill_timeout)\nif server_process.is_alive():\nserver_process.kill()\nserver_process.join()\nlogger.debug(\n'Server terminated on parent process exit '\nf'(pid={server_process.pid})',\n)\natexit.register(_kill_on_exit)\nlogger.debug('Registered server cleanup atexit callback')\nwait_for_server(protocol, address, port, timeout=spawn_timeout)\nlogger.debug(\nf'Server started (address={url}, pid={server_process.pid})',\n)\nreturn server_process\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.wait_for_server","title":"wait_for_server()","text":"<pre><code>wait_for_server(\nprotocol: str,\naddress: str,\nport: int,\ntimeout: float = 0.1,\n) -&gt; None\n</code></pre> <p>Wait until the server responds.</p> Warning <p>Due to how Margo blocks internally, the timeout is not very accurate.</p> <p>Parameters:</p> <ul> <li> protocol             (<code>str</code>)         \u2013 <p>Communication protocol.</p> </li> <li> address             (<code>str</code>)         \u2013 <p>Host IP of the server to wait on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port of the server to wait on.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>The max time in seconds to wait for server response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013         <p>If the server does not respond within the timeout.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def wait_for_server(\nprotocol: str,\naddress: str,\nport: int,\ntimeout: float = 0.1,\n) -&gt; None:\n\"\"\"Wait until the server responds.\n    Warning:\n        Due to how Margo blocks internally, the timeout is not very accurate.\n    Args:\n        protocol: Communication protocol.\n        address: Host IP of the server to wait on.\n        port: Port of the server to wait on.\n        timeout: The max time in seconds to wait for server response.\n    Raises:\n        ServerTimeoutError: If the server does not respond within the timeout.\n    \"\"\"\nengine = Engine(protocol, mode=pymargo.client, use_progress_thread=True)\nremote_function = engine.register('exists')\nkey = DIMKey(\n'margo',\nobj_id='ping',\nsize=0,\npeer_host=address,\npeer_port=port,\n)\nrpc = RPC('exists', key=key)\nurl = f'{protocol}://{address}:{port}'\nsleep_time = 0.01\nstart = time.time()\nwhile time.time() - start &lt; timeout:\ntry:\nlocal_url = engine.lookup(url)\nresult = remote_function.on(local_url)(\nrpc.data,\nrpc.key.size,\nrpc.key,\n)\nresponse = deserialize(result)\nassert response.exception is None\n# We could call engine.finalize() now to be safe but Margo\n# raises a _pymargo.MargoException: margo_addr_free() returned 11\n# exception.\nreturn\nexcept MargoException:  # pragma: no cover\ntime.sleep(sleep_time)\nraise ServerTimeoutError(\nf'Failed to connect to server within timeout ({timeout} seconds).',\n)\n</code></pre>"},{"location":"api/connectors/dim/models/","title":"proxystore.connectors.dim.models","text":"<code>proxystore/connectors/dim/models.py</code> <p>Message types for communication with DIM servers.</p>"},{"location":"api/connectors/dim/models/#proxystore.connectors.dim.models.DIMKey","title":"DIMKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects stored across <code>UCXConnector</code>s.</p> <p>Attributes:</p> <ul> <li> dim_type             (<code>Literal['margo', 'ucx', 'zmq']</code>)         \u2013 <p>Type of DIM this key belongs to.</p> </li> <li> obj_id             (<code>str</code>)         \u2013 <p>Unique object key.</p> </li> <li> size             (<code>int</code>)         \u2013 <p>Object size in bytes.</p> </li> <li> peer_host             (<code>str</code>)         \u2013 <p>Hostname of peer where object is located.</p> </li> <li> peer_port             (<code>int</code>)         \u2013 <p>Port of peer server where object is located.</p> </li> </ul>"},{"location":"api/connectors/dim/models/#proxystore.connectors.dim.models.RPC","title":"RPC  <code>dataclass</code>","text":"<p>Client request to a DIM server.</p> <p>Attributes:</p> <ul> <li> operation             (<code>Literal['exists', 'evict', 'get', 'put']</code>)         \u2013 <p>Operation type requested.</p> </li> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key to operate on.</p> </li> <li> size             (<code>DIMKey</code>)         \u2013 <p>Size of data associated with key.</p> </li> <li> data             (<code>bytes | None</code>)         \u2013 <p>Data associated with <code>set</code> operation.</p> </li> </ul>"},{"location":"api/connectors/dim/models/#proxystore.connectors.dim.models.RPCResponse","title":"RPCResponse  <code>dataclass</code>","text":"<p>Server response to a client request.</p> <p>Attributes:</p> <ul> <li> operation             (<code>Literal['exists', 'evict', 'get', 'put']</code>)         \u2013 <p>Operation type performed.</p> </li> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key that was operated on.</p> </li> <li> size             (<code>DIMKey</code>)         \u2013 <p>Size of data associated with key.</p> </li> <li> data             (<code>bytes | None</code>)         \u2013 <p>Data returned by <code>get</code> operation.</p> </li> <li> exists             (<code>bool | None</code>)         \u2013 <p>Return value for <code>exists</code> operation.</p> </li> <li> exception             (<code>Exception | None</code>)         \u2013 <p>Optional exception raised by the operation.</p> </li> </ul>"},{"location":"api/connectors/dim/ucx/","title":"proxystore.connectors.dim.ucx","text":"<code>proxystore/connectors/dim/ucx.py</code> <p>UCX-based distributed in-memory connector implementation.</p>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector","title":"UCXConnector","text":"<pre><code>UCXConnector(\nport: int,\naddress: str | None = None,\ninterface: str | None = None,\ntimeout: float = 1,\n) -&gt; None\n</code></pre> <p>UCX-based distributed in-memory connector.</p> Note <p>The first instance of this connector created on a process will spawn a <code>UCXServer</code> that will store data. Hence, this connector just acts as an interface to that server.</p> <p>Parameters:</p> <ul> <li> port             (<code>int</code>)         \u2013 <p>The desired port for the spawned server.</p> </li> <li> address             (<code>str | None</code>)         \u2013 <p>The IP address of the network interface to use. Has precedence over <code>interface</code> if both are provided.</p> </li> <li> interface             (<code>str | None</code>)         \u2013 <p>The network interface to use. <code>address</code> has precedence if both args are defined.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Timeout in seconds to try connecting to local server before spawning one.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013         <p>If a local server cannot be connected to within <code>timeout</code> seconds, and a new local server does not response within <code>timeout</code> seconds after being started.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def __init__(\nself,\nport: int,\naddress: str | None = None,\ninterface: str | None = None,\ntimeout: float = 1,\n) -&gt; None:\nif ucx_import_error is not None:  # pragma: no cover\nraise ucx_import_error\nself._address = address\nself._interface = interface\nself.port = port\nself.timeout = timeout\nif self._address is not None:\nself.address = self._address\nelif self._interface is not None:\nself.address = ucp.get_address(ifname=self._interface)\nelse:\nself.address = ucp.get_address()\nself.url = f'{self.address}:{self.port}'\nself.server: multiprocessing.context.SpawnProcess | None\ntry:\nlogger.info(\nf'Connecting to local server (URL={self.url})...',\n)\nwait_for_server(self.address, self.port, self.timeout)\nlogger.info(\nf'Connected to local server (URL={self.url})',\n)\nexcept ServerTimeoutError:\nlogger.info(\n'Failed to connect to local server '\nf'(URL={self.url}, timeout={self.timeout})',\n)\nself.server = spawn_server(\nself.address,\nself.port,\nspawn_timeout=self.timeout,\n)\nlogger.info(f'Spawned local server (address={self.url})')\nelse:\nself.server = None\ntry:\nself._loop = asyncio.get_running_loop()\nexcept RuntimeError:\nself._loop = asyncio.new_event_loop()\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.close","title":"close()","text":"<pre><code>close(kill_server: bool = False) -&gt; None\n</code></pre> <p>Close the connector.</p> <p>Parameters:</p> <ul> <li> kill_server             (<code>bool</code>)         \u2013 <p>Whether to kill the server process. If this instance did not spawn the local node's server process, this is a no-op.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def close(self, kill_server: bool = False) -&gt; None:\n\"\"\"Close the connector.\n    Args:\n        kill_server: Whether to kill the server process. If this instance\n            did not spawn the local node's server process, this is a\n            no-op.\n    \"\"\"\nif kill_server and self.server is not None:\nself.server.terminate()\nself.server.join()\nlogger.info(\n'Terminated local server on connector close '\nf'(pid={self.server.pid})',\n)\nlogger.debug('Closed UCX connector')\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {\n'address': self._address,\n'interface': self._interface,\n'port': self.port,\n'timeout': self.timeout,\n}\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; UCXConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; UCXConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.evict","title":"evict()","text":"<pre><code>evict(key: DIMKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def evict(self, key: DIMKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nrpc = RPC(operation='evict', key=key)\nself._send_rpcs([rpc])\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.exists","title":"exists()","text":"<pre><code>exists(key: DIMKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def exists(self, key: DIMKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nrpc = RPC(operation='exists', key=key)\n(response,) = self._send_rpcs([rpc])\nassert response.exists is not None\nreturn response.exists\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.get","title":"get()","text":"<pre><code>get(key: DIMKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def get(self, key: DIMKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nrpc = RPC(operation='get', key=key)\n(result,) = self._send_rpcs([rpc])\nreturn result.data\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[DIMKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[DIMKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def get_batch(self, keys: Sequence[DIMKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nrpcs = [RPC(operation='get', key=key) for key in keys]\nresponses = self._send_rpcs(rpcs)\nreturn [r.data for r in responses]\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; DIMKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DIMKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def put(self, obj: bytes) -&gt; DIMKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = DIMKey(\ndim_type='ucx',\nobj_id=str(uuid.uuid4()),\nsize=len(obj),\npeer_host=self.address,\npeer_port=self.port,\n)\nrpc = RPC(operation='put', key=key, data=obj)\nself._send_rpcs([rpc])\nreturn key\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[DIMKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DIMKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[DIMKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\nkeys = [\nDIMKey(\ndim_type='ucx',\nobj_id=str(uuid.uuid4()),\nsize=len(obj),\npeer_host=self.address,\npeer_port=self.port,\n)\nfor obj in objs\n]\nrpcs = [\nRPC(operation='put', key=key, data=obj)\nfor key, obj in zip(keys, objs)\n]\nself._send_rpcs(rpcs)\nreturn keys\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer","title":"UCXServer","text":"<pre><code>UCXServer() -&gt; None\n</code></pre> <p>UCXServer implementation.</p> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def __init__(self) -&gt; None:\nself.data: dict[str, bytes] = {}\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.evict","title":"evict()","text":"<pre><code>evict(key: str) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def evict(self, key: str) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nself.data.pop(key, None)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.exists","title":"exists()","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nreturn key in self.data\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.get","title":"get()","text":"<pre><code>get(key: str) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Data or <code>None</code> if no data associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def get(self, key: str) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Data or `None` if no data associated with the key exists.\n    \"\"\"\nreturn self.data.get(key, None)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.put","title":"put()","text":"<pre><code>put(key: str, data: bytes) -&gt; None\n</code></pre> <p>Put data in the store.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with data.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Data to put in the store.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def put(self, key: str, data: bytes) -&gt; None:\n\"\"\"Put data in the store.\n    Args:\n        key: Key associated with data.\n        data: Data to put in the store.\n    \"\"\"\nself.data[key] = data\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.handle_rpc","title":"handle_rpc()","text":"<pre><code>handle_rpc(rpc: RPC) -&gt; RPCResponse\n</code></pre> <p>Process an RPC request.</p> <p>Parameters:</p> <ul> <li> rpc             (<code>RPC</code>)         \u2013 <p>Client RPC to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RPCResponse</code>         \u2013 <p>Response containing result or an exception if the operation failed.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def handle_rpc(self, rpc: RPC) -&gt; RPCResponse:\n\"\"\"Process an RPC request.\n    Args:\n        rpc: Client RPC to process.\n    Returns:\n        Response containing result or an exception if the operation failed.\n    \"\"\"\nresponse: RPCResponse\ntry:\nif rpc.operation == 'exists':\nexists = self.exists(rpc.key.obj_id)\nresponse = RPCResponse('exists', key=rpc.key, exists=exists)\nelif rpc.operation == 'evict':\nself.evict(rpc.key.obj_id)\nresponse = RPCResponse('evict', key=rpc.key)\nelif rpc.operation == 'get':\ndata = self.get(rpc.key.obj_id)\nresponse = RPCResponse('get', key=rpc.key, data=data)\nelif rpc.operation == 'put':\nassert rpc.data is not None\nself.put(rpc.key.obj_id, rpc.data)\nresponse = RPCResponse('put', key=rpc.key)\nelse:\nraise AssertionError('Unreachable.')\nexcept Exception as e:\nresponse = RPCResponse(rpc.operation, key=rpc.key, exception=e)\nreturn response\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.handler","title":"handler()  <code>async</code>","text":"<pre><code>handler(ep: ucp.Endpoint) -&gt; None\n</code></pre> <p>Handle endpoint requests.</p> <p>Parameters:</p> <ul> <li> ep             (<code>ucp.Endpoint</code>)         \u2013 <p>The endpoint making the request.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>async def handler(self, ep: ucp.Endpoint) -&gt; None:\n\"\"\"Handle endpoint requests.\n    Args:\n        ep: The endpoint making the request.\n    \"\"\"\nrpc_bytes = bytes(await ep.recv_obj())\nif rpc_bytes == b'ping':\nawait ep.send_obj(b'pong')\nreturn\nrpc: RPC = deserialize(rpc_bytes)\nresponse = self.handle_rpc(rpc)\nmessage = serialize(response)\nawait ep.send_obj(message)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.run_server","title":"run_server()  <code>async</code>","text":"<pre><code>run_server(port: int) -&gt; None\n</code></pre> <p>Listen and reply to RPCs from clients.</p> Warning <p>This function does not return until SIGINT or SIGTERM is received.</p> <p>Parameters:</p> <ul> <li> port             (<code>int</code>)         \u2013 <p>Port the server should listen on.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>async def run_server(port: int) -&gt; None:  # pragma: no cover\n\"\"\"Listen and reply to RPCs from clients.\n    Warning:\n        This function does not return until SIGINT or SIGTERM is received.\n    Args:\n        port: Port the server should listen on.\n    \"\"\"\nserver = UCXServer()\nucp_listener = ucp.create_listener(server.handler, port)\nloop = asyncio.get_running_loop()\nclose_future = loop.create_future()\nloop.add_signal_handler(signal.SIGINT, close_future.set_result, None)\nloop.add_signal_handler(signal.SIGTERM, close_future.set_result, None)\nawait close_future\nucp_listener.close()\nwhile not ucp_listener.closed():\nawait asyncio.sleep(0.001)\nloop.remove_signal_handler(signal.SIGINT)\nloop.remove_signal_handler(signal.SIGTERM)\n# UCP does reference counting of open resources\ndel ucp_listener\nawait reset_ucp_async()\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.start_server","title":"start_server()","text":"<pre><code>start_server(port: int) -&gt; None\n</code></pre> <p>Run a local server.</p> Note <p>This function creates an event loop and executes <code>run_server()</code> within that loop.</p> <p>Parameters:</p> <ul> <li> port             (<code>int</code>)         \u2013 <p>Port the server should listen on.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def start_server(port: int) -&gt; None:  # pragma: no cover\n\"\"\"Run a local server.\n    Note:\n        This function creates an event loop and executes\n        [`run_server()`][proxystore.connectors.dim.ucx.run_server] within\n        that loop.\n    Args:\n        port: Port the server should listen on.\n    \"\"\"\nasyncio.run(run_server(port))\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.spawn_server","title":"spawn_server()","text":"<pre><code>spawn_server(\naddress: str,\nport: int,\n*,\nspawn_timeout: float = 5.0,\nkill_timeout: float | None = 1.0\n) -&gt; multiprocessing.context.SpawnProcess\n</code></pre> <p>Spawn a local server running in a separate process.</p> Note <p>An <code>atexit</code> callback is registered which will terminate the spawned server process when the calling process exits.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>IP address the server will listen on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port the server will listen on.</p> </li> <li> spawn_timeout             (<code>float</code>)         \u2013 <p>Max time in seconds to wait for the server to start.</p> </li> <li> kill_timeout             (<code>float | None</code>)         \u2013 <p>Max time in seconds to wait for the server to shutdown on exit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>multiprocessing.context.SpawnProcess</code>         \u2013 <p>The process that the server is running in.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def spawn_server(\naddress: str,\nport: int,\n*,\nspawn_timeout: float = 5.0,\nkill_timeout: float | None = 1.0,\n) -&gt; multiprocessing.context.SpawnProcess:\n\"\"\"Spawn a local server running in a separate process.\n    Note:\n        An `atexit` callback is registered which will terminate the spawned\n        server process when the calling process exits.\n    Args:\n        address: IP address the server will listen on.\n        port: Port the server will listen on.\n        spawn_timeout: Max time in seconds to wait for the server to start.\n        kill_timeout: Max time in seconds to wait for the server to shutdown\n            on exit.\n    Returns:\n        The process that the server is running in.\n    \"\"\"\nctx = multiprocessing.get_context('spawn')\n# UCX seems to hang if you fork a process after calling ucp.init().\n# If discovered this via a comment in Dask's distributed communication:\n# https://github.com/dask/distributed/blob/76bbfaf9f4a14906cbf4500ed42c442c7a5bc971/distributed/comm/ucx.py#L40  # noqa: E501\nserver_process = ctx.Process(\ntarget=start_server,\nargs=(port,),\n)\nserver_process.start()\ndef _kill_on_exit() -&gt; None:  # pragma: no cover\nserver_process.terminate()\nserver_process.join(timeout=kill_timeout)\nif server_process.is_alive():\nserver_process.kill()\nserver_process.join()\nlogger.debug(\n'Server terminated on parent process exit '\nf'(pid={server_process.pid})',\n)\natexit.register(_kill_on_exit)\nlogger.debug('Registered server cleanup atexit callback')\nwait_for_server(address, port, timeout=spawn_timeout)\nlogger.debug(\nf'Server started (host={address}, port={port}, pid={server_process.pid})',\n)\nreturn server_process\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.wait_for_server_async","title":"wait_for_server_async()  <code>async</code>","text":"<pre><code>wait_for_server_async(\naddress: str, port: int, timeout: float = 0.1\n) -&gt; None\n</code></pre> <p>Wait until the server responds.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Host IP of the server to ping.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port of the server to ping.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Max time in seconds to wait for server response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013         <p>If the server does not respond within the timeout.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>async def wait_for_server_async(\naddress: str,\nport: int,\ntimeout: float = 0.1,\n) -&gt; None:\n\"\"\"Wait until the server responds.\n    Args:\n        address: Host IP of the server to ping.\n        port: Port of the server to ping.\n        timeout: Max time in seconds to wait for server response.\n    Raises:\n        ServerTimeoutError: If the server does not respond within the timeout.\n    \"\"\"\nsleep_time = 0.01\ntime_waited = 0.0\nwhile True:\ntry:\nep = await ucp.create_endpoint(address, port)\nexcept ucp._libs.exceptions.UCXNotConnected as e:  # pragma: no cover\nif time_waited &gt;= timeout:\nraise ServerTimeoutError(\n'Failed to connect to server within timeout '\nf'({timeout} seconds).',\n) from e\nawait asyncio.sleep(sleep_time)\ntime_waited += sleep_time\nelse:\nbreak  # pragma: no cover\nawait ep.send_obj(b'ping')\nassert bytes(await ep.recv_obj()) == b'pong'\nawait ep.close()\nassert ep.closed()\ndel ep\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.wait_for_server","title":"wait_for_server()","text":"<pre><code>wait_for_server(\naddress: str, port: int, timeout: float = 0.1\n) -&gt; None\n</code></pre> <p>Wait until the server responds.</p> Note <p>This function calls <code>wait_for_server_async()</code> using <code>asyncio.run()</code>.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>The host IP of the server to ping.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Theport of the server to ping.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>The max time in seconds to wait for server response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013         <p>If the server does not respond within the timeout.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def wait_for_server(address: str, port: int, timeout: float = 0.1) -&gt; None:\n\"\"\"Wait until the server responds.\n    Note:\n        This function calls\n        [`wait_for_server_async()`][proxystore.connectors.dim.ucx.wait_for_server_async]\n        using [`asyncio.run()`][asyncio.run].\n    Args:\n        address: The host IP of the server to ping.\n        port: Theport of the server to ping.\n        timeout: The max time in seconds to wait for server response.\n    Raises:\n        ServerTimeoutError: If the server does not respond within the timeout.\n    \"\"\"\nasyncio.run(wait_for_server_async(address, port, timeout))\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.reset_ucp_async","title":"reset_ucp_async()  <code>async</code>","text":"<pre><code>reset_ucp_async(reset_ucp: bool = True) -&gt; None\n</code></pre> <p>Hard reset all of UCP.</p> <p>UCP provides <code>ucp.reset()</code>; however, this function does not correctly shutdown all asyncio tasks and readers. This function wraps <code>ucp.reset()</code> and additionally removes all readers on the event loop and cancels/awaits all asyncio tasks.</p> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>async def reset_ucp_async(reset_ucp: bool = True) -&gt; None:  # pragma: no cover\n\"\"\"Hard reset all of UCP.\n    UCP provides `ucp.reset()`; however, this function does not correctly\n    shutdown all asyncio tasks and readers. This function wraps\n    `ucp.reset()` and additionally removes all readers on the event loop\n    and cancels/awaits all asyncio tasks.\n    \"\"\"\nasync def inner_context() -&gt; None:\nctx = ucp.core._get_ctx()\nfor task in ctx.progress_tasks:\nif task is None:\ncontinue\ntask.event_loop.remove_reader(ctx.epoll_fd)\nif task.asyncio_task is not None:\ntry:\ntask.asyncio_task.cancel()\nawait task.asyncio_task\n# A RuntimeError can happen if the task if from a different\n# event loop. We'll just skip these for now\nexcept (asyncio.CancelledError, RuntimeError):\npass\n# We access ucp.core._get_ctx() inside this nested function so our local\n# reference to the UCP context goes out of scope before calling\n# ucp.reset(). ucp.reset() will fail if there are any weak references to\n# to the UCP context because it assumes those may be Listeners or\n# Endpoints that were not properly closed.\nawait inner_context()\nif reset_ucp:\ntry:\nucp.reset()\nexcept ucp.UCXError:\npass\n</code></pre>"},{"location":"api/connectors/dim/utils/","title":"proxystore.connectors.dim.utils","text":"<code>proxystore/connectors/dim/utils.py</code> <p>Shared functions used by DIM stores.</p>"},{"location":"api/connectors/dim/utils/#proxystore.connectors.dim.utils.get_ip_address","title":"get_ip_address()","text":"<pre><code>get_ip_address(ifname: str) -&gt; str\n</code></pre> <p>Get ip address provided an interface name.</p> Warning <p>This function does not work on MacOS/Darwin.</p> <p>Parameters:</p> <ul> <li> ifname             (<code>str</code>)         \u2013 <p>The interface name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The IP address.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/utils.py</code> <pre><code>def get_ip_address(ifname: str) -&gt; str:  # pragma: darwin no cover\n\"\"\"Get ip address provided an interface name.\n    Warning:\n        This function does not work on MacOS/Darwin.\n    Args:\n        ifname: The interface name.\n    Returns:\n        The IP address.\n    \"\"\"\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nreturn socket.inet_ntoa(\nfcntl.ioctl(\ns.fileno(),\n0x8915,\nstruct.pack(\n'256s',\nbytes(ifname[:15], 'utf-8'),\n),  # SIOCGIFADDR\n)[20:24],\n)\n</code></pre>"},{"location":"api/connectors/dim/zmq/","title":"proxystore.connectors.dim.zmq","text":"<code>proxystore/connectors/dim/zmq.py</code> <p>ZeroMQ-based distributed in-memory connector implementation.</p>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector","title":"ZeroMQConnector","text":"<pre><code>ZeroMQConnector(\nport: int,\naddress: str | None = None,\ninterface: str | None = None,\nchunk_length: int | None = None,\ntimeout: float = 1,\n) -&gt; None\n</code></pre> <p>ZeroMQ-based distributed in-memory connector.</p> Note <p>The first instance of this connector created on a process will spawn a <code>ZeroMQServer</code> that will store data. Hence, this connector just acts as an interface to that server.</p> <p>Parameters:</p> <ul> <li> address             (<code>str | None</code>)         \u2013 <p>The network IP address to use. Takes precedence over <code>interface</code> if both are provided.</p> </li> <li> interface             (<code>str | None</code>)         \u2013 <p>The network interface to use. <code>address</code> arg takes precedence if both are provided.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The desired port for the spawned server.</p> </li> <li> chunk_length             (<code>int | None</code>)         \u2013 <p>Message chunk size in bytes. Defaults to <code>MAX_CHUNK_LENGTH_DEFAULT</code>.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Timeout in seconds to try connecting to local server before spawning one.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013         <p>If a local server cannot be connected to within <code>timeout</code> seconds, and a new local server does not response within <code>timeout</code> seconds after being started.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def __init__(\nself,\nport: int,\naddress: str | None = None,\ninterface: str | None = None,\nchunk_length: int | None = None,\ntimeout: float = 1,\n) -&gt; None:\n# ZMQ is not a default dependency so we don't want to raise\n# an error unless the user actually tries to use this code\nif zmq_import_error is not None:  # pragma: no cover\nraise zmq_import_error\nself._address = address\nself._interface = interface\nself.port = port\nself.chunk_length = (\nMAX_CHUNK_LENGTH_DEFAULT if chunk_length is None else chunk_length\n)\nself.timeout = timeout\nif self._address is not None:\nself.address = self._address\nelif self._interface is not None:  # pragma: darwin no cover\nself.address = get_ip_address(self._interface)\nelse:\nhost = socket.gethostname()\nself.address = socket.gethostbyname(host)\nself.url = f'tcp://{self.address}:{self.port}'\nself.server: multiprocessing.Process | None\ntry:\nlogger.info(\nf'Connecting to local server (url={self.url})...',\n)\nwait_for_server(self.address, self.port, self.timeout)\nlogger.info(\nf'Connected to local server (url={self.url})',\n)\nexcept ServerTimeoutError:\nlogger.info(\n'Failed to connect to local server '\nf'(address={self.url}, timeout={self.timeout})',\n)\nself.server = spawn_server(\nself.address,\nself.port,\nchunk_length=self.chunk_length,\nspawn_timeout=self.timeout,\n)\nlogger.info(f'Spawned local server (url={self.url})')\nelse:\nself.server = None\nself.context = zmq.Context()\nself.socket = self.context.socket(zmq.REQ)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.close","title":"close()","text":"<pre><code>close(kill_server: bool = True) -&gt; None\n</code></pre> <p>Close the connector.</p> <p>Parameters:</p> <ul> <li> kill_server             (<code>bool</code>)         \u2013 <p>Whether to kill the server process. If this instance did not spawn the local node's server process, this is a no-op.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def close(self, kill_server: bool = True) -&gt; None:\n\"\"\"Close the connector.\n    Args:\n        kill_server: Whether to kill the server process. If this instance\n            did not spawn the local node's server process, this is a\n            no-op.\n    \"\"\"\nif kill_server and self.server is not None:\nself.server.terminate()\nself.server.join()\nlogger.info(\n'Terminated local server on connector close '\nf'(pid={self.server.pid})',\n)\nself.socket.close()\nself.context.term()\nlogger.info('Closed ZMQ connector')\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {\n'address': self._address,\n'interface': self._interface,\n'port': self.port,\n'chunk_length': self.chunk_length,\n'timeout': self.timeout,\n}\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; ZeroMQConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; ZeroMQConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.evict","title":"evict()","text":"<pre><code>evict(key: DIMKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def evict(self, key: DIMKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nrpc = RPC(operation='evict', key=key)\nself._send_rpcs([rpc])\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.exists","title":"exists()","text":"<pre><code>exists(key: DIMKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def exists(self, key: DIMKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nrpc = RPC(operation='exists', key=key)\n(response,) = self._send_rpcs([rpc])\nassert response.exists is not None\nreturn response.exists\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.get","title":"get()","text":"<pre><code>get(key: DIMKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>DIMKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def get(self, key: DIMKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nrpc = RPC(operation='get', key=key)\n(result,) = self._send_rpcs([rpc])\nreturn result.data\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[DIMKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[DIMKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def get_batch(self, keys: Sequence[DIMKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nrpcs = [RPC(operation='get', key=key) for key in keys]\nresponses = self._send_rpcs(rpcs)\nreturn [r.data for r in responses]\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; DIMKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DIMKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def put(self, obj: bytes) -&gt; DIMKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = DIMKey(\ndim_type='zmq',\nobj_id=str(uuid.uuid4()),\nsize=len(obj),\npeer_host=self.address,\npeer_port=self.port,\n)\nrpc = RPC(operation='put', key=key, data=obj)\nself._send_rpcs([rpc])\nreturn key\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[DIMKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DIMKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[DIMKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\nkeys = [\nDIMKey(\ndim_type='zmq',\nobj_id=str(uuid.uuid4()),\nsize=len(obj),\npeer_host=self.address,\npeer_port=self.port,\n)\nfor obj in objs\n]\nrpcs = [\nRPC(operation='put', key=key, data=obj)\nfor key, obj in zip(keys, objs)\n]\nself._send_rpcs(rpcs)\nreturn keys\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer","title":"ZeroMQServer","text":"<pre><code>ZeroMQServer() -&gt; None\n</code></pre> <p>ZeroMQServer implementation.</p> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def __init__(self) -&gt; None:\nself.data: dict[str, bytes] = {}\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.evict","title":"evict()","text":"<pre><code>evict(key: str) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def evict(self, key: str) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nself.data.pop(key, None)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.exists","title":"exists()","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nreturn key in self.data\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.get","title":"get()","text":"<pre><code>get(key: str) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Data or <code>None</code> if no data associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def get(self, key: str) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Data or `None` if no data associated with the key exists.\n    \"\"\"\nreturn self.data.get(key, None)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.put","title":"put()","text":"<pre><code>put(key: str, data: bytes) -&gt; None\n</code></pre> <p>Put data in the store.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with data.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Data to put in the store.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def put(self, key: str, data: bytes) -&gt; None:\n\"\"\"Put data in the store.\n    Args:\n        key: Key associated with data.\n        data: Data to put in the store.\n    \"\"\"\nself.data[key] = data\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.handle_rpc","title":"handle_rpc()","text":"<pre><code>handle_rpc(rpc: RPC) -&gt; RPCResponse\n</code></pre> <p>Process an RPC request.</p> <p>Parameters:</p> <ul> <li> rpc             (<code>RPC</code>)         \u2013 <p>Client RPC to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RPCResponse</code>         \u2013 <p>Response containing result or an exception if the operation failed.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def handle_rpc(self, rpc: RPC) -&gt; RPCResponse:\n\"\"\"Process an RPC request.\n    Args:\n        rpc: Client RPC to process.\n    Returns:\n        Response containing result or an exception if the operation failed.\n    \"\"\"\nresponse: RPCResponse\ntry:\nif rpc.operation == 'exists':\nexists = self.exists(rpc.key.obj_id)\nresponse = RPCResponse('exists', key=rpc.key, exists=exists)\nelif rpc.operation == 'evict':\nself.evict(rpc.key.obj_id)\nresponse = RPCResponse('evict', key=rpc.key)\nelif rpc.operation == 'get':\ndata = self.get(rpc.key.obj_id)\nresponse = RPCResponse('get', key=rpc.key, data=data)\nelif rpc.operation == 'put':\nassert rpc.data is not None\nself.put(rpc.key.obj_id, rpc.data)\nresponse = RPCResponse('put', key=rpc.key)\nelse:\nraise AssertionError('Unreachable.')\nexcept Exception as e:\nresponse = RPCResponse(rpc.operation, key=rpc.key, exception=e)\nreturn response\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.run_server","title":"run_server()  <code>async</code>","text":"<pre><code>run_server(\naddress: str, port: int, chunk_length: int | None = None\n) -&gt; None\n</code></pre> <p>Listen and reply to RPCs from clients.</p> Warning <p>This function does not return until SIGINT or SIGTERM is received.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>IP address the server should bind to.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port the server should listen on.</p> </li> <li> chunk_length             (<code>int | None</code>)         \u2013 <p>Message chunk size in bytes. Defaults to <code>MAX_CHUNK_LENGTH_DEFAULT</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>async def run_server(\naddress: str,\nport: int,\nchunk_length: int | None = None,\n) -&gt; None:\n\"\"\"Listen and reply to RPCs from clients.\n    Warning:\n        This function does not return until SIGINT or SIGTERM is received.\n    Args:\n        address: IP address the server should bind to.\n        port: Port the server should listen on.\n        chunk_length: Message chunk size in bytes. Defaults to\n            `MAX_CHUNK_LENGTH_DEFAULT`.\n    \"\"\"\nloop = asyncio.get_running_loop()\nclose_future = loop.create_future()\nloop.add_signal_handler(signal.SIGINT, close_future.set_result, None)\nloop.add_signal_handler(signal.SIGTERM, close_future.set_result, None)\nserver = ZeroMQServer()\nchunk_length = (\nMAX_CHUNK_LENGTH_DEFAULT if chunk_length is None else chunk_length\n)\ncontext = zmq.asyncio.Context()\nsocket = context.socket(zmq.REP)\nsocket.setsockopt(zmq.RCVTIMEO, 100)\nwith socket.bind(f'tcp://{address}:{port}'):\nwhile not close_future.done():\ntry:\nrpc_parts = await socket.recv_multipart()\nexcept zmq.error.Again:\ncontinue\nrpc_bytes = b''.join(rpc_parts)\nif rpc_bytes == b'ping':\nawait socket.send(b'pong')\ncontinue\nrpc: RPC = deserialize(rpc_bytes)\nresponse = server.handle_rpc(rpc)\nmessage = serialize(response)\nawait socket.send_multipart(\nlist(utils.chunk_bytes(message, chunk_length)),\n)\nloop.remove_signal_handler(signal.SIGINT)\nloop.remove_signal_handler(signal.SIGTERM)\nsocket.close()\ncontext.term()\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.start_server","title":"start_server()","text":"<pre><code>start_server(\naddress: str, port: int, chunk_length: int | None = None\n) -&gt; None\n</code></pre> <p>Run a local server.</p> Note <p>This function creates an event loop and executes <code>run_server()</code> within that loop.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>IP address the server should bind to.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port the server should listen on.</p> </li> <li> chunk_length             (<code>int | None</code>)         \u2013 <p>Message chunk size in bytes. Defaults to <code>MAX_CHUNK_LENGTH_DEFAULT</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def start_server(\naddress: str,\nport: int,\nchunk_length: int | None = None,\n) -&gt; None:\n\"\"\"Run a local server.\n    Note:\n        This function creates an event loop and executes\n        [`run_server()`][proxystore.connectors.dim.zmq.run_server] within\n        that loop.\n    Args:\n        address: IP address the server should bind to.\n        port: Port the server should listen on.\n        chunk_length: Message chunk size in bytes. Defaults to\n            `MAX_CHUNK_LENGTH_DEFAULT`.\n    \"\"\"\nasyncio.run(run_server(address, port, chunk_length))\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.spawn_server","title":"spawn_server()","text":"<pre><code>spawn_server(\naddress: str,\nport: int,\n*,\nchunk_length: int | None = None,\nspawn_timeout: float = 5.0,\nkill_timeout: float | None = 1.0\n) -&gt; multiprocessing.Process\n</code></pre> <p>Spawn a local server running in a separate process.</p> Note <p>An <code>atexit</code> callback is registered which will terminate the spawned server process when the calling process exits.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>IP address the server should bind to.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port the server will listen on.</p> </li> <li> chunk_length             (<code>int | None</code>)         \u2013 <p>Message chunk size in bytes. Defaults to <code>MAX_CHUNK_LENGTH_DEFAULT</code>.</p> </li> <li> spawn_timeout             (<code>float</code>)         \u2013 <p>Max time in seconds to wait for the server to start.</p> </li> <li> kill_timeout             (<code>float | None</code>)         \u2013 <p>Max time in seconds to wait for the server to shutdown on exit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>multiprocessing.Process</code>         \u2013 <p>The process that the server is running in.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def spawn_server(\naddress: str,\nport: int,\n*,\nchunk_length: int | None = None,\nspawn_timeout: float = 5.0,\nkill_timeout: float | None = 1.0,\n) -&gt; multiprocessing.Process:\n\"\"\"Spawn a local server running in a separate process.\n    Note:\n        An `atexit` callback is registered which will terminate the spawned\n        server process when the calling process exits.\n    Args:\n        address: IP address the server should bind to.\n        port: Port the server will listen on.\n        chunk_length: Message chunk size in bytes. Defaults to\n            `MAX_CHUNK_LENGTH_DEFAULT`.\n        spawn_timeout: Max time in seconds to wait for the server to start.\n        kill_timeout: Max time in seconds to wait for the server to shutdown\n            on exit.\n    Returns:\n        The process that the server is running in.\n    \"\"\"\nserver_process = multiprocessing.Process(\ntarget=start_server,\nargs=(address, port, chunk_length),\n)\nserver_process.start()\ndef _kill_on_exit() -&gt; None:  # pragma: no cover\nserver_process.terminate()\nserver_process.join(timeout=kill_timeout)\nif server_process.is_alive():\nserver_process.kill()\nserver_process.join()\nlogger.debug(\n'Server terminated on parent process exit '\nf'(pid={server_process.pid})',\n)\natexit.register(_kill_on_exit)\nlogger.debug('Registered server cleanup atexit callback')\nwait_for_server(address, port, timeout=spawn_timeout)\nlogger.debug(\nf'Server started (host={address}, port={port}, pid={server_process.pid})',\n)\nreturn server_process\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.wait_for_server","title":"wait_for_server()","text":"<pre><code>wait_for_server(\naddress: str, port: int, timeout: float = 0.1\n) -&gt; None\n</code></pre> <p>Wait until the server responds.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Host of the server to ping.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port of the server to ping.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Max time in seconds to wait for server response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013         <p>If the server does not respond within the timeout.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def wait_for_server(address: str, port: int, timeout: float = 0.1) -&gt; None:\n\"\"\"Wait until the server responds.\n    Args:\n        address: Host of the server to ping.\n        port: Port of the server to ping.\n        timeout: Max time in seconds to wait for server response.\n    Raises:\n        ServerTimeoutError: If the server does not respond within the timeout.\n    \"\"\"\nstart = time.time()\ncontext = zmq.Context()\nsocket = context.socket(zmq.REQ)\nsocket.setsockopt(zmq.LINGER, 0)\nsocket.connect(f'tcp://{address}:{port}')\nsocket.send(b'ping')\npoller = zmq.Poller()\npoller.register(socket, zmq.POLLIN)\nwhile time.time() - start &lt; timeout:\n# Poll for 100ms\nevent = poller.poll(100)\nif len(event) != 0:\nresponse = socket.recv()\nassert response == b'pong'\nsocket.close()\nreturn\nsocket.close()\nraise ServerTimeoutError(\nf'Failed to connect to server within timeout ({timeout} seconds).',\n)\n</code></pre>"},{"location":"api/endpoint/","title":"proxystore.endpoint","text":"<code>proxystore/endpoint/__init__.py</code> <p>Endpoints for direct, cross-site communication.</p> Note <p>Please refer to the Endpoints Guide for an introduction to endpoints in ProxyStore.</p> <p><code>Endpoints</code> are in-memory object stores with peering capabilities. Endpoints enable peer-to-peer data transfer between clients behind different NATs. See the <code>proxystore-endpoint</code> CLI reference to start your own endpoints.</p>"},{"location":"api/endpoint/cli/","title":"proxystore.endpoint.cli","text":"<code>proxystore/endpoint/cli.py</code> <p><code>proxystore-endpoint</code> command-line interface.</p> <p>See the CLI Reference for the <code>proxystore-endpoint</code> usage instructions.</p>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.cli","title":"cli()","text":"<pre><code>cli(ctx: click.Context, log_level: str) -&gt; None\n</code></pre> <p>Manage and start ProxyStore Endpoints.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@click.group()\n@click.option(\n'--log-level',\ndefault='INFO',\ntype=click.Choice(\n['ERROR', 'WARNING', 'INFO', 'DEBUG'],\ncase_sensitive=False,\n),\nhelp='Minimum logging level.',\n)\n@click.pass_context\ndef cli(ctx: click.Context, log_level: str) -&gt; None:\n\"\"\"Manage and start ProxyStore Endpoints.\"\"\"\nhandler = logging.StreamHandler(sys.stdout)\nhandler.setFormatter(_CLIFormatter())\nlogging.basicConfig(level=log_level, handlers=[handler])\nctx.ensure_object(dict)\nctx.obj['LOG_LEVEL'] = log_level\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.show_help","title":"show_help()","text":"<pre><code>show_help() -&gt; None\n</code></pre> <p>Show available commands and options.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command(name='help')\ndef show_help() -&gt; None:\n\"\"\"Show available commands and options.\"\"\"\nwith click.Context(cli) as ctx:\nclick.echo(cli.get_help(ctx))\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.version","title":"version()","text":"<pre><code>version() -&gt; None\n</code></pre> <p>Show the ProxyStore version.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command()\ndef version() -&gt; None:\n\"\"\"Show the ProxyStore version.\"\"\"\nclick.echo(f'ProxyStore v{proxystore.__version__}')\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.configure","title":"configure()","text":"<pre><code>configure(\nname: str,\nport: int,\nrelay_server: str,\npeer_channels: int,\npersist: bool,\n) -&gt; None\n</code></pre> <p>Configure a new endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command()\n@click.argument('name', metavar='NAME', required=True)\n@click.option(\n'--port',\ndefault=8765,\ntype=int,\nmetavar='PORT',\nhelp='Port to listen on.',\n)\n@click.option(\n'--relay-server',\ndefault=None,\nmetavar='ADDR',\nhelp='Optional relay server address.',\n)\n@click.option(\n'--peer-channels',\ndefault=1,\ntype=int,\nmetavar='COUNT',\nhelp='Datachannels to use per peer connection.',\n)\n@click.option(\n'--persist/--no-persist',\ndefault=False,\nmetavar='BOOL',\nhelp='Optionally persist data to a database.',\n)\ndef configure(\nname: str,\nport: int,\nrelay_server: str,\npeer_channels: int,\npersist: bool,\n) -&gt; None:\n\"\"\"Configure a new endpoint.\"\"\"\nraise SystemExit(\nconfigure_endpoint(\nname,\nport=port,\nrelay_server=relay_server,\npeer_channels=peer_channels,\npersist_data=persist,\n),\n)\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.list_all","title":"list_all()","text":"<pre><code>list_all() -&gt; None\n</code></pre> <p>List all user endpoints.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command(name='list')\ndef list_all() -&gt; None:\n\"\"\"List all user endpoints.\"\"\"\nraise SystemExit(list_endpoints())\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.remove","title":"remove()","text":"<pre><code>remove(name: str) -&gt; None\n</code></pre> <p>Remove an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command()\n@click.argument('name', metavar='NAME', required=True)\ndef remove(name: str) -&gt; None:\n\"\"\"Remove an endpoint.\"\"\"\nraise SystemExit(remove_endpoint(name))\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.start","title":"start()","text":"<pre><code>start(ctx: click.Context, name: str, detach: bool) -&gt; None\n</code></pre> <p>Start an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command()\n@click.argument('name', metavar='NAME', required=True)\n@click.option('--detach/--no-detach', default=True, help='Run as daemon.')\n@click.pass_context\ndef start(ctx: click.Context, name: str, detach: bool) -&gt; None:\n\"\"\"Start an endpoint.\"\"\"\nraise SystemExit(\nstart_endpoint(name, detach=detach, log_level=ctx.obj['LOG_LEVEL']),\n)\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.stop","title":"stop()","text":"<pre><code>stop(name: str) -&gt; None\n</code></pre> <p>Stop a detached endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command()\n@click.argument('name', metavar='NAME', required=True)\ndef stop(name: str) -&gt; None:\n\"\"\"Stop a detached endpoint.\"\"\"\nraise SystemExit(stop_endpoint(name))\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.test","title":"test()","text":"<pre><code>test(\nctx: click.Context, name: str, remote: str | None\n) -&gt; None\n</code></pre> <p>Execute test commands on an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.group()\n@click.argument('name', metavar='NAME', required=True)\n@click.option(\n'--remote',\nmetavar='UUID',\nhelp='Optional UUID of remote endpoint to use.',\n)\n@click.pass_context\ndef test(\nctx: click.Context,\nname: str,\nremote: str | None,\n) -&gt; None:\n\"\"\"Execute test commands on an endpoint.\"\"\"\nctx.ensure_object(dict)\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\nif os.path.isdir(endpoint_dir):\ncfg = read_config(endpoint_dir)\nelse:\nlogger.error(f'An endpoint named {name} does not exist.')\nraise SystemExit(1)\nctx.obj['ENDPOINT_ADDRESS'] = f'http://{cfg.host}:{cfg.port}'\nctx.obj['REMOTE_ENDPOINT_UUID'] = remote\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.evict","title":"evict()","text":"<pre><code>evict(ctx: click.Context, key: str) -&gt; None\n</code></pre> <p>Evict object from an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@test.command()\n@click.argument('key', metavar='KEY', required=True)\n@click.pass_context\ndef evict(ctx: click.Context, key: str) -&gt; None:\n\"\"\"Evict object from an endpoint.\"\"\"\naddress = ctx.obj['ENDPOINT_ADDRESS']\nremote = ctx.obj['REMOTE_ENDPOINT_UUID']\ntry:\nclient.evict(address, key, remote)\nexcept requests.exceptions.ConnectionError as e:\nlogger.error(f'Unable to connect to endpoint at {address}.')\nlogger.debug(e)\nsys.exit(1)\nexcept requests.exceptions.RequestException as e:\nlogger.error(e)\nsys.exit(1)\nelse:\nlogger.info('Evicted object from endpoint.')\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.exists","title":"exists()","text":"<pre><code>exists(ctx: click.Context, key: str) -&gt; None\n</code></pre> <p>Check if object exists in an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@test.command()\n@click.argument('key', metavar='KEY', required=True)\n@click.pass_context\ndef exists(ctx: click.Context, key: str) -&gt; None:\n\"\"\"Check if object exists in an endpoint.\"\"\"\naddress = ctx.obj['ENDPOINT_ADDRESS']\nremote = ctx.obj['REMOTE_ENDPOINT_UUID']\ntry:\nres = client.exists(address, key, remote)\nexcept requests.exceptions.ConnectionError as e:\nlogger.error(f'Unable to connect to endpoint at {address}.')\nlogger.debug(e)\nsys.exit(1)\nexcept requests.exceptions.RequestException as e:\nlogger.error(e)\nsys.exit(1)\nelse:\nlogger.info(f'Object exists: {res}')\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.get","title":"get()","text":"<pre><code>get(ctx: click.Context, key: str) -&gt; None\n</code></pre> <p>Get an object from an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@test.command()\n@click.argument('key', metavar='KEY', required=True)\n@click.pass_context\ndef get(ctx: click.Context, key: str) -&gt; None:\n\"\"\"Get an object from an endpoint.\"\"\"\naddress = ctx.obj['ENDPOINT_ADDRESS']\nremote = ctx.obj['REMOTE_ENDPOINT_UUID']\ntry:\nres = client.get(address, key, remote)\nexcept requests.exceptions.ConnectionError as e:\nlogger.error(f'Unable to connect to endpoint at {address}.')\nlogger.debug(e)\nsys.exit(1)\nexcept requests.exceptions.RequestException as e:\nlogger.error(e)\nsys.exit(1)\nif res is None:\nlogger.info('Object does not exist.')\nelse:\nobj = deserialize(res)\nlogger.info(f'Result: {obj}')\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.put","title":"put()","text":"<pre><code>put(ctx: click.Context, data: str) -&gt; None\n</code></pre> <p>Put an object in an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@test.command()\n@click.argument('data', required=True)\n@click.pass_context\ndef put(ctx: click.Context, data: str) -&gt; None:\n\"\"\"Put an object in an endpoint.\"\"\"\naddress = ctx.obj['ENDPOINT_ADDRESS']\nremote = ctx.obj['REMOTE_ENDPOINT_UUID']\nkey = str(uuid.uuid4())\ndata_ = serialize(data)\ntry:\nclient.put(address, key, data_, remote)\nexcept requests.exceptions.ConnectionError as e:\nlogger.error(f'Unable to connect to endpoint at {address}.')\nlogger.debug(e)\nsys.exit(1)\nexcept requests.exceptions.RequestException as e:\nlogger.error(e)\nsys.exit(1)\nelse:\nlogger.info(f'Put object in endpoint with key {key}')\n</code></pre>"},{"location":"api/endpoint/client/","title":"proxystore.endpoint.client","text":"<code>proxystore/endpoint/client.py</code> <p>Utilities for client interactions with endpoints.</p>"},{"location":"api/endpoint/client/#proxystore.endpoint.client.evict","title":"evict()","text":"<pre><code>evict(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\nsession: requests.Session | None = None,\n) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of endpoint.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key associated with object to evict.</p> </li> <li> endpoint             (<code>uuid.UUID | str | None</code>)         \u2013 <p>Optional UUID of remote endpoint to forward operation to.</p> </li> <li> session             (<code>requests.Session | None</code>)         \u2013 <p>Session instance to use for making the request. Reusing the same session across multiple requests to the same host can improve performance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestException</code>           \u2013         <p>If the endpoint request results in an unexpected error code.</p> </li> </ul> Source code in <code>proxystore/endpoint/client.py</code> <pre><code>def evict(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\nsession: requests.Session | None = None,\n) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        address: Address of endpoint.\n        key: Key associated with object to evict.\n        endpoint: Optional UUID of remote endpoint to forward operation to.\n        session: Session instance to use for making the request. Reusing the\n            same session across multiple requests to the same host can improve\n            performance.\n    Raises:\n        RequestException: If the endpoint request results in an unexpected\n            error code.\n    \"\"\"\nendpoint_str = (\nstr(endpoint) if isinstance(endpoint, uuid.UUID) else endpoint\n)\npost = requests.post if session is None else session.post\nresponse = post(\nf'{address}/evict',\nparams={'key': key, 'endpoint': endpoint_str},\n)\nif not response.ok:\nraise requests.exceptions.RequestException(\nf'Endpoint returned HTTP error code {response.status_code}. '\nf'{response.text}',\nresponse=response,\n)\n</code></pre>"},{"location":"api/endpoint/client/#proxystore.endpoint.client.exists","title":"exists()","text":"<pre><code>exists(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\nsession: requests.Session | None = None,\n) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of endpoint.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> <li> endpoint             (<code>uuid.UUID | str | None</code>)         \u2013 <p>Optional UUID of remote endpoint to forward operation to.</p> </li> <li> session             (<code>requests.Session | None</code>)         \u2013 <p>Session instance to use for making the request. Reusing the same session across multiple requests to the same host can improve performance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestException</code>           \u2013         <p>If the endpoint request results in an unexpected error code.</p> </li> </ul> Source code in <code>proxystore/endpoint/client.py</code> <pre><code>def exists(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\nsession: requests.Session | None = None,\n) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        address: Address of endpoint.\n        key: Key potentially associated with stored object.\n        endpoint: Optional UUID of remote endpoint to forward operation to.\n        session: Session instance to use for making the request. Reusing the\n            same session across multiple requests to the same host can improve\n            performance.\n    Returns:\n        If an object associated with the key exists.\n    Raises:\n        RequestException: If the endpoint request results in an unexpected\n            error code.\n    \"\"\"\nendpoint_str = (\nstr(endpoint) if isinstance(endpoint, uuid.UUID) else endpoint\n)\nget_ = requests.get if session is None else session.get\nresponse = get_(\nf'{address}/exists',\nparams={'key': key, 'endpoint': endpoint_str},\n)\nif not response.ok:\nraise requests.exceptions.RequestException(\nf'Endpoint returned HTTP error code {response.status_code}. '\nf'{response.text}',\nresponse=response,\n)\nreturn response.json()['exists']\n</code></pre>"},{"location":"api/endpoint/client/#proxystore.endpoint.client.get","title":"get()","text":"<pre><code>get(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\nsession: requests.Session | None = None,\n) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of endpoint.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key associated with object to retrieve.</p> </li> <li> endpoint             (<code>uuid.UUID | str | None</code>)         \u2013 <p>Optional UUID of remote endpoint to forward operation to.</p> </li> <li> session             (<code>requests.Session | None</code>)         \u2013 <p>Session instance to use for making the request. Reusing the same session across multiple requests to the same host can improve performance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestException</code>           \u2013         <p>If the endpoint request results in an unexpected error code.</p> </li> </ul> Source code in <code>proxystore/endpoint/client.py</code> <pre><code>def get(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\nsession: requests.Session | None = None,\n) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        address: Address of endpoint.\n        key: Key associated with object to retrieve.\n        endpoint: Optional UUID of remote endpoint to forward operation to.\n        session: Session instance to use for making the request. Reusing the\n            same session across multiple requests to the same host can improve\n            performance.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    Raises:\n        RequestException: If the endpoint request results in an unexpected\n            error code.\n    \"\"\"\nendpoint_str = (\nstr(endpoint) if isinstance(endpoint, uuid.UUID) else endpoint\n)\nget_ = requests.get if session is None else session.get\nresponse = get_(\nf'{address}/get',\nparams={'key': key, 'endpoint': endpoint_str},\nstream=True,\n)\nif response.status_code == 400:\nreturn None\nif not response.ok:\nraise requests.exceptions.RequestException(\nf'Endpoint returned HTTP error code {response.status_code}. '\nf'{response.text}',\nresponse=response,\n)\ndata = bytearray()\nfor chunk in response.iter_content(chunk_size=None):\ndata += chunk\nreturn bytes(data)\n</code></pre>"},{"location":"api/endpoint/client/#proxystore.endpoint.client.put","title":"put()","text":"<pre><code>put(\naddress: str,\nkey: str,\ndata: bytes,\nendpoint: uuid.UUID | str | None = None,\nsession: requests.Session | None = None,\n) -&gt; None\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of endpoint.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key associated with object to retrieve.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Serialized data to put in the store.</p> </li> <li> endpoint             (<code>uuid.UUID | str | None</code>)         \u2013 <p>Optional UUID of remote endpoint to forward operation to.</p> </li> <li> session             (<code>requests.Session | None</code>)         \u2013 <p>Session instance to use for making the request. Reusing the same session across multiple requests to the same host can improve performance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestException</code>           \u2013         <p>If the endpoint request results in an unexpected error code.</p> </li> </ul> Source code in <code>proxystore/endpoint/client.py</code> <pre><code>def put(\naddress: str,\nkey: str,\ndata: bytes,\nendpoint: uuid.UUID | str | None = None,\nsession: requests.Session | None = None,\n) -&gt; None:\n\"\"\"Put a serialized object in the store.\n    Args:\n        address: Address of endpoint.\n        key: Key associated with object to retrieve.\n        data: Serialized data to put in the store.\n        endpoint: Optional UUID of remote endpoint to forward operation to.\n        session: Session instance to use for making the request. Reusing the\n            same session across multiple requests to the same host can improve\n            performance.\n    Raises:\n        RequestException: If the endpoint request results in an unexpected\n            error code.\n    \"\"\"\nendpoint_str = (\nstr(endpoint) if isinstance(endpoint, uuid.UUID) else endpoint\n)\npost = requests.post if session is None else session.post\nresponse = post(\nf'{address}/set',\nheaders={'Content-Type': 'application/octet-stream'},\nparams={'key': key, 'endpoint': endpoint_str},\ndata=chunk_bytes(data, MAX_CHUNK_LENGTH),\nstream=True,\n)\nif not response.ok:\nraise requests.exceptions.RequestException(\nf'Endpoint returned HTTP error code {response.status_code}. '\nf'{response.text}',\nresponse=response,\n)\n</code></pre>"},{"location":"api/endpoint/commands/","title":"proxystore.endpoint.commands","text":"<code>proxystore/endpoint/commands.py</code> <p>Endpoint management commands.</p> <p>These are the implementations of the commands available via the <code>proxystore-endpoint</code> command. Subsequently, all commands log errors and results and return status codes (rather than raising errors and returning results).</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus","title":"EndpointStatus","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Endpoint status.</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.RUNNING","title":"RUNNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RUNNING = enum.auto()\n</code></pre> <p>Endpoint is running on this host.</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.STOPPED","title":"STOPPED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOPPED = enum.auto()\n</code></pre> <p>Endpoint is stopped.</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN = enum.auto()\n</code></pre> <p>Endpoint cannot be found (missing/corrupted directory).</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.HANGING","title":"HANGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HANGING = enum.auto()\n</code></pre> <p>Endpoint PID file exists but process is not active.</p> <p>This is either because the process died unexpectedly or the endpoint is running on another host.</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.get_status","title":"get_status()","text":"<pre><code>get_status(\nname: str, proxystore_dir: str | None = None\n) -&gt; EndpointStatus\n</code></pre> <p>Check status of endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to check.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EndpointStatus</code>         \u2013 <p><code>EndpointStatus.RUNNING</code> if the endpoint has a valid directory and         the PID file points to a running process.         <code>EndpointStatus.STOPPED</code> if the endpoint has a valid directory and no         PID file.         <code>EndpointStatus.UNKNOWN</code> if the endpoint directory is missing or the         config file is missing/unreadable.         <code>EndpointStatus.HANGING</code> if the endpoint has a valid directory but         the PID file does not point to a running process. This can be due to         the endpoint process dying unexpectedly or the endpoint process is on         a different host.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def get_status(name: str, proxystore_dir: str | None = None) -&gt; EndpointStatus:\n\"\"\"Check status of endpoint.\n    Args:\n        name: Name of endpoint to check.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        `EndpointStatus.RUNNING` if the endpoint has a valid directory and \\\n        the PID file points to a running process. \\\n        `EndpointStatus.STOPPED` if the endpoint has a valid directory and no \\\n        PID file. \\\n        `EndpointStatus.UNKNOWN` if the endpoint directory is missing or the \\\n        config file is missing/unreadable. \\\n        `EndpointStatus.HANGING` if the endpoint has a valid directory but \\\n        the PID file does not point to a running process. This can be due to \\\n        the endpoint process dying unexpectedly or the endpoint process is on \\\n        a different host.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\nif not os.path.isdir(endpoint_dir):\nreturn EndpointStatus.UNKNOWN\ntry:\nread_config(endpoint_dir)\nexcept (FileNotFoundError, ValueError) as e:\nlogger.error(e)\nreturn EndpointStatus.UNKNOWN\npid_file = get_pid_filepath(endpoint_dir)\nif not os.path.isfile(pid_file):\nreturn EndpointStatus.STOPPED\npid = int(open(pid_file).read().strip())\nif psutil.pid_exists(pid):\nreturn EndpointStatus.RUNNING\nelse:\nreturn EndpointStatus.HANGING\n</code></pre>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.configure_endpoint","title":"configure_endpoint()","text":"<pre><code>configure_endpoint(\nname: str,\n*,\nport: int,\nrelay_server: str | None,\nproxystore_dir: str | None = None,\npeer_channels: int = 1,\npersist_data: bool = False\n) -&gt; int\n</code></pre> <p>Configure a new endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port for endpoint to listen on.</p> </li> <li> relay_server             (<code>str | None</code>)         \u2013 <p>Optional relay server address for P2P endpoint connections.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>Number of datachannels per peer connection to another endpoint to communicate over.</p> </li> <li> persist_data             (<code>bool</code>)         \u2013 <p>Persist data stored in the endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def configure_endpoint(\nname: str,\n*,\nport: int,\nrelay_server: str | None,\nproxystore_dir: str | None = None,\npeer_channels: int = 1,\npersist_data: bool = False,\n) -&gt; int:\n\"\"\"Configure a new endpoint.\n    Args:\n        name: Name of endpoint.\n        port: Port for endpoint to listen on.\n        relay_server: Optional relay server address for P2P endpoint connections.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n        peer_channels: Number of datachannels per peer connection\n            to another endpoint to communicate over.\n        persist_data: Persist data stored in the endpoint.\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\ndatabase_path = (\nos.path.join(endpoint_dir, ENDPOINT_DATABASE_FILE)\nif persist_data\nelse None\n)\ntry:\ncfg = EndpointConfig(\nname=name,\nuuid=uuid.uuid4(),\nhost=None,\nport=port,\nrelay_server=relay_server,\ndatabase_path=database_path,\npeer_channels=peer_channels,\n)\nexcept ValueError as e:\nlogger.error(str(e))\nreturn 1\nif os.path.exists(endpoint_dir):\nlogger.error(f'An endpoint named {name} already exists.')\nlogger.info('To reconfigure the endpoint, remove and try again.')\nreturn 1\nwrite_config(cfg, endpoint_dir)\nlogger.info(f'Configured endpoint {cfg.name} &lt;{cfg.uuid}&gt;. Start with:')\nlogger.info(f'  $ proxystore-endpoint start {cfg.name}')\nreturn 0\n</code></pre>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.list_endpoints","title":"list_endpoints()","text":"<pre><code>list_endpoints(*, proxystore_dir: str | None = None) -&gt; int\n</code></pre> <p>List available endpoints.</p> <p>Parameters:</p> <ul> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def list_endpoints(\n*,\nproxystore_dir: str | None = None,\n) -&gt; int:\n\"\"\"List available endpoints.\n    Args:\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoints = get_configs(proxystore_dir)\nif len(endpoints) == 0:\nlogger.info(f'No valid endpoint configurations in {proxystore_dir}.')\nelse:\neps = [(e.name, str(e.uuid)) for e in endpoints]\neps = sorted(eps, key=lambda x: x[0])\nlogger.info(f'{\"NAME\":&lt;18} {\"STATUS\":&lt;8} UUID', extra={'simple': True})\nlogger.info('=' * (19 + 9 + len(eps[0][1])), extra={'simple': True})\nfor name, uuid_ in eps:\nstatus = get_status(name, proxystore_dir)\nlogger.info(\nf'{name:18.18} {status.name:&lt;8.8} {uuid_}',\nextra={'simple': True},\n)\nreturn 0\n</code></pre>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.remove_endpoint","title":"remove_endpoint()","text":"<pre><code>remove_endpoint(\nname: str, *, proxystore_dir: str | None = None\n) -&gt; int\n</code></pre> <p>Remove endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to remove.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def remove_endpoint(\nname: str,\n*,\nproxystore_dir: str | None = None,\n) -&gt; int:\n\"\"\"Remove endpoint.\n    Args:\n        name: Name of endpoint to remove.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\nif not os.path.exists(endpoint_dir):\nlogger.error(f'An endpoint named {name} does not exist.')\nreturn 1\nstatus = get_status(name, proxystore_dir)\nif status in (EndpointStatus.RUNNING, EndpointStatus.HANGING):\nlogger.error('Endpoint must be stopped before removing.')\nlogger.error(f'  $ proxystore-endpoint stop {name}')\nreturn 1\nshutil.rmtree(endpoint_dir)\nlogger.info(f'Removed endpoint named {name}.')\nreturn 0\n</code></pre>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.start_endpoint","title":"start_endpoint()","text":"<pre><code>start_endpoint(\nname: str,\n*,\ndetach: bool = False,\nlog_level: str = \"INFO\",\nproxystore_dir: str | None = None\n) -&gt; int\n</code></pre> <p>Start endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to start.</p> </li> <li> detach             (<code>bool</code>)         \u2013 <p>Start the endpoint as a daemon process.</p> </li> <li> log_level             (<code>str</code>)         \u2013 <p>Logging level of the endpoint.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def start_endpoint(\nname: str,\n*,\ndetach: bool = False,\nlog_level: str = 'INFO',\nproxystore_dir: str | None = None,\n) -&gt; int:\n\"\"\"Start endpoint.\n    Args:\n        name: Name of endpoint to start.\n        detach: Start the endpoint as a daemon process.\n        log_level: Logging level of the endpoint.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nstatus = get_status(name, proxystore_dir)\nif status == EndpointStatus.RUNNING:\nlogger.error(f'Endpoint {name} is already running.')\nreturn 1\nelif status == EndpointStatus.UNKNOWN:\nlogger.error(f'A valid endpoint named {name} does not exist.')\nlogger.error('Use `list` to see available endpoints.')\nreturn 1\nendpoint_dir = os.path.join(proxystore_dir, name)\ncfg = read_config(endpoint_dir)\n# Use IP address here which is generally more reliable\nhostname = socket.gethostbyname(utils.hostname())\npid_file = get_pid_filepath(endpoint_dir)\nif (\nstatus == EndpointStatus.HANGING\nand cfg.host is not None\nand hostname != cfg.host\n):\nlogger.error(\n'A PID file exists for the endpoint, but the config indicates the '\nf'endpoint is running on a host named {cfg.host}. Try stopping '\nf'the endpoint on {cfg.host}. Otherwise, delete the PID file at '\nf'{pid_file} and try again.',\n)\nreturn 1\nelif status == EndpointStatus.HANGING:\nlogger.debug(f'Removing invalid PID file ({pid_file}).')\nos.remove(pid_file)\n# Write out new config with host so clients can see the current host\ncfg.host = hostname\nwrite_config(cfg, endpoint_dir)\nlog_file = get_log_filepath(endpoint_dir)\nif detach:\nlogger.info('Starting endpoint process as daemon.')\nlogger.info(f'Logs will be written to {log_file}')\ncontext = daemon.DaemonContext(\nworking_directory=endpoint_dir,\numask=0o002,\npidfile=daemon.pidfile.PIDLockFile(pid_file),\ndetach_process=True,\n# Note: stdin, stdout, stderr left as None which binds to /dev/null\n)\nelse:\ncontext = _attached_pid_manager(pid_file)\n# TODO: handle sigterm/sigkill exit codes/graceful shutdown.\nwith context:\nserve(cfg, log_level=log_level, log_file=log_file)\nreturn 0\n</code></pre>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.stop_endpoint","title":"stop_endpoint()","text":"<pre><code>stop_endpoint(\nname: str, *, proxystore_dir: str | None = None\n) -&gt; int\n</code></pre> <p>Stop endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to start.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def stop_endpoint(name: str, *, proxystore_dir: str | None = None) -&gt; int:\n\"\"\"Stop endpoint.\n    Args:\n        name: Name of endpoint to start.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nstatus = get_status(name, proxystore_dir)\nif status == EndpointStatus.UNKNOWN:\nlogger.error(f'A valid endpoint named {name} does not exist.')\nlogger.error('Use `list` to see available endpoints.')\nreturn 1\nelif status == EndpointStatus.STOPPED:\nlogger.info(f'Endpoint {name} is not running.')\nreturn 0\nendpoint_dir = os.path.join(proxystore_dir, name)\ncfg = read_config(endpoint_dir)\nhostname = utils.hostname()\npid_file = get_pid_filepath(endpoint_dir)\nif (\nstatus == EndpointStatus.HANGING\nand cfg.host is not None\nand hostname != cfg.host\n):\nlogger.error(\n'A PID file exists for the endpoint, but the config indicates the '\nf'endpoint is running on a host named {cfg.host}. Try stopping '\nf'the endpoint on {cfg.host}. Otherwise, delete the PID file at '\nf'{pid_file} and try again.',\n)\nreturn 1\nelif status == EndpointStatus.HANGING:\nlogger.debug(f'Removing invalid PID file ({pid_file}).')\nos.remove(pid_file)\nlogger.info(f'Endpoint {name} is not running.')\nreturn 0\nassert status == EndpointStatus.RUNNING\nwith open(pid_file) as f:\npid = int(f.read().strip())\nlogger.debug(f'Terminating endpoint process (PID: {pid}).')\n# Source: https://github.com/funcx-faas/funcX/blob/facf37348f9a9eb4e1a0572793d7b6819be5754d/funcx_endpoint/funcx_endpoint/endpoint/endpoint.py#L360  # noqa: E501\nparent = psutil.Process(pid)\nprocesses = parent.children(recursive=True)\nprocesses.append(parent)\nfor p in processes:\np.send_signal(signal.SIGTERM)\nterminated, alive = psutil.wait_procs(processes, timeout=1)\nfor p in alive:  # pragma: no cover\ntry:\np.send_signal(signal.SIGKILL)\nexcept psutil.NoSuchProcess:\npass\nif os.path.isfile(pid_file):  # pragma: no branch\nlogger.debug(f'Cleaning up PID file ({pid_file}).')\nos.remove(pid_file)\nlogger.info(f'Endpoint {name} has been stopped.')\nreturn 0\n</code></pre>"},{"location":"api/endpoint/config/","title":"proxystore.endpoint.config","text":"<code>proxystore/endpoint/config.py</code> <p>Endpoint configuration.</p>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.EndpointConfig","title":"EndpointConfig  <code>dataclass</code>","text":"<p>Endpoint configuration.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Endpoint name.</p> </li> <li> uuid             (<code>uuid.UUID</code>)         \u2013 <p>Endpoint UUID.</p> </li> <li> host             (<code>str | None</code>)         \u2013 <p>Host endpoint is running on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port endpoint is running on.</p> </li> <li> relay_server             (<code>str | None</code>)         \u2013 <p>Optional relay server the endpoint should register with.</p> </li> <li> database_path             (<code>str | None</code>)         \u2013 <p>Optional path to SQLite database file that will be used for storing endpoint data. If <code>None</code>, data will only be stored in-memory.</p> </li> <li> max_object_size             (<code>int | None</code>)         \u2013 <p>Optional maximum object size.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>Number of peer channels to multiplex communications over.</p> </li> <li> verify_certificates             (<code>int</code>)         \u2013 <p>Validate the SSL certificates of the <code>relay</code> server.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the name does not contain only alphanumeric, dash, or underscore characters, if the UUID cannot be parsed, or if the port is not in the range [1, 65535].</p> </li> </ul>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.get_configs","title":"get_configs()","text":"<pre><code>get_configs(proxystore_dir: str) -&gt; list[EndpointConfig]\n</code></pre> <p>Get all valid endpoint configurations in parent directory.</p> <p>Parameters:</p> <ul> <li> proxystore_dir             (<code>str</code>)         \u2013 <p>Parent directory containing possible endpoint configurations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[EndpointConfig]</code>         \u2013 <p>List of found configs.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def get_configs(proxystore_dir: str) -&gt; list[EndpointConfig]:\n\"\"\"Get all valid endpoint configurations in parent directory.\n    Args:\n        proxystore_dir: Parent directory containing possible endpoint\n            configurations.\n    Returns:\n        List of found configs.\n    \"\"\"\nendpoints: list[EndpointConfig] = []\nif not os.path.isdir(proxystore_dir):\nreturn endpoints\nfor dirpath, _, _ in os.walk(proxystore_dir):\nif os.path.samefile(proxystore_dir, dirpath):\ncontinue\ntry:\ncfg = read_config(dirpath)\nexcept FileNotFoundError:\ncontinue\nexcept ValueError:\ncontinue\nelse:\nendpoints.append(cfg)\nreturn endpoints\n</code></pre>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.get_log_filepath","title":"get_log_filepath()","text":"<pre><code>get_log_filepath(endpoint_dir: str) -&gt; str\n</code></pre> <p>Return path to log file for endpoint.</p> <p>Parameters:</p> <ul> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory for the endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Path to log file.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def get_log_filepath(endpoint_dir: str) -&gt; str:\n\"\"\"Return path to log file for endpoint.\n    Args:\n        endpoint_dir: Directory for the endpoint.\n    Returns:\n        Path to log file.\n    \"\"\"\nreturn os.path.join(endpoint_dir, ENDPOINT_LOG_FILE)\n</code></pre>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.get_pid_filepath","title":"get_pid_filepath()","text":"<pre><code>get_pid_filepath(endpoint_dir: str) -&gt; str\n</code></pre> <p>Return path to PID file for endpoint.</p> <p>Parameters:</p> <ul> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory for the endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Path to PID file.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def get_pid_filepath(endpoint_dir: str) -&gt; str:\n\"\"\"Return path to PID file for endpoint.\n    Args:\n        endpoint_dir: Directory for the endpoint.\n    Returns:\n        Path to PID file.\n    \"\"\"\nreturn os.path.join(endpoint_dir, ENDPOINT_PID_FILE)\n</code></pre>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.read_config","title":"read_config()","text":"<pre><code>read_config(endpoint_dir: str) -&gt; EndpointConfig\n</code></pre> <p>Read endpoint config file.</p> <p>Parameters:</p> <ul> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory containing endpoint configuration file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EndpointConfig</code>         \u2013 <p>Config found in <code>endpoint_dir</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>           \u2013         <p>If a config files does not exist in the directory.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If config contains an invalid value or cannot be parsed.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def read_config(endpoint_dir: str) -&gt; EndpointConfig:\n\"\"\"Read endpoint config file.\n    Args:\n        endpoint_dir: Directory containing endpoint configuration file.\n    Returns:\n        Config found in `endpoint_dir`.\n    Raises:\n        FileNotFoundError: If a config files does not exist in the directory.\n        ValueError: If config contains an invalid value or cannot be parsed.\n    \"\"\"\npath = os.path.join(endpoint_dir, ENDPOINT_CONFIG_FILE)\nif os.path.exists(path):\nwith open(path) as f:\ntry:\ncfg_json = json.load(f)\nexcept json.decoder.JSONDecodeError as e:\nraise ValueError(\nf'Unable to parse ({path}): {e!s}.',\n) from None\ntry:\ncfg = EndpointConfig(**cfg_json)\nexcept TypeError as e:\nraise ValueError(\nf'Keys in config ({path}) do not match expected: {e!s}.',\n) from None\nreturn cfg\nelse:\nraise FileNotFoundError(\nf'Endpoint directory {endpoint_dir} does not contain a valid '\n'configuration.',\n)\n</code></pre>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.validate_name","title":"validate_name()","text":"<pre><code>validate_name(name: str) -&gt; bool\n</code></pre> <p>Validate name only contains alphanumeric or dash/underscore chars.</p> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def validate_name(name: str) -&gt; bool:\n\"\"\"Validate name only contains alphanumeric or dash/underscore chars.\"\"\"\nreturn len(re.findall(r'[^A-Za-z0-9_\\-]', name)) == 0 and len(name) &gt; 0\n</code></pre>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.write_config","title":"write_config()","text":"<pre><code>write_config(\ncfg: EndpointConfig, endpoint_dir: str\n) -&gt; None\n</code></pre> <p>Write config to endpoint directory.</p> <p>Parameters:</p> <ul> <li> cfg             (<code>EndpointConfig</code>)         \u2013 <p>Configuration to write.</p> </li> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory to write config to.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def write_config(cfg: EndpointConfig, endpoint_dir: str) -&gt; None:\n\"\"\"Write config to endpoint directory.\n    Args:\n        cfg: Configuration to write.\n        endpoint_dir: Directory to write config to.\n    \"\"\"\nos.makedirs(endpoint_dir, exist_ok=True)\npath = os.path.join(endpoint_dir, ENDPOINT_CONFIG_FILE)\nwith open(path, 'w') as f:\ndata = dataclasses.asdict(cfg)\ndata['uuid'] = str(data['uuid'])\njson.dump(data, f, indent=4)\n# Add newline so cat on the file looks better\nf.write('\\n')\n</code></pre>"},{"location":"api/endpoint/constants/","title":"proxystore.endpoint.constants","text":"<code>proxystore/endpoint/constants.py</code> <p>Endpoint constants.</p>"},{"location":"api/endpoint/constants/#proxystore.endpoint.constants.MAX_CHUNK_LENGTH","title":"MAX_CHUNK_LENGTH  <code>module-attribute</code>","text":"<pre><code>MAX_CHUNK_LENGTH = 1000000\n</code></pre> <p>Maximum chunk length (bytes) for GET/SET requests to/from the endpoint.</p>"},{"location":"api/endpoint/constants/#proxystore.endpoint.constants.MAX_OBJECT_SIZE_DEFAULT","title":"MAX_OBJECT_SIZE_DEFAULT  <code>module-attribute</code>","text":"<pre><code>MAX_OBJECT_SIZE_DEFAULT = 100000000\n</code></pre> <p>Default maximum endpoint object size in bytes.</p>"},{"location":"api/endpoint/endpoint/","title":"proxystore.endpoint.endpoint","text":"<code>proxystore/endpoint/endpoint.py</code> <p>Endpoint implementation.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.EndpointMode","title":"EndpointMode","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Endpoint mode.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.EndpointMode.PEERING","title":"PEERING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PEERING = 1\n</code></pre> <p>Endpoint will establish peer connections with other endpoints.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.EndpointMode.SOLO","title":"SOLO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOLO = 2\n</code></pre> <p>Endpoint is operating in isolation and will ignore peer requests.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint","title":"Endpoint","text":"<pre><code>Endpoint(\nname: str,\nuuid: UUID,\nrelay_server: str | None = None,\n*,\nmax_object_size: int | None = MAX_OBJECT_SIZE_DEFAULT,\npeer_channels: int = 1,\npeer_timeout: int = 30,\nstorage: Storage | None = None,\nverify_certificate: bool = True\n) -&gt; None\n</code></pre> <p>ProxyStore Endpoint.</p> <p>An endpoint is an object store with <code>get</code>/<code>set</code> functionality.</p> <p>By default, an endpoint operates in <code>EndpointMode.SOLO</code> mode where the endpoint acts just as an isolated object store. Endpoints can also be configured in <code>EndpointMode.PEERING</code> mode by initializing the endpoint with a relay server address. The relay server is used to establish peer-to-peer connections with other endpoints after which endpoints can forward operations between each other. Peering is available even when endpoints are being separate NATs. See the proxystore.p2p module to learn more about peering.</p> Warning <p>Requests made to remote endpoints will only invoke the request on the remote and return the result. I.e., invoking GET on a remote will return the value but will not store it on the local endpoint.</p> Example <p>Solo Mode Usage</p> <pre><code>async with Endpoint('ep1', uuid.uuid4()) as endpoint:\nserialized_data = b'data string'\nendpoint.set('key', serialized_data)\nassert endpoint.get('key') == serialized_data\nendpoint.evict('key')\nassert not endpoint.exists('key')\n</code></pre> Example <p>Peering Mode Usage</p> <pre><code>ep1 = await Endpoint('ep1', uuid.uuid4(), relay_server)\nep2 = await Endpoint('ep1', uuid.uuid4(), relay_server)\nserialized_data = b'data string'\nep1.set('key', serialized_data)\nassert ep2.get('key', endpoint=ep1.uuid) == serialized_data\nassert ep1.exists('key')\nassert not ep1.exists('key', endpoint=ep2.uuid)\nep1.close()\nep2.close()\n</code></pre> Note <p>Endpoints can be configured and started via the <code>proxystore-endpoint</code> command-line interface.</p> Note <p>If the endpoint is being used in peering mode, the endpoint should be used as a context manager or initialized with await. This will ensure <code>Endpoint.async_init()</code> is executed which connects to the relay server and established a listener for incoming messages.</p> <pre><code>endpoint = await Endpoint(...)\nendpoint.close()\n</code></pre> <pre><code>async with Endpoint(...) as endpoint:\n...\n</code></pre> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Readable name of endpoint.</p> </li> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of the endpoint.</p> </li> <li> relay_server             (<code>str | None</code>)         \u2013 <p>Address of relay server used for peer-to-peer connections between endpoints. If None, endpoint will not be able to communicate with other endpoints.</p> </li> <li> max_object_size             (<code>int | None</code>)         \u2013 <p>Optional max size in bytes for any single object stored by the endpoint. If exceeded, an error is raised.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>Number of datachannels per peer connection to another endpoint to communicate over.</p> </li> <li> peer_timeout             (<code>int</code>)         \u2013 <p>Timeout for establishing p2p connection with another endpoint.</p> </li> <li> storage             (<code>Storage | None</code>)         \u2013 <p>Storage interface to use. If <code>None</code>, <code>DictStorage</code> is used.</p> </li> <li> verify_certificate             (<code>bool</code>)         \u2013 <p>Verify the relay server's SSL certificate. This should almost never be disabled except for testing with self-signed certificates.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>def __init__(\nself,\nname: str,\nuuid: UUID,\nrelay_server: str | None = None,\n*,\nmax_object_size: int | None = MAX_OBJECT_SIZE_DEFAULT,\npeer_channels: int = 1,\npeer_timeout: int = 30,\nstorage: Storage | None = None,\nverify_certificate: bool = True,\n) -&gt; None:\nself._name = name\nself._uuid = uuid\nself._relay_server = relay_server\nself._max_object_size = max_object_size\nself._peer_channels = peer_channels\nself._peer_timeout = peer_timeout\nself._verify_certificate = verify_certificate\nself._storage = DictStorage() if storage is None else storage\nself._mode = (\nEndpointMode.SOLO if relay_server is None else EndpointMode.PEERING\n)\nself._peer_manager: PeerManager | None = None\nself._pending_requests: dict[\nstr,\nasyncio.Future[EndpointRequest],\n] = {}\nself._async_init_done = False\nself._peer_handler_task: asyncio.Task[None] | None = None\nlogger.info(\nf'{self._log_prefix}: initialized endpoint operating '\nf'in {self._mode.name} mode',\n)\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: UUID\n</code></pre> <p>UUID of this endpoint.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of this endpoint.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.async_init","title":"async_init()  <code>async</code>","text":"<pre><code>async_init() -&gt; None\n</code></pre> <p>Initialize connections and tasks necessary for peering.</p> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def async_init(self) -&gt; None:\n\"\"\"Initialize connections and tasks necessary for peering.\"\"\"\nif self._relay_server is not None and not self._async_init_done:\nself._peer_manager = await PeerManager(\nuuid=self.uuid,\nrelay_server=self._relay_server,\nname=self.name,\ntimeout=self._peer_timeout,\npeer_channels=self._peer_channels,\nverify_certificate=self._verify_certificate,\n)\nself._peer_handler_task = spawn_guarded_background_task(\nself._handle_peer_requests,\n)\nlogger.info(f'{self._log_prefix}: initialized peer manager')\nself._async_init_done = True\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.evict","title":"evict()  <code>async</code>","text":"<pre><code>evict(key: str, endpoint: UUID | None = None) -&gt; None\n</code></pre> <p>Evict key from endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to evict.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def evict(self, key: str, endpoint: UUID | None = None) -&gt; None:\n\"\"\"Evict key from endpoint.\n    Args:\n        key: Key to evict.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Raises:\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: EVICT key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='evict',\nuuid=str(uuid4()),\nkey=key,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nawait request_future\nelse:\nawait self._storage.evict(key)\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.exists","title":"exists()  <code>async</code>","text":"<pre><code>exists(key: str, endpoint: UUID | None = None) -&gt; bool\n</code></pre> <p>Check if key exists on endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to check.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the key exists.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def exists(self, key: str, endpoint: UUID | None = None) -&gt; bool:\n\"\"\"Check if key exists on endpoint.\n    Args:\n        key: Key to check.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Returns:\n        If the key exists.\n    Raises:\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: EXISTS key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='exists',\nuuid=str(uuid4()),\nkey=key,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nresponse = await request_future\nassert isinstance(response.exists, bool)\nreturn response.exists\nelse:\nreturn await self._storage.exists(key)\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.get","title":"get()  <code>async</code>","text":"<pre><code>get(key: str, endpoint: UUID | None = None) -&gt; bytes | None\n</code></pre> <p>Get value associated with key on endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to get value for.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Value associated with key.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def get(\nself,\nkey: str,\nendpoint: UUID | None = None,\n) -&gt; bytes | None:\n\"\"\"Get value associated with key on endpoint.\n    Args:\n        key: Key to get value for.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Returns:\n        Value associated with key.\n    Raises:\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: GET key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='get',\nuuid=str(uuid4()),\nkey=key,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nresponse = await request_future\nreturn response.data\nelse:\nreturn await self._storage.get(key, None)\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.set","title":"set()  <code>async</code>","text":"<pre><code>set(\nkey: str, data: bytes, endpoint: UUID | None = None\n) -&gt; None\n</code></pre> <p>Set key with data on endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to associate with value.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Value to associate with key.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ObjectSizeExceededError</code>           \u2013         <p>If the max object size is configured and the data exceeds that size.</p> </li> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def set(\nself,\nkey: str,\ndata: bytes,\nendpoint: UUID | None = None,\n) -&gt; None:\n\"\"\"Set key with data on endpoint.\n    Args:\n        key: Key to associate with value.\n        data: Value to associate with key.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Raises:\n        ObjectSizeExceededError: If the max object size is configured and\n            the data exceeds that size.\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: SET key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='set',\nuuid=str(uuid4()),\nkey=key,\ndata=data,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nawait request_future\nelif (\nself._max_object_size is not None\nand len(data) &gt; self._max_object_size\n):\nraise ObjectSizeExceededError(\nf'Bytes value has size {bytes_to_readable(len(data))} which '\nf'exceeds the {bytes_to_readable(self._max_object_size)} '\n'object limit.',\n)\nelse:\nawait self._storage.set(key, data)\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.close","title":"close()  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the endpoint and any open connections safely.</p> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the endpoint and any open connections safely.\"\"\"\nif self._peer_handler_task is not None:\nself._peer_handler_task.cancel()\ntry:\nawait self._peer_handler_task\nexcept asyncio.CancelledError:\npass\nif self._peer_manager is not None:\nawait self._peer_manager.close()\nawait self._storage.close()\nlogger.info(f'{self._log_prefix}: endpoint closed')\n</code></pre>"},{"location":"api/endpoint/exceptions/","title":"proxystore.endpoint.exceptions","text":"<code>proxystore/endpoint/exceptions.py</code> <p>Endpoint exceptions.</p>"},{"location":"api/endpoint/exceptions/#proxystore.endpoint.exceptions.FileDumpNotAvailableError","title":"FileDumpNotAvailableError","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when dumping objects to file is not available.</p>"},{"location":"api/endpoint/exceptions/#proxystore.endpoint.exceptions.ObjectSizeExceededError","title":"ObjectSizeExceededError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when an object exceeds the max allowable size.</p>"},{"location":"api/endpoint/exceptions/#proxystore.endpoint.exceptions.PeeringNotAvailableError","title":"PeeringNotAvailableError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception when a peer request is made but peering is not available.</p>"},{"location":"api/endpoint/exceptions/#proxystore.endpoint.exceptions.PeerRequestError","title":"PeerRequestError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when a request to a peer fails.</p>"},{"location":"api/endpoint/messages/","title":"proxystore.endpoint.messages","text":"<code>proxystore/endpoint/messages.py</code> <p>Endpoint to endpoint messages.</p>"},{"location":"api/endpoint/messages/#proxystore.endpoint.messages.EndpointRequest","title":"EndpointRequest  <code>dataclass</code>","text":"<p>Message type for requests between endpoints.</p> <p>Attributes:</p> <ul> <li> kind             (<code>Literal['request', 'response']</code>)         \u2013 <p>One of <code>'request'</code> or <code>'response'</code>.</p> </li> <li> op             (<code>Literal['evict', 'exists', 'get', 'set']</code>)         \u2013 <p>One of <code>'evict'</code>, <code>'exists'</code>, <code>'get'</code>, or <code>'set'</code>.</p> </li> <li> uuid             (<code>str</code>)         \u2013 <p>UUID of sender.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key to operate on.</p> </li> <li> data             (<code>bytes | None</code>)         \u2013 <p>Optional data to operate on.</p> </li> <li> exists             (<code>bool | None</code>)         \u2013 <p>Result of <code>exists</code> operation.</p> </li> <li> error             (<code>Exception | None</code>)         \u2013 <p>Error raised by operation.</p> </li> </ul>"},{"location":"api/endpoint/serve/","title":"proxystore.endpoint.serve","text":"<code>proxystore/endpoint/serve.py</code> <p>Endpoint serving.</p>"},{"location":"api/endpoint/serve/#proxystore.endpoint.serve.create_app","title":"create_app()","text":"<pre><code>create_app(\nendpoint: Endpoint,\nmax_content_length: int | None = None,\nbody_timeout: int = 300,\n) -&gt; quart.Quart\n</code></pre> <p>Create quart app for endpoint and registers routes.</p> <p>Parameters:</p> <ul> <li> endpoint             (<code>Endpoint</code>)         \u2013 <p>Initialized endpoint to forward quart routes to.</p> </li> <li> max_content_length             (<code>int | None</code>)         \u2013 <p>Max request body size in bytes.</p> </li> <li> body_timeout             (<code>int</code>)         \u2013 <p>Number of seconds to wait for the body to be completely received.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>quart.Quart</code>         \u2013 <p>Quart app.</p> </li> </ul> Source code in <code>proxystore/endpoint/serve.py</code> <pre><code>def create_app(\nendpoint: Endpoint,\nmax_content_length: int | None = None,\nbody_timeout: int = 300,\n) -&gt; quart.Quart:\n\"\"\"Create quart app for endpoint and registers routes.\n    Args:\n        endpoint: Initialized endpoint to forward quart routes to.\n        max_content_length: Max request body size in bytes.\n        body_timeout: Number of seconds to wait for the body to be\n            completely received.\n    Returns:\n        Quart app.\n    \"\"\"\napp = quart.Quart(__name__)\napp.config['endpoint'] = endpoint\napp.register_blueprint(routes_blueprint, url_prefix='')\nlogger.info(\n'Quart routes registered to endpoint '\nf'{endpoint.uuid} ({endpoint.name})',\n)\napp.config['MAX_CONTENT_LENGTH'] = max_content_length\napp.config['BODY_TIMEOUT'] = body_timeout\nreturn app\n</code></pre>"},{"location":"api/endpoint/serve/#proxystore.endpoint.serve.serve","title":"serve()","text":"<pre><code>serve(\nconfig: EndpointConfig,\n*,\nlog_level: int | str = logging.INFO,\nlog_file: str | None = None,\nuse_uvloop: bool = True\n) -&gt; None\n</code></pre> <p>Initialize endpoint and serve Quart app.</p> Warning <p>This function does not return until the Quart app is terminated.</p> <p>Parameters:</p> <ul> <li> config             (<code>EndpointConfig</code>)         \u2013 <p>Configuration object.</p> </li> <li> log_level             (<code>int | str</code>)         \u2013 <p>Logging level of endpoint.</p> </li> <li> log_file             (<code>str | None</code>)         \u2013 <p>Optional file path to append log to.</p> </li> <li> use_uvloop             (<code>bool</code>)         \u2013 <p>Install uvloop as the default event loop implementation.</p> </li> </ul> Source code in <code>proxystore/endpoint/serve.py</code> <pre><code>def serve(\nconfig: EndpointConfig,\n*,\nlog_level: int | str = logging.INFO,\nlog_file: str | None = None,\nuse_uvloop: bool = True,\n) -&gt; None:\n\"\"\"Initialize endpoint and serve Quart app.\n    Warning:\n        This function does not return until the Quart app is terminated.\n    Args:\n        config: Configuration object.\n        log_level: Logging level of endpoint.\n        log_file: Optional file path to append log to.\n        use_uvloop: Install uvloop as the default event loop implementation.\n    \"\"\"\nif config.host is None:\nraise ValueError('EndpointConfig has NoneType as host.')\nif log_file is not None:\nparent_dir = os.path.dirname(log_file)\nif not os.path.isdir(parent_dir):\nos.makedirs(parent_dir, exist_ok=True)\nlogging.getLogger().handlers.append(logging.FileHandler(log_file))\nfor handler in logging.getLogger().handlers:\nhandler.setFormatter(\nlogging.Formatter(\n'[%(asctime)s.%(msecs)03d] %(levelname)-5s (%(name)s) :: '\n'%(message)s',\ndatefmt='%Y-%m-%d %H:%M:%S',\n),\n)\nlogging.getLogger().setLevel(log_level)\nkwargs = dataclasses.asdict(config)\n# These are the only two EndpointConfig attributes not passed to the\n# Endpoint constructor\nkwargs.pop('host', None)\nkwargs.pop('port', None)\ndatabase_path = kwargs.pop('database_path', None)\nstorage: SQLiteStorage | None\nif database_path is not None:\nlogger.info(\nf'Using SQLite database for storage (path: {database_path})',\n)\nstorage = SQLiteStorage(database_path)\nelse:\nlogger.warning(\n'Database path not provided. Data will not be persisted',\n)\nstorage = None\nendpoint = Endpoint(**kwargs, storage=storage)\napp = create_app(endpoint)\nif use_uvloop:  # pragma: no cover\nlogger.info('Installing uvloop as default event loop')\nuvloop.install()\nelse:\nlogger.warning(\n'Not installing uvloop. Uvicorn may override and install anyways',\n)\nserver_config = uvicorn.Config(\napp,\nhost=config.host,\nport=config.port,\nlog_config=None,\nlog_level=logger.level,\naccess_log=False,\n)\nserver = uvicorn.Server(server_config)\nlogger.info(\nf'Serving endpoint {endpoint.uuid} ({endpoint.name}) on '\nf'{config.host}:{config.port}',\n)\nlogger.info(f'Config: {config}')\nasyncio.run(server.serve())\n</code></pre>"},{"location":"api/endpoint/storage/","title":"proxystore.endpoint.storage","text":"<code>proxystore/endpoint/storage.py</code> <p>Blob storage interface for endpoints.</p>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Storage","title":"Storage","text":"<p>         Bases: <code>Protocol</code></p> <p>Endpoint storage protocol for blobs.</p>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Storage.evict","title":"evict()  <code>async</code>","text":"<pre><code>evict(key: str) -&gt; None\n</code></pre> <p>Evict a blob from storage.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with blob to evict.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def evict(self, key: str) -&gt; None:\n\"\"\"Evict a blob from storage.\n    Args:\n        key: Key associated with blob to evict.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Storage.exists","title":"exists()  <code>async</code>","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if a blob exists in the storage.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with the blob to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If a blob associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def exists(self, key: str) -&gt; bool:\n\"\"\"Check if a blob exists in the storage.\n    Args:\n        key: Key associated with the blob to check.\n    Returns:\n        If a blob associated with the key exists.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Storage.get","title":"get()  <code>async</code>","text":"<pre><code>get(key: str, default: bytes | None = None) -&gt; bytes | None\n</code></pre> <p>Get a blob from storage.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with the blob to get.</p> </li> <li> default             (<code>bytes | None</code>)         \u2013 <p>Default return value if the blob does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>The blob associated with the key or the value of <code>default</code>.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def get(\nself,\nkey: str,\ndefault: bytes | None = None,\n) -&gt; bytes | None:\n\"\"\"Get a blob from storage.\n    Args:\n        key: Key associated with the blob to get.\n        default: Default return value if the blob does not exist.\n    Returns:\n        The blob associated with the key or the value of `default`.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Storage.set","title":"set()  <code>async</code>","text":"<pre><code>set(key: str, blob: bytes) -&gt; None\n</code></pre> <p>Store the blob associated with a key.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key that will be used to retrieve the blob.</p> </li> <li> blob             (<code>bytes</code>)         \u2013 <p>Blob to store.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def set(self, key: str, blob: bytes) -&gt; None:\n\"\"\"Store the blob associated with a key.\n    Args:\n        key: Key that will be used to retrieve the blob.\n        blob: Blob to store.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Storage.close","title":"close()  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the storage.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the storage.\"\"\"\n...\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.DictStorage","title":"DictStorage","text":"<pre><code>DictStorage() -&gt; None\n</code></pre> <p>Simple dictionary-based storage for blobs.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __init__(self) -&gt; None:\nself._data: dict[str, bytes] = {}\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.DictStorage.evict","title":"evict()  <code>async</code>","text":"<pre><code>evict(key: str) -&gt; None\n</code></pre> <p>Evict a blob from storage.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with blob to evict.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def evict(self, key: str) -&gt; None:\n\"\"\"Evict a blob from storage.\n    Args:\n        key: Key associated with blob to evict.\n    \"\"\"\nself._data.pop(key, None)\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.DictStorage.exists","title":"exists()  <code>async</code>","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if a blob exists in the storage.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with the blob to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If a blob associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def exists(self, key: str) -&gt; bool:\n\"\"\"Check if a blob exists in the storage.\n    Args:\n        key: Key associated with the blob to check.\n    Returns:\n        If a blob associated with the key exists.\n    \"\"\"\nreturn key in self._data\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.DictStorage.get","title":"get()  <code>async</code>","text":"<pre><code>get(key: str, default: bytes | None = None) -&gt; bytes | None\n</code></pre> <p>Get a blob from storage.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with the blob to get.</p> </li> <li> default             (<code>bytes | None</code>)         \u2013 <p>Default return value if the blob does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>The blob associated with the key or the value of <code>default</code>.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def get(\nself,\nkey: str,\ndefault: bytes | None = None,\n) -&gt; bytes | None:\n\"\"\"Get a blob from storage.\n    Args:\n        key: Key associated with the blob to get.\n        default: Default return value if the blob does not exist.\n    Returns:\n        The blob associated with the key or the value of `default`.\n    \"\"\"\nreturn self._data.get(key, default)\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.DictStorage.set","title":"set()  <code>async</code>","text":"<pre><code>set(key: str, blob: bytes) -&gt; None\n</code></pre> <p>Store the blob associated with a key.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key that will be used to retrieve the blob.</p> </li> <li> blob             (<code>bytes</code>)         \u2013 <p>Blob to store.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def set(self, key: str, blob: bytes) -&gt; None:\n\"\"\"Store the blob associated with a key.\n    Args:\n        key: Key that will be used to retrieve the blob.\n        blob: Blob to store.\n    \"\"\"\nself._data[key] = blob\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.DictStorage.close","title":"close()  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Clear all stored blobs.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Clear all stored blobs.\"\"\"\nself._data.clear()\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.SQLiteStorage","title":"SQLiteStorage","text":"<pre><code>SQLiteStorage(\ndatabase_path: str | pathlib.Path = \":memory:\",\n) -&gt; None\n</code></pre> <p>SQLite storage protocol for blobs.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __init__(self, database_path: str | pathlib.Path = ':memory:') -&gt; None:\nif database_path == ':memory:':\nself.database_path = database_path\nelse:\npath = pathlib.Path(database_path).expanduser().resolve()\nself.database_path = str(path)\nself._db: aiosqlite.Connection | None = None\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.SQLiteStorage.db","title":"db()  <code>async</code>","text":"<pre><code>db() -&gt; aiosqlite.Connection\n</code></pre> <p>Get the database connection object.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def db(self) -&gt; aiosqlite.Connection:\n\"\"\"Get the database connection object.\"\"\"\nif self._db is None:\nself._db = await aiosqlite.connect(self.database_path)\nawait self._db.execute(\n'CREATE TABLE IF NOT EXISTS blobs'\n'(key TEXT PRIMARY KEY, value BLOB NOT NULL)',\n)\nreturn self._db\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.SQLiteStorage.evict","title":"evict()  <code>async</code>","text":"<pre><code>evict(key: str) -&gt; None\n</code></pre> <p>Evict a blob from storage.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with blob to evict.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def evict(self, key: str) -&gt; None:\n\"\"\"Evict a blob from storage.\n    Args:\n        key: Key associated with blob to evict.\n    \"\"\"\ndb = await self.db()\nawait db.execute('DELETE FROM blobs WHERE key=?', (key,))\nawait db.commit()\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.SQLiteStorage.exists","title":"exists()  <code>async</code>","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if a blob exists in the storage.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with the blob to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If a blob associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def exists(self, key: str) -&gt; bool:\n\"\"\"Check if a blob exists in the storage.\n    Args:\n        key: Key associated with the blob to check.\n    Returns:\n        If a blob associated with the key exists.\n    \"\"\"\ndb = await self.db()\nasync with db.execute(\n'SELECT count(*) FROM blobs WHERE key=?',\n(key,),\n) as cursor:\n(count,) = await cursor.fetchone()\nreturn bool(count)\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.SQLiteStorage.get","title":"get()  <code>async</code>","text":"<pre><code>get(key: str, default: bytes | None = None) -&gt; bytes | None\n</code></pre> <p>Get a blob from storage.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with the blob to get.</p> </li> <li> default             (<code>bytes | None</code>)         \u2013 <p>Default return value if the blob does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>The blob associated with the key or the value of <code>default</code>.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def get(\nself,\nkey: str,\ndefault: bytes | None = None,\n) -&gt; bytes | None:\n\"\"\"Get a blob from storage.\n    Args:\n        key: Key associated with the blob to get.\n        default: Default return value if the blob does not exist.\n    Returns:\n        The blob associated with the key or the value of `default`.\n    \"\"\"\ndb = await self.db()\nasync with db.execute(\n'SELECT value FROM blobs WHERE key=?',\n(key,),\n) as cursor:\nresult = await cursor.fetchone()\nif result is None:\nreturn default\nelse:\nreturn result[0]\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.SQLiteStorage.set","title":"set()  <code>async</code>","text":"<pre><code>set(key: str, blob: bytes) -&gt; None\n</code></pre> <p>Store the blob associated with a key.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key that will be used to retrieve the blob.</p> </li> <li> blob             (<code>bytes</code>)         \u2013 <p>Blob to store.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def set(self, key: str, blob: bytes) -&gt; None:\n\"\"\"Store the blob associated with a key.\n    Args:\n        key: Key that will be used to retrieve the blob.\n        blob: Blob to store.\n    \"\"\"\ndb = await self.db()\nawait db.execute(\n'INSERT OR REPLACE INTO blobs (key, value) VALUES (?, ?)',\n(key, blob),\n)\nawait db.commit()\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.SQLiteStorage.close","title":"close()  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the storage.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the storage.\"\"\"\nif self._db is not None:\nawait self._db.close()\n</code></pre>"},{"location":"api/p2p/","title":"proxystore.p2p","text":"<code>proxystore/p2p/__init__.py</code> <p>Peer-to-peer communication and relaying.</p> <p>This module provides two main functionalities: the <code>PeerManager</code> and <code>RelayServer</code>.</p> <ul> <li>The <code>PeerManager</code> enables   easy communication between arbitrary peers even if peers are behind separate   NATs. Peer connections are established using   aiortc, an asyncio WebRTC   implementation.</li> <li>The <code>RelayServer</code> is a   commonly accessible server by peers that is used to facilitate WebRTC peer   connections.</li> </ul>"},{"location":"api/p2p/chunks/","title":"proxystore.p2p.chunks","text":"<code>proxystore/p2p/chunks.py</code> <p>Message chunking utilities.</p>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.ChunkDType","title":"ChunkDType","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Data type contained in a Chunk.</p>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.ChunkDType.BYTES","title":"BYTES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BYTES = 1\n</code></pre> <p>Data is bytes.</p>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.ChunkDType.STRING","title":"STRING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRING = 2\n</code></pre> <p>Data is a string.</p>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.Chunk","title":"Chunk","text":"<pre><code>Chunk(\nstream_id: int,\nseq_id: int,\nseq_len: int,\ndata: bytes | str,\ndtype: ChunkDType | None = None,\n) -&gt; None\n</code></pre> <p>Representation of a chunk of a message.</p> <p>Parameters:</p> <ul> <li> stream_id             (<code>int</code>)         \u2013 <p>Unique ID for the stream of chunks.</p> </li> <li> seq_id             (<code>int</code>)         \u2013 <p>Sequence number for this chunk in the stream.</p> </li> <li> seq_len             (<code>int</code>)         \u2013 <p>Length of the stream.</p> </li> <li> data             (<code>bytes | str</code>)         \u2013 <p>Data for this chunk.</p> </li> <li> dtype             (<code>ChunkDType | None</code>)         \u2013 <p>Optionally specify data type otherwise inferred from data.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>if the sequence ID is not less than the sequence length.</p> </li> </ul> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def __init__(\nself,\nstream_id: int,\nseq_id: int,\nseq_len: int,\ndata: bytes | str,\ndtype: ChunkDType | None = None,\n) -&gt; None:\nif seq_len &lt;= seq_id:\nraise ValueError(\nf'seq_id ({seq_id}) must be less than seq_len ({seq_len}).',\n)\nself.stream_id = stream_id\nself.seq_id = seq_id\nself.seq_len = seq_len\nself.data = data\nif dtype is None:\nself.dtype = (\nChunkDType.BYTES\nif isinstance(data, bytes)\nelse ChunkDType.STRING\n)\nelse:\nself.dtype = dtype\n</code></pre>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.Chunk.__bytes__","title":"__bytes__()","text":"<pre><code>__bytes__() -&gt; bytes\n</code></pre> <p>Pack the chunk into bytes.</p> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def __bytes__(self) -&gt; bytes:\n\"\"\"Pack the chunk into bytes.\"\"\"\nlength = CHUNK_HEADER_LENGTH + len(self.data)\nheader = pack(\nCHUNK_HEADER_FORMAT,\nself.dtype.value,\nlength,\nself.stream_id,\nself.seq_id,\nself.seq_len,\n)\ndata = (\nself.data.encode('utf8')\nif isinstance(self.data, str)\nelse self.data\n)\nchunk = header + data\ndata += b'\\x00' * (len(chunk) % 4)\nreturn chunk\n</code></pre>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.Chunk.from_bytes","title":"from_bytes()  <code>classmethod</code>","text":"<pre><code>from_bytes(chunk: bytes) -&gt; Chunk\n</code></pre> <p>Decode bytes into a Chunk.</p> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>@classmethod\ndef from_bytes(cls, chunk: bytes) -&gt; Chunk:\n\"\"\"Decode bytes into a Chunk.\"\"\"\n(dtype_value, length, stream_id, seq_id, seq_len) = unpack_from(\nCHUNK_HEADER_FORMAT,\nchunk,\n)\ndtype = ChunkDType(dtype_value)\nchunk_data = chunk[CHUNK_HEADER_LENGTH:length]\ndata: bytes | str\nif dtype is ChunkDType.STRING:\ndata = chunk_data.decode('utf8')\nelse:\ndata = chunk_data\nreturn cls(\nstream_id=stream_id,\nseq_id=seq_id,\nseq_len=seq_len,\ndata=data,\ndtype=dtype,\n)\n</code></pre>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.chunkify","title":"chunkify()","text":"<pre><code>chunkify(\ndata: bytes | str, size: int, stream_id: int\n) -&gt; Generator[Chunk, None, None]\n</code></pre> <p>Generate chunks from data.</p> <p>Parameters:</p> <ul> <li> data             (<code>bytes | str</code>)         \u2013 <p>Data to chunk.</p> </li> <li> size             (<code>int</code>)         \u2013 <p>Size of each chunk.</p> </li> <li> stream_id             (<code>int</code>)         \u2013 <p>Unique ID for the stream of chunks.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Generator[Chunk, None, None]</code>         \u2013 <p>Chunks of data.</p> </li> </ul> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def chunkify(\ndata: bytes | str,\nsize: int,\nstream_id: int,\n) -&gt; Generator[Chunk, None, None]:\n\"\"\"Generate chunks from data.\n    Args:\n        data: Data to chunk.\n        size: Size of each chunk.\n        stream_id: Unique ID for the stream of chunks.\n    Yields:\n        Chunks of data.\n    \"\"\"\nseq_len = math.ceil(len(data) / size)\nfor i, x in enumerate(range(0, len(data), size)):\nchunk_data = data[x : min(x + size, len(data))]\nyield Chunk(\nstream_id=stream_id,\nseq_id=i,\nseq_len=seq_len,\ndata=chunk_data,\n)\n</code></pre>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.reconstruct","title":"reconstruct()","text":"<pre><code>reconstruct(chunks: list[Chunk]) -&gt; bytes | str\n</code></pre> <p>Reconstructs data from list of chunks.</p> <p>Parameters:</p> <ul> <li> chunks             (<code>list[Chunk]</code>)         \u2013 <p>List of chunks to order and join.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | str</code>         \u2013 <p>Reconstructed bytes or string.</p> </li> </ul> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def reconstruct(chunks: list[Chunk]) -&gt; bytes | str:\n\"\"\"Reconstructs data from list of chunks.\n    Args:\n        chunks: List of chunks to order and join.\n    Returns:\n        Reconstructed bytes or string.\n    \"\"\"\nif len(chunks) == 0:\nraise ValueError('Chunks list cannot be empty.')\nseq_len = chunks[0].seq_len\nif len(chunks) != seq_len:\nraise ValueError(f'Got {len(chunks)} but expected {seq_len}.')\nchunks = sorted(chunks, key=lambda c: c.seq_id)\nif isinstance(chunks[0].data, bytes):\nreturn b''.join(c.data for c in chunks)  # type: ignore\nelif isinstance(chunks[0].data, str):\nreturn ''.join(c.data for c in chunks)  # type: ignore\nelse:\nraise AssertionError('Unreachable.')\n</code></pre>"},{"location":"api/p2p/connection/","title":"proxystore.p2p.connection","text":"<code>proxystore/p2p/connection.py</code> <p>Representation of peer-to-peer connection.</p>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection","title":"PeerConnection","text":"<pre><code>PeerConnection(\nrelay_client: RelayServerClient, *, channels: int = 1\n) -&gt; None\n</code></pre> <p>Peer-to-peer connection.</p> <p>Interface for establishing a peer-to-peer connection via WebRTC aiortc and sending/receiving messages between the two peers. The peer-to-peer connection is established using a central and publicly accessible relay server.</p> Warning <p>Applications should prefer using the <code>PeerManager</code> rather than using the <code>PeerConnection</code> class.</p> Example <pre><code>from proxystore.p2p.connection import PeerConnection\nfrom proxystore.p2p.relay_client import RelayServerClient\nclient1 = RelayServerClient(relay_server_address)\nawait client1.connect()\nconnection1 = PeerConnection(client1)\nclient2 = RelayServerClient(relay_server_address)\nawait client2.connect()\nconnection2 = PeerConnection(client2)\nawait connection1.send_offer(client2.uuid)\noffer = await client2.recv()\nawait connection2.handle_server_message(offer)\nanswer = await client1.recv()\nawait connection1.handle_server_message(answer)\nawait connection1.ready()\nawait connection2.ready()\nawait connection1.send('hello')\nassert await connection2.recv() == 'hello'\nawait connection2.send('hello hello')\nassert await connection1.recv() == 'hello hello'\nawait client1.close()\nawait client2.close()\nawait connection1.close()\nawait connection2.close()\n</code></pre> <p>Parameters:</p> <ul> <li> relay_client             (<code>RelayServerClient</code>)         \u2013 <p>Client connection to the relay server.</p> </li> <li> channels             (<code>int</code>)         \u2013 <p>Number of datachannels to open with peer.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>def __init__(\nself,\nrelay_client: RelayServerClient,\n*,\nchannels: int = 1,\n) -&gt; None:\nself._uuid = relay_client.uuid\nself._name = relay_client.name\nself._relay_client = relay_client\nself._max_channels = channels\nself._handshake_success: asyncio.Future[\nbool\n] = asyncio.get_running_loop().create_future()\nself._pc = RTCPeerConnection()\nself._incoming_queue: asyncio.Queue[bytes | str] = asyncio.Queue()\nself._incoming_chunks: dict[int, list[Chunk]] = defaultdict(list)\n# Max size of unsigned long (4 bytes) is 2^32 - 1\nself._message_counter = AtomicCounter(size=2**32 - 1)\n# Used by offerer to count how many of the channels it opened are ready\nself._ready = 0\nself._channels: dict[str, RTCDataChannel] = {}\nself._channel_buffer_low: dict[str, asyncio.Event] = {}\nself._peer_uuid: UUID | None = None\nself._peer_name: str | None = None\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.state","title":"state  <code>property</code>","text":"<pre><code>state: str\n</code></pre> <p>Get the current connection state.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>One of 'connected', 'connecting', 'closed', 'failed', or 'new'.</p> </li> </ul>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.close","title":"close()  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Terminate the peer connection.</p> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Terminate the peer connection.\"\"\"\nlogger.info(f'{self._log_prefix}: closing connection')\n# Flush send buffers before close\n# https://github.com/aiortc/aiortc/issues/547\nfor channel in self._channels.values():\ntransport = channel._RTCDataChannel__transport\nawait transport._data_channel_flush()\nawait transport._transmit()\nchannel.close()\nawait self._pc.close()\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.on_close_callback","title":"on_close_callback()","text":"<pre><code>on_close_callback(\ncallback: Callable[..., Awaitable[None]],\n*args: Any,\n**kwargs: Any\n) -&gt; None\n</code></pre> <p>Configure a callback for when the connection fails or closes.</p> <p>Parameters:</p> <ul> <li> callback             (<code>Callable[..., Awaitable[None]]</code>)         \u2013 <p>Callable to invoke when the peer connection state changes to closed or failed.</p> </li> <li> args             (<code>Any</code>)         \u2013 <p>Positional arguments to pass to the callback.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Keyword arguments to pass to the callback.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>def on_close_callback(\nself,\ncallback: Callable[..., Awaitable[None]],\n*args: Any,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Configure a callback for when the connection fails or closes.\n    Args:\n        callback: Callable to invoke when the peer connection state\n            changes to closed or failed.\n        args: Positional arguments to pass to the callback.\n        kwargs: Keyword arguments to pass to the callback.\n    \"\"\"\nasync def _on_close() -&gt; None:\nif self.state in ('closed', 'failed'):\nlogger.info(\nf'{self._log_prefix}: connection entered {self.state} '\n'state, invoking callback',\n)\nawait callback(*args, **kwargs)\nself._pc.on('connectionstatechange', _on_close)\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.send","title":"send()  <code>async</code>","text":"<pre><code>send(message: bytes | str, timeout: float = 30) -&gt; None\n</code></pre> <p>Send message to peer.</p> <p>Parameters:</p> <ul> <li> message             (<code>bytes | str</code>)         \u2013 <p>Message to send to peer.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Timeout to wait on peer connection to be ready.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerConnectionTimeoutError</code>           \u2013         <p>If the peer connection is not established within the timeout.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def send(self, message: bytes | str, timeout: float = 30) -&gt; None:\n\"\"\"Send message to peer.\n    Args:\n        message: Message to send to peer.\n        timeout: Timeout to wait on peer connection to be ready.\n    Raises:\n        PeerConnectionTimeoutError: If the peer connection is not\n            established within the timeout.\n    \"\"\"\nawait self.ready(timeout)\nchunk_size = (\nMAX_CHUNK_SIZE_STRING\nif isinstance(message, str)\nelse MAX_CHUNK_SIZE_BYTES\n)\nmessage_id = self._message_counter.increment()\nchannel_names = list(self._channels.keys())\nfor i, chunk in enumerate(chunkify(message, chunk_size, message_id)):\nchannel_name = channel_names[i % len(channel_names)]\nchannel = self._channels[channel_name]\nbuffer_low = self._channel_buffer_low[channel_name]\nif channel.bufferedAmount &gt; channel.bufferedAmountLowThreshold:\nawait buffer_low.wait()\nbuffer_low.clear()\nchannel.send(bytes(chunk))\nlogger.debug(f'{self._log_prefix}: sending message to peer')\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.recv","title":"recv()  <code>async</code>","text":"<pre><code>recv() -&gt; bytes | str\n</code></pre> <p>Receive next message from peer.</p> <p>Returns:</p> <ul> <li> <code>bytes | str</code>         \u2013 <p>Message received from peer.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def recv(self) -&gt; bytes | str:\n\"\"\"Receive next message from peer.\n    Returns:\n        Message received from peer.\n    \"\"\"\nreturn await self._incoming_queue.get()\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.send_offer","title":"send_offer()  <code>async</code>","text":"<pre><code>send_offer(peer_uuid: UUID) -&gt; None\n</code></pre> <p>Send offer for peering via relay server.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer client to establish connection with.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def send_offer(self, peer_uuid: UUID) -&gt; None:\n\"\"\"Send offer for peering via relay server.\n    Args:\n        peer_uuid: UUID of peer client to establish connection with.\n    \"\"\"\ndef _on_close(label: str) -&gt; Any:\n# We use this factory method to avoid Flake8-BugBear B023\nasync def on_close() -&gt; None:\nif self._channels[label].readyState in ('closed', 'failed'):\nawait self.close()\nreturn on_close\nfor i in range(self._max_channels):\nlabel = f'p2p-{i}-{self._max_channels}'\nchannel = self._pc.createDataChannel(label, ordered=False)\nbuffer_low = asyncio.Event()\nchannel.on('open', self._on_datachannel_open)\nchannel.on('bufferedamountlow', buffer_low.set)\nchannel.on('message', self._on_message)\nself._channels[label] = channel\nself._channel_buffer_low[label] = buffer_low\n# We use the underlying RTCDtlsTransport as the channel status.\nchannel.transport.transport.on('statechange', _on_close(label))\nawait self._pc.setLocalDescription(await self._pc.createOffer())\nmessage = messages.PeerConnection(\nsource_uuid=self._uuid,\nsource_name=self._name,\npeer_uuid=peer_uuid,\ndescription_type='offer',\ndescription=object_to_string(self._pc.localDescription),\n)\nlogger.info(f'{self._log_prefix}: sending offer to {peer_uuid}')\nawait self._relay_client.send(message)\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.send_answer","title":"send_answer()  <code>async</code>","text":"<pre><code>send_answer(peer_uuid: UUID) -&gt; None\n</code></pre> <p>Send answer to peering request via relay server.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer client that sent the initial offer.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def send_answer(self, peer_uuid: UUID) -&gt; None:\n\"\"\"Send answer to peering request via relay server.\n    Args:\n        peer_uuid: UUID of peer client that sent the initial offer.\n    \"\"\"\n@self._pc.on('datachannel')\ndef on_datachannel(channel: RTCDataChannel) -&gt; None:\nlogger.info(f'{self._log_prefix}: peer channel established')\n# TODO: note this is first channel opened\nmatch = re.search(r'(\\d+)-(\\d+)$', channel.label)\nif match is None:\nraise AssertionError(\nf'Got mislabled datachannel {channel.label}',\n)\ntotal = int(match.group(2))\nbuffer_low = asyncio.Event()\nself._channels[channel.label] = channel\nself._channel_buffer_low[channel.label] = buffer_low\nchannel.on('bufferedamountlow', buffer_low.set)\nchannel.on('message', self._on_message)\nasync def _on_close() -&gt; None:\nif channel.readyState in ('closed', 'failed'):\nawait self.close()\nelse:\npass  # pragma: no cover\n# We use the underlying RTCDtlsTransport as the channel status\nchannel.transport.transport.on('statechange', _on_close)\nif len(self._channels) &gt;= total:\nself._handshake_success.set_result(True)\nawait self._pc.setLocalDescription(await self._pc.createAnswer())\nmessage = messages.PeerConnection(\nsource_uuid=self._uuid,\nsource_name=self._name,\npeer_uuid=peer_uuid,\ndescription_type='answer',\ndescription=object_to_string(self._pc.localDescription),\n)\nlogger.info(f'{self._log_prefix}: sending answer to {peer_uuid}')\nawait self._relay_client.send(message)\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.handle_server_message","title":"handle_server_message()  <code>async</code>","text":"<pre><code>handle_server_message(\nmessage: messages.PeerConnection,\n) -&gt; None\n</code></pre> <p>Handle message from the relay server.</p> <p>Parameters:</p> <ul> <li> message             (<code>messages.PeerConnection</code>)         \u2013 <p>Message received from the relay server.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def handle_server_message(\nself,\nmessage: messages.PeerConnection,\n) -&gt; None:\n\"\"\"Handle message from the relay server.\n    Args:\n        message: Message received from the relay server.\n    \"\"\"\nif message.error is not None:\nself._handshake_success.set_exception(\nPeerConnectionError(\n'Received error message from relay server: '\nf'{message.error!s}',\n),\n)\nreturn\nif message.description_type == 'offer':\nlogger.info(\nf'{self._log_prefix}: received offer from '\nf'{message.source_uuid} ({message.source_name})',\n)\nobj = object_from_string(message.description)\nelif message.description_type == 'answer':\nlogger.info(\nf'{self._log_prefix}: received answer from '\nf'{message.source_uuid} ({message.source_name})',\n)\nobj = object_from_string(message.description)\nelse:\nraise AssertionError(\n'P2P connection message does not contain either an offer or '\n'an answer',\n)\nif isinstance(obj, RTCSessionDescription):\nawait self._pc.setRemoteDescription(obj)\nself._peer_uuid = message.source_uuid\nself._peer_name = message.source_name\nif obj.type == 'offer':\nawait self.send_answer(message.source_uuid)\nelif isinstance(obj, RTCIceCandidate):  # pragma: no cover\n# We should not receive an RTCIceCandidate message via the\n# relay server but this is here following the aiortc example.\n# https://github.com/aiortc/aiortc/blob/713fb644b95328f8ec1ac2cbb54def0424cc6645/examples/datachannel-cli/cli.py#L30  # noqa: E501\nawait self._pc.addIceCandidate(obj)\nelif obj is BYE:  # pragma: no cover\nraise AssertionError('received BYE message')\nelse:\nraise AssertionError('received unknown message')\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.ready","title":"ready()  <code>async</code>","text":"<pre><code>ready(timeout: float | None = None) -&gt; None\n</code></pre> <p>Wait for connection to be ready.</p> <p>Parameters:</p> <ul> <li> timeout             (<code>float | None</code>)         \u2013 <p>The maximum time in seconds to wait for the peer connection to establish. If None, block until the connection is established.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerConnectionTimeoutError</code>           \u2013         <p>If the connection is not ready within the timeout.</p> </li> <li> <code>PeerConnectionError</code>           \u2013         <p>If there is an error establishing the peer connection.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def ready(self, timeout: float | None = None) -&gt; None:\n\"\"\"Wait for connection to be ready.\n    Args:\n        timeout: The maximum time in seconds to wait for\n            the peer connection to establish. If None, block until\n            the connection is established.\n    Raises:\n        PeerConnectionTimeoutError: If the connection is not ready within\n            the timeout.\n        PeerConnectionError: If there is an error establishing the peer\n            connection.\n    \"\"\"\ntry:\nawait asyncio.wait_for(self._handshake_success, timeout)\nexcept asyncio.TimeoutError as e:\nraise PeerConnectionTimeoutError(\n'Timeout waiting for peer to peer connection to establish '\nf'in {self._log_prefix}.',\n) from e\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.log_name","title":"log_name()","text":"<pre><code>log_name(uuid: UUID, name: str) -&gt; str\n</code></pre> <p>Return string formatted as <code>'name(uuid-prefix)'</code>.</p> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>def log_name(uuid: UUID, name: str) -&gt; str:\n\"\"\"Return string formatted as `#!python 'name(uuid-prefix)'`.\"\"\"\nuuid_ = str(uuid)\nreturn f'{name}({uuid_[:min(8,len(uuid_))]})'\n</code></pre>"},{"location":"api/p2p/counter/","title":"proxystore.p2p.counter","text":"<code>proxystore/p2p/counter.py</code> <p>Atomic counting utilities.</p>"},{"location":"api/p2p/counter/#proxystore.p2p.counter.AtomicCounter","title":"AtomicCounter","text":"<pre><code>AtomicCounter(size: int | None = None) -&gt; None\n</code></pre> <p>Thread-safe counter.</p> <p>Parameters:</p> <ul> <li> size             (<code>int | None</code>)         \u2013 <p>Optional max count upon which an exception will be raised.</p> </li> </ul> Source code in <code>proxystore/p2p/counter.py</code> <pre><code>def __init__(self, size: int | None = None) -&gt; None:\nself._size = size\nself._value = 0\nself._lock = threading.Lock()\n</code></pre>"},{"location":"api/p2p/counter/#proxystore.p2p.counter.AtomicCounter.increment","title":"increment()","text":"<pre><code>increment() -&gt; int\n</code></pre> <p>Get current count and increment value.</p> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Current count.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If current count is equal to or greater than size.</p> </li> </ul> Source code in <code>proxystore/p2p/counter.py</code> <pre><code>def increment(self) -&gt; int:\n\"\"\"Get current count and increment value.\n    Returns:\n        Current count.\n    Raises:\n        ValueError: If current count is equal to or greater than size.\n    \"\"\"\nwith self._lock:\nvalue = self._value\nif self._size is not None and value &gt;= self._size:\nraise ValueError(f'Max counter size exceeded ({self._size}).')\nself._value += 1\nreturn value\n</code></pre>"},{"location":"api/p2p/exceptions/","title":"proxystore.p2p.exceptions","text":"<code>proxystore/p2p/exceptions.py</code> <p>Exception types for the relay server.</p>"},{"location":"api/p2p/exceptions/#proxystore.p2p.exceptions.PeerConnectionError","title":"PeerConnectionError","text":"<p>         Bases: <code>Exception</code></p> <p>Error connecting to peer.</p>"},{"location":"api/p2p/exceptions/#proxystore.p2p.exceptions.PeerConnectionTimeoutError","title":"PeerConnectionTimeoutError","text":"<p>         Bases: <code>PeerConnectionError</code></p> <p>Timeout waiting on peer to peer connection to establish.</p>"},{"location":"api/p2p/exceptions/#proxystore.p2p.exceptions.PeerRegistrationError","title":"PeerRegistrationError","text":"<p>         Bases: <code>Exception</code></p> <p>Error when establishing peer connection.</p>"},{"location":"api/p2p/manager/","title":"proxystore.p2p.manager","text":"<code>proxystore/p2p/manager.py</code> <p>Manager of many peer-to-peer connections.</p>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager","title":"PeerManager","text":"<pre><code>PeerManager(\nuuid: UUID,\nrelay_server: str,\nname: str | None = None,\n*,\ntimeout: int = 30,\npeer_channels: int = 1,\nverify_certificate: bool = True\n) -&gt; None\n</code></pre> <p>Peer Connections Manager.</p> <p>Handles establishing peer connections via aiortc, responding to requests for new peer connections from the relay server, and sending and receiving data to/from existing peer connections.</p> Example <pre><code>from proxystore.p2p.manager import PeerManager\npm1 = await PeerManager(uuid.uuid4(), relay_server_address)\npm2 = await PeerManager(uuid.uuid4(), relay_server_address)\nawait pm1.send(pm2.uuid, 'hello hello')\nsource_uuid, message = await pm2.recv()\nassert source_uuid == pm1.uuid\nassert message == 'hello hello'\npm1.close()\npm2.close()\n</code></pre> Note <p>The class can also be used as a context manager.</p> <pre><code>async with PeerManager(..) as manager:\n...\n</code></pre> Warning <p>The class must be initialized with await or inside an async with statement to correctly configure all async tasks and connections.</p> <pre><code>manager = await PeerManager(...)\nmanager.close()\n</code></pre> <pre><code>async with PeerManager(...) as manager:\n...\n</code></pre> <p>Parameters:</p> <ul> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of the client.</p> </li> <li> relay_server             (<code>str</code>)         \u2013 <p>Address of relay server to use for establishing peer-to-peer connections.</p> </li> <li> name             (<code>str | None</code>)         \u2013 <p>Readable name of the client to use in logging. If unspecified, the hostname will be used.</p> </li> <li> timeout             (<code>int</code>)         \u2013 <p>Timeout in seconds when waiting for a peer or relay server connection to be established.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>number of datachannels to split message sending over between each peer.</p> </li> <li> verify_certificate             (<code>bool</code>)         \u2013 <p>Verify the relay server's SSL certificate,</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the relay server address does not start with \"ws://\" or \"wss://\".</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>def __init__(\nself,\nuuid: UUID,\nrelay_server: str,\nname: str | None = None,\n*,\ntimeout: int = 30,\npeer_channels: int = 1,\nverify_certificate: bool = True,\n) -&gt; None:\nif not (\nrelay_server.startswith('ws://')\nor relay_server.startswith('wss://')\n):\nraise ValueError(\n'Relay server address must start with ws:// or wss://'\nf'Got {relay_server}.',\n)\nself._uuid = uuid\nself._relay_server = relay_server\nself._name = name if name is not None else utils.hostname()\nself._timeout = timeout\nself._peer_channels = peer_channels\nself._verify_certificate = verify_certificate\nself._peers_lock = asyncio.Lock()\nself._peers: dict[frozenset[UUID], PeerConnection] = {}\nself._message_queue: asyncio.Queue[\ntuple[UUID, bytes | str]\n] = asyncio.Queue()\nself._server_task: asyncio.Task[None] | None = None\nself._tasks: dict[frozenset[UUID], asyncio.Task[None]] = {}\nself._relay_server_client_or_none: RelayServerClient | None = None\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: UUID\n</code></pre> <p>UUID of the peer manager.</p>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the peer manager.</p>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.async_init","title":"async_init()  <code>async</code>","text":"<pre><code>async_init() -&gt; None\n</code></pre> <p>Connect to relay server.</p> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def async_init(self) -&gt; None:\n\"\"\"Connect to relay server.\"\"\"\nif self._relay_server_client_or_none is None:\nssl_context = ssl.create_default_context()\nif not self._verify_certificate:\nssl_context.check_hostname = False\nssl_context.verify_mode = ssl.CERT_NONE\nclient = RelayServerClient(\naddress=self._relay_server,\nclient_uuid=self._uuid,\nclient_name=self._name,\ntimeout=self._timeout,\nssl=ssl_context\nif self._relay_server.startswith('wss://')\nelse None,\n)\nawait client.connect()\nself._relay_server_client_or_none = client\nlogger.info(\nf'{self._log_prefix}: registered as peer with relay '\nf'server at {self._relay_server}',\n)\nif self._server_task is None:\nself._server_task = spawn_guarded_background_task(\nself._handle_server_messages,\n)\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.close","title":"close()  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connection manager.</p> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the connection manager.\"\"\"\nif self._server_task is not None:\nself._server_task.cancel()\ntry:\nawait self._server_task\nexcept (asyncio.CancelledError, SafeTaskExitError):\npass\nfor task in self._tasks.values():\ntask.cancel()\ntry:\nawait task\nexcept (asyncio.CancelledError, SafeTaskExitError):\npass\nasync with self._peers_lock:\nfor connection in self._peers.values():\nawait connection.close()\nif self._relay_server_client_or_none is not None:\nawait self._relay_server_client_or_none.close()\nlogger.info(f'{self._log_prefix}: peer manager closed')\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.close_connection","title":"close_connection()  <code>async</code>","text":"<pre><code>close_connection(peers: Iterable[UUID]) -&gt; None\n</code></pre> <p>Close a peer connection if it exists.</p> <p>This will close the associated <code>PeerConnection</code> and cancel the asyncio task handling peer messages. If the <code>PeerManager</code> is used to send a message from the peer again, a new connection will be established.</p> <p>Parameters:</p> <ul> <li> peers             (<code>Iterable[UUID]</code>)         \u2013 <p>Iterable containing the two peer UUIDs taking part in the connection that should be closed.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def close_connection(self, peers: Iterable[UUID]) -&gt; None:\n\"\"\"Close a peer connection if it exists.\n    This will close the associated\n    [`PeerConnection`][proxystore.p2p.connection.PeerConnection] and\n    cancel the asyncio task handling peer messages. If the\n    [`PeerManager`][proxystore.p2p.manager.PeerManager] is used to\n    send a message from the peer again, a new connection will be\n    established.\n    Args:\n        peers: Iterable containing the two peer UUIDs taking part in the\n            connection that should be closed.\n    \"\"\"\npeers = frozenset(peers)\nasync with self._peers_lock:\nconnection = self._peers.pop(peers, None)\nif connection is not None:\nlogger.info(\nf'{self._log_prefix} Closing connection between peers: '\nf'{\", \".join(str(peer) for peer in peers)}',\n)\nawait connection.close()\ntask = self._tasks.pop(peers, None)\nif task is not None:\ntask.cancel()\ntry:\nawait task\nexcept (asyncio.CancelledError, SafeTaskExitError):\npass\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.recv","title":"recv()  <code>async</code>","text":"<pre><code>recv() -&gt; tuple[UUID, bytes | str]\n</code></pre> <p>Receive next message from a peer.</p> <p>Returns:</p> <ul> <li> <code>tuple[UUID, bytes | str]</code>         \u2013 <p>Tuple containing the UUID of the peer that sent the message             and the message itself.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def recv(self) -&gt; tuple[UUID, bytes | str]:\n\"\"\"Receive next message from a peer.\n    Returns:\n        Tuple containing the UUID of the peer that sent the message \\\n        and the message itself.\n    \"\"\"\nreturn await self._message_queue.get()\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.send","title":"send()  <code>async</code>","text":"<pre><code>send(\npeer_uuid: UUID,\nmessage: bytes | str,\ntimeout: float = 30,\n) -&gt; None\n</code></pre> <p>Send message to peer.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer to send message to.</p> </li> <li> message             (<code>bytes | str</code>)         \u2013 <p>Message to send to peer.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Timeout to wait on peer connection to be ready.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerConnectionTimeoutError</code>           \u2013         <p>If the peer connection is not established within the timeout.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def send(\nself,\npeer_uuid: UUID,\nmessage: bytes | str,\ntimeout: float = 30,\n) -&gt; None:\n\"\"\"Send message to peer.\n    Args:\n        peer_uuid: UUID of peer to send message to.\n        message: Message to send to peer.\n        timeout: Timeout to wait on peer connection to be ready.\n    Raises:\n        PeerConnectionTimeoutError: If the peer connection is not\n            established within the timeout.\n    \"\"\"\nconnection = await self.get_connection(peer_uuid)\nawait connection.send(message, timeout)\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.get_connection","title":"get_connection()  <code>async</code>","text":"<pre><code>get_connection(peer_uuid: UUID) -&gt; PeerConnection\n</code></pre> <p>Get connection to the peer.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer to make connection with.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PeerConnection</code>         \u2013 <p>The peer connection object.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def get_connection(self, peer_uuid: UUID) -&gt; PeerConnection:\n\"\"\"Get connection to the peer.\n    Args:\n        peer_uuid: UUID of peer to make connection with.\n    Returns:\n        The peer connection object.\n    \"\"\"\npeers = frozenset({self._uuid, peer_uuid})\nasync with self._peers_lock:\nif peers in self._peers:\nreturn self._peers[peers]\nconnection = PeerConnection(\nself._relay_server_client,\nchannels=self._peer_channels,\n)\nself._peers[peers] = connection\nlogger.info(\nf'{self._log_prefix}: opening peer connection with '\nf'{peer_uuid}',\n)\nawait connection.send_offer(peer_uuid)\nself._tasks[peers] = spawn_guarded_background_task(\nself._handle_peer_messages,\npeer_uuid,\nconnection,\n)\nconnection.on_close_callback(self.close_connection, peers)\nreturn connection\n</code></pre>"},{"location":"api/p2p/messages/","title":"proxystore.p2p.messages","text":"<code>proxystore/p2p/messages.py</code> <p>Message types for peer-to-peer communication.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageType","title":"MessageType","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Types of messages supported.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageType.server_response","title":"server_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>server_response = 'ServerResponse'\n</code></pre> <p>Server response message.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageType.server_registration","title":"server_registration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>server_registration = 'ServerRegistration'\n</code></pre> <p>Server registration message.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageType.peer_connection","title":"peer_connection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>peer_connection = 'PeerConnection'\n</code></pre> <p>Peer connection message.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.Message","title":"Message  <code>dataclass</code>","text":"<p>Base message.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.ServerRegistration","title":"ServerRegistration  <code>dataclass</code>","text":"<p>         Bases: <code>Message</code></p> <p>Register with relay server as peer.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of peer requesting to register.</p> </li> <li> uuid             (<code>uuid.UUID</code>)         \u2013 <p>UUID of peer requesting to register.</p> </li> </ul>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.ServerResponse","title":"ServerResponse  <code>dataclass</code>","text":"<p>         Bases: <code>Message</code></p> <p>Message returned by relay server on success or error.</p> <p>Attributes:</p> <ul> <li> success             (<code>bool</code>)         \u2013 <p>If the registration was successful.</p> </li> <li> message             (<code>str | None</code>)         \u2013 <p>Message from server.</p> </li> <li> error             (<code>bool</code>)         \u2013 <p>If <code>message</code> is an error message.</p> </li> </ul>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.PeerConnection","title":"PeerConnection  <code>dataclass</code>","text":"<p>         Bases: <code>Message</code></p> <p>Message used in establishing a peer-to-peer connection.</p> <p>Attributes:</p> <ul> <li> source_uuid             (<code>uuid.UUID</code>)         \u2013 <p>UUID of sending peer.</p> </li> <li> source_name             (<code>str</code>)         \u2013 <p>Name of sending peer.</p> </li> <li> peer_uuid             (<code>uuid.UUID</code>)         \u2013 <p>UUID of destination peer.</p> </li> <li> description_type             (<code>Literal['answer', 'offer']</code>)         \u2013 <p>One of <code>'answer'</code> or <code>'offer'</code> indicating the type of message being sent.</p> </li> <li> description             (<code>str</code>)         \u2013 <p>Session description protocol message.</p> </li> <li> error             (<code>str | None</code>)         \u2013 <p>Error string if a problem occurs.</p> </li> </ul>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageDecodeError","title":"MessageDecodeError","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when a message cannot be decoded.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageEncodeError","title":"MessageEncodeError","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when an message cannot be encoded.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.uuid_to_str","title":"uuid_to_str()","text":"<pre><code>uuid_to_str(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Cast any UUIDs to strings.</p> <p>Scans the input dictionary for any values where the associated key contains 'uuid' and value is a UUID instance and converts it to a string for jsonification.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>Shallow copy of the input dictionary with values cast from UUID         to str if their key also contains UUID.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def uuid_to_str(data: dict[str, Any]) -&gt; dict[str, Any]:\n\"\"\"Cast any UUIDs to strings.\n    Scans the input dictionary for any values where the associated key\n    contains 'uuid' and value is a UUID instance and converts it to a\n    string for jsonification.\n    Returns:\n        Shallow copy of the input dictionary with values cast from UUID \\\n        to str if their key also contains UUID.\n    \"\"\"\ndata = data.copy()\nfor key in data:\nif 'uuid' in key.lower() and isinstance(data[key], uuid.UUID):\ndata[key] = str(data[key])\nreturn data\n</code></pre>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.str_to_uuid","title":"str_to_uuid()","text":"<pre><code>str_to_uuid(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Cast any possible UUID strings to UUID objects.</p> <p>The inverse operation of uuid_to_str().</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>Shallow copy of the input dictionary with values cast from         str to UUID if the key also contains UUID.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MessageDecodeError</code>           \u2013         <p>If a key contains 'uuid' but the value cannot be cast to a UUID.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def str_to_uuid(data: dict[str, Any]) -&gt; dict[str, Any]:\n\"\"\"Cast any possible UUID strings to UUID objects.\n    The inverse operation of\n    [uuid_to_str()][proxystore.p2p.messages.uuid_to_str].\n    Returns:\n        Shallow copy of the input dictionary with values cast from \\\n        str to UUID if the key also contains UUID.\n    Raises:\n        MessageDecodeError: If a key contains 'uuid' but the value cannot be\n            cast to a UUID.\n    \"\"\"\ndata = data.copy()\nfor key in data:\nif 'uuid' in key.lower():\ntry:\ndata[key] = uuid.UUID(data[key])\nexcept (AttributeError, TypeError, ValueError) as e:\nraise MessageDecodeError(\nf'Failed to convert key {key} to UUID.',\n) from e\nreturn data\n</code></pre>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.decode","title":"decode()","text":"<pre><code>decode(message: str) -&gt; Message\n</code></pre> <p>Decode JSON string into correct Message type.</p> <p>Parameters:</p> <ul> <li> message             (<code>str</code>)         \u2013 <p>JSON string to decode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>         \u2013 <p>Parsed message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MessageDecodeError</code>           \u2013         <p>If the message cannot be decoded.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def decode(message: str) -&gt; Message:\n\"\"\"Decode JSON string into correct Message type.\n    Args:\n        message: JSON string to decode.\n    Returns:\n        Parsed message.\n    Raises:\n        MessageDecodeError: If the message cannot be decoded.\n    \"\"\"\ntry:\ndata = json.loads(message)\nexcept json.JSONDecodeError as e:\nraise MessageDecodeError('Failed to load string as JSON.') from e\ntry:\nmessage_type_name = data.pop('message_type')\nexcept KeyError as e:\nraise MessageDecodeError(\n'Message does not contain a message_type key.',\n) from e\ntry:\nmessage_type = getattr(\nsys.modules[__name__],\nMessageType[message_type_name].value,\n)\nexcept (AttributeError, KeyError) as e:\nraise MessageDecodeError(\n'The message is of an unknown message type: '\nf'{message_type_name}.',\n) from e\ndata = str_to_uuid(data)\ntry:\nreturn message_type(**data)\nexcept TypeError as e:\nraise MessageDecodeError(\nf'Failed to convert message to {message_type.__name__}: {e}',\n) from e\n</code></pre>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.encode","title":"encode()","text":"<pre><code>encode(message: Message) -&gt; str\n</code></pre> <p>Encode message as JSON string.</p> <p>Parameters:</p> <ul> <li> message             (<code>Message</code>)         \u2013 <p>Message to JSON encode.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MessageEncodeError</code>           \u2013         <p>If the message cannot be JSON encoded.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def encode(message: Message) -&gt; str:\n\"\"\"Encode message as JSON string.\n    Args:\n        message: Message to JSON encode.\n    Raises:\n        MessageEncodeError: If the message cannot be JSON encoded.\n    \"\"\"\nif not isinstance(message, Message):\nraise MessageEncodeError(\nf'Message is not an instance of {Message.__name__}. '\nf'Got {type(message).__name__}.',\n)\ndata = dataclasses.asdict(message)\ndata = uuid_to_str(data)\ntry:\nreturn json.dumps(data)\nexcept TypeError as e:\nraise MessageEncodeError('Error encoding message.') from e\n</code></pre>"},{"location":"api/p2p/relay/","title":"proxystore.p2p.relay","text":"<code>proxystore/p2p/relay.py</code> <p>Relay server implementation for WebRTC peer connections.</p> <p>The relay server (or signaling server) is a lightweight server accessible by all peers (e.g., has a public IP address) that facilitates the establishment of peer WebRTC connections.</p>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.Client","title":"Client  <code>dataclass</code>","text":"<p>Representation of client connection.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of client.</p> </li> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of client.</p> </li> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>WebSocket connection to the client.</p> </li> </ul>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer","title":"RelayServer","text":"<pre><code>RelayServer() -&gt; None\n</code></pre> <p>WebRTC relay server.</p> <p>The relay server acts as a public third-party that helps two peers (endpoints) establish a peer-to-peer connection during the WebRTC peer connection initiation process. The relay server's responsibility is just to forward session descriptions between two peers, so the server can be relatively lightweight and typically only needs to transfer two messages to establish a peer connection, after which the peers no longer need the relay server.</p> <p>To learn more about the WebRTC peer connection process, check out https://webrtc.org/getting-started/peer-connections.</p> <p>The relay server is built on websockets and designed to be served using <code>websockets.serve()</code>.</p> Example <pre><code>import websockets\nfrom proxystore.p2p.relay import RelayServer\nrelay_server = RelayServer()\nasync with websockets.serve(\nrelay_server.handler, host='localhost', port=1234\n) as websocket_server:\n...\n</code></pre> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>def __init__(self) -&gt; None:\nself._websocket_to_client: dict[WebSocketServerProtocol, Client] = {}\nself._uuid_to_client: dict[UUID, Client] = {}\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer.send","title":"send()  <code>async</code>","text":"<pre><code>send(\nwebsocket: WebSocketServerProtocol,\nmessage: messages.Message,\n) -&gt; None\n</code></pre> <p>Send message on the socket.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket to send message on.</p> </li> <li> message             (<code>messages.Message</code>)         \u2013 <p>Message to json encode and send.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def send(\nself,\nwebsocket: WebSocketServerProtocol,\nmessage: messages.Message,\n) -&gt; None:\n\"\"\"Send message on the socket.\n    Args:\n        websocket: Websocket to send message on.\n        message: Message to json encode and send.\n    \"\"\"\ntry:\nmessage_str = messages.encode(message)\nexcept messages.MessageEncodeError as e:\nlogger.error(f'Failed to encode message: {e}')\nreturn\ntry:\nawait websocket.send(message_str)\nexcept websockets.exceptions.ConnectionClosed:\nlogger.error('Connection closed while attempting to send message')\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer.register","title":"register()  <code>async</code>","text":"<pre><code>register(\nwebsocket: WebSocketServerProtocol,\nrequest: messages.ServerRegistration,\n) -&gt; None\n</code></pre> <p>Register peer with relay server.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket connection with client wanting to register.</p> </li> <li> request             (<code>messages.ServerRegistration</code>)         \u2013 <p>Registration request message.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def register(\nself,\nwebsocket: WebSocketServerProtocol,\nrequest: messages.ServerRegistration,\n) -&gt; None:\n\"\"\"Register peer with relay server.\n    Args:\n        websocket: Websocket connection with client wanting to register.\n        request: Registration request message.\n    \"\"\"\nif websocket not in self._websocket_to_client:\n# Check if previous client reconnected on new socket so unregister\n# old socket. Warning: could be a client impersontating another\nif request.uuid in self._uuid_to_client:\nlogger.info(\nf'Previously registered client {request.uuid} attempting '\n'to reregister so old registration will be removed',\n)\nawait self.unregister(\nself._uuid_to_client[request.uuid].websocket,\nFalse,\n)\nclient = Client(\nname=request.name,\nuuid=request.uuid,\nwebsocket=websocket,\n)\nself._websocket_to_client[websocket] = client\nself._uuid_to_client[client.uuid] = client\nlogger.info(\nf'Registered {client.uuid} ({client.name} at '\nf'{websocket.remote_address})',\n)\nelse:\nclient = self._websocket_to_client[websocket]\nlogger.info(\nf'Previously registered client {client.uuid} attempting to '\n'reregister so previous registration will be returned',\n)\nawait self.send(websocket, messages.ServerResponse(success=True))\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer.unregister","title":"unregister()  <code>async</code>","text":"<pre><code>unregister(\nwebsocket: WebSocketServerProtocol, expected: bool\n) -&gt; None\n</code></pre> <p>Unregister the endpoint.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket connection that was closed.</p> </li> <li> expected             (<code>bool</code>)         \u2013 <p>If the connection was closed intentionally or due to an error.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def unregister(\nself,\nwebsocket: WebSocketServerProtocol,\nexpected: bool,\n) -&gt; None:\n\"\"\"Unregister the endpoint.\n    Args:\n        websocket: Websocket connection that was closed.\n        expected: If the connection was closed intentionally or due to an\n            error.\n    \"\"\"\nclient = self._websocket_to_client.pop(websocket, None)\nif client is None:\n# Most likely websocket closed before registration was performed\nreturn\nreason = 'ok' if expected else 'unexpected'\nlogger.info(\nf'Unregistering client {client.uuid} ({client.name}) '\nf'for {reason} reason',\n)\nself._uuid_to_client.pop(client.uuid, None)\nawait client.websocket.close(code=1000 if expected else 1001)\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer.connect","title":"connect()  <code>async</code>","text":"<pre><code>connect(\nwebsocket: WebSocketServerProtocol,\nmessage: messages.PeerConnection,\n) -&gt; None\n</code></pre> <p>Pass peer connection messages between clients.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket connection with client that sent the peer connection message.</p> </li> <li> message             (<code>messages.PeerConnection</code>)         \u2013 <p>Message to forward to peer client.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def connect(\nself,\nwebsocket: WebSocketServerProtocol,\nmessage: messages.PeerConnection,\n) -&gt; None:\n\"\"\"Pass peer connection messages between clients.\n    Args:\n        websocket: Websocket connection with client that sent the peer\n            connection message.\n        message: Message to forward to peer client.\n    \"\"\"\nclient = self._websocket_to_client[websocket]\nif message.peer_uuid not in self._uuid_to_client:\nlogger.warning(\nf'Client {client.uuid} ({client.name}) attempting to send '\nf'message to unknown peer {message.peer_uuid}',\n)\nmessage.error = (\n'Cannot forward peer connection message to peer '\nf'{message.peer_uuid} because this peer is unknown.'\n)\nawait self.send(websocket, message)\nelse:\npeer_client = self._uuid_to_client[message.peer_uuid]\nlogger.info(\nf'Transmitting message from {client.uuid} ({client.name}) '\nf'to {message.peer_uuid}',\n)\nawait self.send(peer_client.websocket, message)\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer.handler","title":"handler()  <code>async</code>","text":"<pre><code>handler(\nwebsocket: WebSocketServerProtocol, uri: str\n) -&gt; None\n</code></pre> <p>Websocket server message handler.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket message was received on.</p> </li> <li> uri             (<code>str</code>)         \u2013 <p>URI message was sent to.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def handler(\nself,\nwebsocket: WebSocketServerProtocol,\nuri: str,\n) -&gt; None:\n\"\"\"Websocket server message handler.\n    Args:\n        websocket: Websocket message was received on.\n        uri: URI message was sent to.\n    \"\"\"\nlogger.info('Relay server listening for incoming connections')\nwhile True:\ntry:\nmessage_str = await websocket.recv()\nif isinstance(message_str, str):\nmessage = messages.decode(message_str)\nelse:\nraise AssertionError(\n'Received non-str type on websocket.',\n)\nexcept websockets.exceptions.ConnectionClosedOK:\nawait self.unregister(websocket, expected=True)\nbreak\nexcept websockets.exceptions.ConnectionClosedError:\nawait self.unregister(websocket, expected=False)\nbreak\nexcept messages.MessageDecodeError as e:\nlogger.error(\n'Caught deserialization error on message received from '\nf'{websocket.remote_address}: {e} ...skipping message',\n)\ncontinue\nif isinstance(message, messages.ServerRegistration):\nawait self.register(websocket, message)\nelif isinstance(message, messages.PeerConnection):\nif websocket in self._websocket_to_client:\nawait self.connect(websocket, message)\nelse:\n# If message is not a registration request but this client\n# has not yet registered, let them know\nlogger.info(\n'Returning server error to message received from '\nf'unregistered client {message.source_uuid} '\nf'({message.source_name})',\n)\nresponse = messages.ServerResponse(\nsuccess=False,\nmessage='client has not registered yet',\nerror=True,\n)\nawait self.send(websocket, response)\nelse:\nraise AssertionError('Unreachable.')\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.serve","title":"serve()  <code>async</code>","text":"<pre><code>serve(\nhost: str,\nport: int,\ncertfile: str | None = None,\nkeyfile: str | None = None,\n) -&gt; None\n</code></pre> <p>Run the relay server.</p> <p>Initializes a <code>RelayServer</code> and starts a websocket server listening on <code>host:port</code> for new connections and incoming messages.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>Host to listen on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port to listen on.</p> </li> <li> certfile             (<code>str | None</code>)         \u2013 <p>Optional certificate file (PEM format) to enable TLS while serving.</p> </li> <li> keyfile             (<code>str | None</code>)         \u2013 <p>Optional private key file. If not specified, the key will be taken from the certfile.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def serve(\nhost: str,\nport: int,\ncertfile: str | None = None,\nkeyfile: str | None = None,\n) -&gt; None:\n\"\"\"Run the relay server.\n    Initializes a [`RelayServer`][proxystore.p2p.relay.RelayServer]\n    and starts a websocket server listening on `host:port` for new connections\n    and incoming messages.\n    Args:\n        host: Host to listen on.\n        port: Port to listen on.\n        certfile: Optional certificate file (PEM format) to enable TLS while\n            serving.\n        keyfile: Optional private key file. If not specified, the key will be\n            taken from the certfile.\n    \"\"\"\nserver = RelayServer()\n# Set the stop condition when receiving SIGINT (ctrl-C) and SIGTERM.\nloop = asyncio.get_running_loop()\nstop = loop.create_future()\nloop.add_signal_handler(signal.SIGINT, stop.set_result, None)\nloop.add_signal_handler(signal.SIGTERM, stop.set_result, None)\nssl_context: ssl.SSLContext | None = None\nif certfile is not None:  # pragma: no cover\nssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\nssl_context.load_cert_chain(certfile, keyfile=keyfile)\nasync with websockets.server.serve(\nserver.handler,\nhost,\nport,\nlogger=logger,\nssl=ssl_context,\n):\nlogger.info(f'Serving relay server on {host}:{port}')\nlogger.info('Use ctrl-C to stop')\nawait stop\nloop.remove_signal_handler(signal.SIGINT)\nloop.remove_signal_handler(signal.SIGTERM)\nlogger.info('Server closed')\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.cli","title":"cli()","text":"<pre><code>cli(\nhost: str,\nport: int,\ncertfile: str | None,\nkeyfile: str | None,\nlog_dir: str | None,\nlog_level: str,\n) -&gt; None\n</code></pre> <p>Run a relay server instance.</p> <p>The relay server is used by clients to establish peer-to-peer WebRTC connections.</p> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>@click.command()\n@click.option(\n'--host',\ndefault='0.0.0.0',\nmetavar='ADDR',\nhelp='Address to listen on.',\n)\n@click.option(\n'--port',\ndefault=8765,\ntype=int,\nmetavar='PORT',\nhelp='Port to listen on.',\n)\n@click.option(\n'--certfile',\ndefault=None,\nmetavar='PATH',\nhelp='Certificate file for serving with TLS.',\n)\n@click.option(\n'--keyfile',\ndefault=None,\nmetavar='PATH',\nhelp='Private key file associated with the certfile.',\n)\n@click.option(\n'--log-dir',\ndefault=None,\nmetavar='PATH',\nhelp='Write server logs to this directory.',\n)\n@click.option(\n'--log-level',\ndefault='INFO',\ntype=click.Choice(\n['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'],\ncase_sensitive=False,\n),\nhelp='Minimum logging level.',\n)\ndef cli(\nhost: str,\nport: int,\ncertfile: str | None,\nkeyfile: str | None,\nlog_dir: str | None,\nlog_level: str,\n) -&gt; None:\n\"\"\"Run a relay server instance.\n    The relay server is used by clients to establish peer-to-peer\n    WebRTC connections.\n    \"\"\"\nhandlers: list[logging.Handler] = [logging.StreamHandler(sys.stdout)]\nif log_dir is not None:\nos.makedirs(log_dir, exist_ok=True)\nhandlers.append(\nlogging.handlers.TimedRotatingFileHandler(\nos.path.join(log_dir, 'server.log'),\n# Rotate logs Sunday at midnight\nwhen='W6',\natTime=datetime.time(hour=0, minute=0, second=0),\n),\n)\nlogging.basicConfig(\nformat=(\n'[%(asctime)s.%(msecs)03d] %(levelname)-5s (%(name)s) :: '\n'%(message)s'\n),\ndatefmt='%Y-%m-%d %H:%M:%S',\nlevel=log_level,\nhandlers=handlers,\n)\nasyncio.run(serve(host, port, certfile=certfile, keyfile=keyfile))\n</code></pre>"},{"location":"api/p2p/relay_client/","title":"proxystore.p2p.relay_client","text":"<code>proxystore/p2p/relay_client.py</code> <p>Client interface to a relay server.</p>"},{"location":"api/p2p/relay_client/#proxystore.p2p.relay_client.RelayServerClient","title":"RelayServerClient","text":"<pre><code>RelayServerClient(\naddress: str,\nclient_uuid: uuid.UUID | None = None,\nclient_name: str | None = None,\ntimeout: float = 10,\nssl: ssl.SSLContext | None = None,\n) -&gt; None\n</code></pre> <p>Client interface to a relay server.</p> <p>This interface abstracts the low-level WebSocket connection to a relay server to provide automatic reconnection.</p> Tip <p>This class can be used as an async context manager! <pre><code>from proxystore.p2p.relay_client import RelayServerClient\nasync with RelayServerClient(...) as client:\nawait client.send(...)\nmessage = await client.recv(...)\n</code></pre></p> Note <p>WebSocket connections are not opened until a message is sent, a message is received, or <code>connect()</code> is called.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of the relay server. Should start with <code>ws://</code> or <code>wss://</code>.</p> </li> <li> client_uuid             (<code>uuid.UUID | None</code>)         \u2013 <p>Optional UUID of the client to use when registering with the relay server. If <code>None</code>, one will be generated.</p> </li> <li> client_name             (<code>str | None</code>)         \u2013 <p>Optional name of the client to use when registering with the relay server. If <code>None</code>, the hostname will be used.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Time to wait in seconds on server connections.</p> </li> <li> ssl             (<code>ssl.SSLContext | None</code>)         \u2013 <p>When <code>None</code>, the correct value to pass to <code>websockets.connect()</code> is inferred from <code>address</code>. If <code>address</code> starts with <code>wss://</code> the value is True, otherwise is False. Optionally provide a custom <code>SSLContext</code> (useful if the server uses self-signed certificates).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRegistrationError</code>           \u2013         <p>If the connection to the relay server is closed, does not reply to the registration request within the timeout, or replies with an error.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If address does not start with <code>ws://</code> or <code>wss://</code>.</p> </li> </ul> Source code in <code>proxystore/p2p/relay_client.py</code> <pre><code>def __init__(\nself,\naddress: str,\nclient_uuid: uuid.UUID | None = None,\nclient_name: str | None = None,\ntimeout: float = 10,\nssl: ssl.SSLContext | None = None,\n) -&gt; None:\nself.address = address\nself.uuid = uuid.uuid4() if client_uuid is None else client_uuid\nself.name = hostname() if client_name is None else client_name\nself.timeout = timeout\nif not (\nself.address.startswith('ws://')\nor self.address.startswith('wss://')\n):\nraise ValueError(\n'Relay server address must start with ws:// or wss://.'\nf'Got {self.address}.',\n)\nssl_default = True if self.address.startswith('wss://') else None\nself.ssl = ssl_default if ssl is None else ssl\nself.initial_backoff_seconds = 1.0\nself._websocket: WebSocketClientProtocol | None = None\n</code></pre>"},{"location":"api/p2p/relay_client/#proxystore.p2p.relay_client.RelayServerClient.connect","title":"connect()  <code>async</code>","text":"<pre><code>connect() -&gt; WebSocketClientProtocol\n</code></pre> <p>Connect to the relay server.</p> Note <p>Typically this does not need to be called because the send and receive methods will automatically call this.</p> Note <p>If an existing and open connection exists, that will be returned. Otherwise, a new connection will be attempted with exponential backoff for connection failures.</p> <p>Returns:</p> <ul> <li> <code>WebSocketClientProtocol</code>         \u2013 <p>WebSocket connection to the relay server.</p> </li> </ul> Source code in <code>proxystore/p2p/relay_client.py</code> <pre><code>async def connect(self) -&gt; WebSocketClientProtocol:\n\"\"\"Connect to the relay server.\n    Note:\n        Typically this does not need to be called because the\n        send and receive methods will automatically call this.\n    Note:\n        If an existing and open connection exists, that will be returned.\n        Otherwise, a new connection will be attempted with\n        exponential backoff for connection failures.\n    Returns:\n        WebSocket connection to the relay server.\n    \"\"\"\nif self._websocket is not None and self._websocket.open:\nreturn self._websocket\nbackoff_seconds = self.initial_backoff_seconds\nwhile True:\ntry:\nself._websocket = await self._register(timeout=self.timeout)\nexcept (\n# Exceptions that we should wait and retry again for\nConnectionRefusedError,\nasyncio.TimeoutError,\nwebsockets.exceptions.ConnectionClosed,\n) as e:\nlogger.warning(\nf'Registration with relay server at {self.address} '\nf'failed because of {e}. Retrying connection in '\nf'{backoff_seconds} seconds',\n)\nawait asyncio.sleep(backoff_seconds)\nbackoff_seconds *= 2\nelse:\n# Coverage doesn't detect the singular break but it does\n# get executed to break from the loop\nbreak  # pragma: no cover\nreturn self._websocket\n</code></pre>"},{"location":"api/p2p/relay_client/#proxystore.p2p.relay_client.RelayServerClient.close","title":"close()  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connection to the relay server.</p> Source code in <code>proxystore/p2p/relay_client.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the connection to the relay server.\"\"\"\nif self._websocket is not None:\nawait self._websocket.close()\n</code></pre>"},{"location":"api/p2p/relay_client/#proxystore.p2p.relay_client.RelayServerClient.recv","title":"recv()  <code>async</code>","text":"<pre><code>recv() -&gt; messages.Message\n</code></pre> <p>Receive the next message.</p> <p>Returns:</p> <ul> <li> <code>messages.Message</code>         \u2013 <p>The message received from the relay server.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>messages.MessageDecodeError</code>           \u2013         <p>If the message received cannot be decoded into the appropriate message type.</p> </li> </ul> Source code in <code>proxystore/p2p/relay_client.py</code> <pre><code>async def recv(self) -&gt; messages.Message:\n\"\"\"Receive the next message.\n    Returns:\n        The message received from the relay server.\n    Raises:\n        messages.MessageDecodeError: If the message received cannot\n            be decoded into the appropriate message type.\n    \"\"\"\nwebsocket = await self.connect()\nmessage_str = await websocket.recv()\nif not isinstance(message_str, str):\nraise AssertionError('Received non-string from websocket.')\nreturn messages.decode(message_str)\n</code></pre>"},{"location":"api/p2p/relay_client/#proxystore.p2p.relay_client.RelayServerClient.send","title":"send()  <code>async</code>","text":"<pre><code>send(message: messages.Message) -&gt; None\n</code></pre> <p>Send a message.</p> <p>Parameters:</p> <ul> <li> message             (<code>messages.Message</code>)         \u2013 <p>The message to send to the relay server.</p> </li> </ul> Source code in <code>proxystore/p2p/relay_client.py</code> <pre><code>async def send(self, message: messages.Message) -&gt; None:\n\"\"\"Send a message.\n    Args:\n        message: The message to send to the relay server.\n    \"\"\"\nmessage_str = messages.encode(message)\nwebsocket = await self.connect()\nawait websocket.send(message_str)\n</code></pre>"},{"location":"api/p2p/task/","title":"proxystore.p2p.task","text":"<code>proxystore/p2p/task.py</code> <p>Utilities for launching async tasks.</p>"},{"location":"api/p2p/task/#proxystore.p2p.task.SafeTaskExitError","title":"SafeTaskExitError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception that can be raised inside a task to safely exit it.</p>"},{"location":"api/p2p/task/#proxystore.p2p.task.exit_on_error","title":"exit_on_error()","text":"<pre><code>exit_on_error(task: asyncio.Task[Any]) -&gt; None\n</code></pre> <p>Task callback that raises SystemExit on task exception.</p> Source code in <code>proxystore/p2p/task.py</code> <pre><code>def exit_on_error(task: asyncio.Task[Any]) -&gt; None:\n\"\"\"Task callback that raises SystemExit on task exception.\"\"\"\nif (\nnot task.cancelled()\nand task.exception() is not None\nand not isinstance(task.exception(), SafeTaskExitError)\n):\nlogger.error(f'Exception in background coroutine: {task.exception()}')\nraise SystemExit(1)\n</code></pre>"},{"location":"api/p2p/task/#proxystore.p2p.task.spawn_guarded_background_task","title":"spawn_guarded_background_task()","text":"<pre><code>spawn_guarded_background_task(\ncoro: Callable[..., Coroutine[Any, Any, None]],\n*args: Any,\n**kwargs: Any\n) -&gt; asyncio.Task[Any]\n</code></pre> <p>Run a coroutine safely in the background.</p> <p>Launches the coroutine as an asyncio task and sets the done callback to <code>exit_on_error()</code>. This is \"safe\" because it will ensure exceptions inside the task get logged and cause the program to exit. Otherwise, background tasks that are not awaited may not have their exceptions raised such that programs hang with no notice of the exception that caused the hang.</p> <p>Tasks can raise <code>SafeTaskExit</code> to signal the task is finished but should not cause a system exit.</p> <p>Source: https://stackoverflow.com/questions/62588076</p> <p>Parameters:</p> <ul> <li> coro             (<code>Callable[..., Coroutine[Any, Any, None]]</code>)         \u2013 <p>Coroutine to run as task.</p> </li> <li> args             (<code>Any</code>)         \u2013 <p>Positional arguments for the coroutine.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Keyword arguments for the coroutine.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>asyncio.Task[Any]</code>         \u2013 <p>Asyncio task handle.</p> </li> </ul> Source code in <code>proxystore/p2p/task.py</code> <pre><code>def spawn_guarded_background_task(\ncoro: Callable[..., Coroutine[Any, Any, None]],\n*args: Any,\n**kwargs: Any,\n) -&gt; asyncio.Task[Any]:\n\"\"\"Run a coroutine safely in the background.\n    Launches the coroutine as an asyncio task and sets the done\n    callback to [`exit_on_error()`][proxystore.p2p.task.exit_on_error].\n    This is \"safe\" because it will ensure exceptions inside the task get logged\n    and cause the program to exit. Otherwise, background tasks that are not\n    awaited may not have their exceptions raised such that programs hang with\n    no notice of the exception that caused the hang.\n    Tasks can raise [`SafeTaskExit`][proxystore.p2p.task.SafeTaskExitError] to\n    signal the task is finished but should not cause a system exit.\n    Source: https://stackoverflow.com/questions/62588076\n    Args:\n        coro: Coroutine to run as task.\n        args: Positional arguments for the coroutine.\n        kwargs: Keyword arguments for the coroutine.\n    Returns:\n        Asyncio task handle.\n    \"\"\"\ntask = asyncio.create_task(coro(*args, **kwargs))\ntask.add_done_callback(exit_on_error)\nreturn task\n</code></pre>"},{"location":"api/store/","title":"proxystore.store","text":"<code>proxystore/store/__init__.py</code> <p>The ProxyStore <code>Store</code> interface.</p>"},{"location":"api/store/#proxystore.store.get_store","title":"get_store()","text":"<pre><code>get_store(val: str | Proxy[T]) -&gt; Store[Any] | None\n</code></pre> <p>Get the backend store with name.</p> <p>Parameters:</p> <ul> <li> val             (<code>str | Proxy[T]</code>)         \u2013 <p>name of the store to get or a <code>Proxy</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Store[Any] | None</code>         \u2013 <p><code>Store</code> if a store matching the         name or belonging to the proxy exists. If the store does not exist,         returns <code>None</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ProxyStoreFactoryError</code>           \u2013         <p>If the value is a proxy but does not contain a factory of type <code>StoreFactory</code>.</p> </li> </ul> Source code in <code>proxystore/store/__init__.py</code> <pre><code>def get_store(val: str | Proxy[T]) -&gt; Store[Any] | None:\n\"\"\"Get the backend store with name.\n    Args:\n        val: name of the store to get or a [`Proxy`][proxystore.proxy.Proxy]\n            instance.\n    Returns:\n        [`Store`][proxystore.store.base.Store] if a store matching the \\\n        name or belonging to the proxy exists. If the store does not exist, \\\n        returns `None`.\n    Raises:\n        ProxyStoreFactoryError: If the value is a proxy but does not contain a\n            factory of type\n            [`StoreFactory`][proxystore.store.base.StoreFactory].\n    \"\"\"\nif isinstance(val, Proxy):\n# If the object is a proxy, get the factory that will access the store\nfactory = val.__factory__\nif isinstance(factory, StoreFactory):\nreturn factory.get_store()\nelse:\nraise ProxyStoreFactoryError(\n'The proxy must contain a factory with type '\nf'{type(StoreFactory).__name__}. {type(factory).__name__} '\n'is not supported.',\n)\nelse:\nname = val\nif name in _stores:\nreturn _stores[name]\nreturn None\n</code></pre>"},{"location":"api/store/#proxystore.store.register_store","title":"register_store()","text":"<pre><code>register_store(\nstore: Store[Any], exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Register the store instance to the global registry.</p> Note <p>Global means globally accessible within the Python process.</p> Tip <p>Use the <code>store_registration</code> context manager to automatically register and unregister as store.</p> <p>Parameters:</p> <ul> <li> store             (<code>Store[Any]</code>)         \u2013 <p>Store instance to register.</p> </li> <li> exist_ok             (<code>bool</code>)         \u2013 <p>If a store with the same name exists, overwrite it.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>StoreExistsError</code>           \u2013         <p>If a store with the same name is already registered and <code>exist_ok</code> is false.</p> </li> </ul> Source code in <code>proxystore/store/__init__.py</code> <pre><code>def register_store(store: Store[Any], exist_ok: bool = False) -&gt; None:\n\"\"\"Register the store instance to the global registry.\n    Note:\n        Global means globally accessible within the Python process.\n    Tip:\n        Use the [`store_registration`][proxystore.store.store_registration]\n        context manager to automatically register and unregister as store.\n    Args:\n        store: Store instance to register.\n        exist_ok: If a store with the same name exists, overwrite it.\n    Raises:\n        StoreExistsError: If a store with the same name is already registered\n            and `exist_ok` is false.\n    \"\"\"\nif store.name in _stores and not exist_ok:\nraise StoreExistsError(f'A store named {store.name} already exists.')\n_stores[store.name] = store\nlogger.info(f'Registered a store named {store.name}')\n</code></pre>"},{"location":"api/store/#proxystore.store.store_registration","title":"store_registration()","text":"<pre><code>store_registration(\n*stores: Store[Any], exist_ok: bool = False\n) -&gt; Generator[None, None, None]\n</code></pre> <p>Context manager that registers and unregisters a set of stores.</p> Example <pre><code>from proxystore.connectors.local import LocalConnector\nfrom proxystore.store import Store\nfrom proxystore.store import store_registration\nwith Store('store', LocalConnector()) as store:\nwith store_registration(store):\n...\nstores = [\nStore('store1', LocalConnector()),\nStore('store2', LocalConnector()),\n]\nwith store_registration(*stores):\n...\n</code></pre> <p>Parameters:</p> <ul> <li> stores             (<code>Store[Any]</code>)         \u2013 <p>Set of <code>Store</code> instances to register then unregister when the context manager is exited.</p> </li> <li> exist_ok             (<code>bool</code>)         \u2013 <p>If a store with the same name exists, overwrite it.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>StoreExistsError</code>           \u2013         <p>If a store with the same name is already registered and <code>exist_ok</code> is false.</p> </li> </ul> Source code in <code>proxystore/store/__init__.py</code> <pre><code>@contextlib.contextmanager\ndef store_registration(\n*stores: Store[Any],\nexist_ok: bool = False,\n) -&gt; Generator[None, None, None]:\n\"\"\"Context manager that registers and unregisters a set of stores.\n    Example:\n        ```python\n        from proxystore.connectors.local import LocalConnector\n        from proxystore.store import Store\n        from proxystore.store import store_registration\n        with Store('store', LocalConnector()) as store:\n            with store_registration(store):\n                ...\n        stores = [\n            Store('store1', LocalConnector()),\n            Store('store2', LocalConnector()),\n        ]\n        with store_registration(*stores):\n            ...\n        ```\n    Args:\n        stores: Set of [`Store`][proxystore.store.base.Store] instances to\n            register then unregister when the context manager is exited.\n        exist_ok: If a store with the same name exists, overwrite it.\n    Raises:\n        StoreExistsError: If a store with the same name is already registered\n            and `exist_ok` is false.\n    \"\"\"\nfor store in stores:\nregister_store(store, exist_ok=exist_ok)\nyield\nfor store in stores:\nunregister_store(store)\n</code></pre>"},{"location":"api/store/#proxystore.store.unregister_store","title":"unregister_store()","text":"<pre><code>unregister_store(name_or_store: str | Store[Any]) -&gt; None\n</code></pre> <p>Unregisters the store instance from the global registry.</p> Note <p>This function is a no-op if no store matching the name exists (i.e., no exception will be raised).</p> <p>Parameters:</p> <ul> <li> name_or_store             (<code>str | Store[Any]</code>)         \u2013 <p>Name of the store to unregister or a store itself.</p> </li> </ul> Source code in <code>proxystore/store/__init__.py</code> <pre><code>def unregister_store(name_or_store: str | Store[Any]) -&gt; None:\n\"\"\"Unregisters the store instance from the global registry.\n    Note:\n        This function is a no-op if no store matching the name\n        exists (i.e., no exception will be raised).\n    Args:\n        name_or_store: Name of the store to unregister or a store itself.\n    \"\"\"\nname = (\nname_or_store if isinstance(name_or_store, str) else name_or_store.name\n)\nif name in _stores:\ndel _stores[name]\nlogger.debug(f'Unregistered a store named {name}')\n</code></pre>"},{"location":"api/store/base/","title":"proxystore.store.base","text":"<code>proxystore/store/base.py</code> <p>Store implementation.</p>"},{"location":"api/store/base/#proxystore.store.base.ConnectorT","title":"ConnectorT  <code>module-attribute</code>","text":"<pre><code>ConnectorT = TypeVar('ConnectorT', bound=Connector[Any])\n</code></pre> <p>Connector type variable.</p>"},{"location":"api/store/base/#proxystore.store.base.ConnectorKeyT","title":"ConnectorKeyT  <code>module-attribute</code>","text":"<pre><code>ConnectorKeyT = Tuple[Any, Ellipsis]\n</code></pre> <p>Connector key type alias.</p>"},{"location":"api/store/base/#proxystore.store.base.SerializerT","title":"SerializerT  <code>module-attribute</code>","text":"<pre><code>SerializerT = Callable[[Any], bytes]\n</code></pre> <p>Serializer type alias.</p>"},{"location":"api/store/base/#proxystore.store.base.DeserializerT","title":"DeserializerT  <code>module-attribute</code>","text":"<pre><code>DeserializerT = Callable[[bytes], Any]\n</code></pre> <p>Deserializer type alias.</p>"},{"location":"api/store/base/#proxystore.store.base.StoreFactory","title":"StoreFactory","text":"<pre><code>StoreFactory(\nkey: ConnectorKeyT,\nstore_config: dict[str, Any],\n*,\nevict: bool = False,\ndeserializer: DeserializerT | None = None,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[ConnectorT, T]</code></p> <p>Factory that resolves an object from a store.</p> <p>Adds support for asynchronously retrieving objects from a <code>Store</code> instance.</p> <p>The factory takes the <code>store_config</code> parameter that is used to reinitialize the store if the factory is sent to a remote process where the store has not already been initialized.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>Key corresponding to object in store.</p> </li> <li> store_config             (<code>dict[str, Any]</code>)         \u2013 <p>Store configuration used to reinitialize the store if needed.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If True, evict the object from the store once <code>resolve()</code> is called.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def __init__(\nself,\nkey: ConnectorKeyT,\nstore_config: dict[str, Any],\n*,\nevict: bool = False,\ndeserializer: DeserializerT | None = None,\nmetrics: bool = False,\n) -&gt; None:\nself.key = key\nself.store_config = store_config\nself.evict = evict\nself.deserializer = deserializer\nself.metrics = metrics\n# The following are not included when a factory is serialized\n# because they are specific to that instance of the factory\nself._obj_future: Future[T] | None = None\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.StoreFactory.get_store","title":"get_store()","text":"<pre><code>get_store() -&gt; Store[ConnectorT]\n</code></pre> <p>Get store and reinitialize if necessary.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the type of the returned store does not match the expected store type passed to the factory constructor.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def get_store(self) -&gt; Store[ConnectorT]:\n\"\"\"Get store and reinitialize if necessary.\n    Raises:\n        ValueError: If the type of the returned store does not match the\n            expected store type passed to the factory constructor.\n    \"\"\"\nstore = proxystore.store.get_store(self.store_config['name'])\nif store is None:\nstore = Store.from_config(self.store_config)\nproxystore.store.register_store(store)\nreturn store\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.StoreFactory.resolve","title":"resolve()","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Get object associated with key from store.</p> <p>Raises:</p> <ul> <li> <code>ProxyResolveMissingKeyError</code>           \u2013         <p>If the key associated with this factory does not exist in the store.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Get object associated with key from store.\n    Raises:\n        ProxyResolveMissingKeyError: If the key associated with this\n            factory does not exist in the store.\n    \"\"\"\nwith Timer() as timer:\nstore = self.get_store()\nobj = store.get(\nself.key,\ndeserializer=self.deserializer,\ndefault=_MISSING_OBJECT,\n)\nif obj is _MISSING_OBJECT:\nraise ProxyResolveMissingKeyError(\nself.key,\ntype(store),\nstore.name,\n)\nif self.evict:\nstore.evict(self.key)\nif store.metrics is not None:\ntotal_time = timer.elapsed_ns\nstore.metrics.add_time('factory.resolve', self.key, total_time)\nreturn cast(T, obj)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.StoreFactory.resolve_async","title":"resolve_async()","text":"<pre><code>resolve_async() -&gt; None\n</code></pre> <p>Asynchronously get object associated with key from store.</p> Source code in <code>proxystore/store/base.py</code> <pre><code>def resolve_async(self) -&gt; None:\n\"\"\"Asynchronously get object associated with key from store.\"\"\"\nlogger.debug(f'Starting asynchronous resolve of {self.key}')\nself._obj_future = _default_pool.submit(self.resolve)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store","title":"Store","text":"<pre><code>Store(\nname: str,\nconnector: ConnectorT,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[ConnectorT]</code></p> <p>Key-value store interface for proxies.</p> Tip <p>A <code>Store</code> instance can be used as a context manager which will automatically call <code>close()</code> on exit.</p> <pre><code>with Store('my-store', connector=...) as store:\nkey = store.put('value')\nstore.get(key)\n</code></pre> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> connector             (<code>ConnectorT</code>)         \u2013 <p>Connector instance to use for object storage.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>cache_size</code> is less than zero.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def __init__(\nself,\nname: str,\nconnector: ConnectorT,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nif cache_size &lt; 0:\nraise ValueError(\nf'Cache size cannot be negative. Got {cache_size}.',\n)\nself.connector = connector\nself.cache: LRUCache[ConnectorKeyT, Any] = LRUCache(cache_size)\nself._name = name\nself._metrics = StoreMetrics() if metrics else None\nself._cache_size = cache_size\nself._serializer = serializer\nself._deserializer = deserializer\nlogger.info(f'Initialized {self}')\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of this <code>Store</code> instance.</p>"},{"location":"api/store/base/#proxystore.store.base.Store.metrics","title":"metrics  <code>property</code>","text":"<pre><code>metrics: StoreMetrics | None\n</code></pre> <p>Optional metrics for this instance.</p>"},{"location":"api/store/base/#proxystore.store.base.Store.serializer","title":"serializer  <code>property</code>","text":"<pre><code>serializer: SerializerT\n</code></pre> <p>Serializer for this instance.</p>"},{"location":"api/store/base/#proxystore.store.base.Store.deserializer","title":"deserializer  <code>property</code>","text":"<pre><code>deserializer: DeserializerT\n</code></pre> <p>Deserializer for this instance.</p>"},{"location":"api/store/base/#proxystore.store.base.Store.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector associated with the store.</p> Warning <p>This method should only be called at the end of the program when the store will no longer be used, for example once all proxies have been resolved.</p> Source code in <code>proxystore/store/base.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector associated with the store.\n    Warning:\n        This method should only be called at the end of the program\n        when the store will no longer be used, for example once all\n        proxies have been resolved.\n    \"\"\"\nself.connector.close()\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the store configuration.</p> Example <pre><code>&gt;&gt;&gt; store = Store(...)\n&gt;&gt;&gt; config = store.config()\n&gt;&gt;&gt; store = Store.from_config(config)\n</code></pre> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>Store configuration.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the store configuration.\n    Example:\n        ```python\n        &gt;&gt;&gt; store = Store(...)\n        &gt;&gt;&gt; config = store.config()\n        &gt;&gt;&gt; store = Store.from_config(config)\n        ```\n    Returns:\n        Store configuration.\n    \"\"\"\nreturn {\n'name': self.name,\n'connector_type': get_class_path(type(self.connector)),\n'connector_config': self.connector.config(),\n'serializer': self._serializer,\n'deserializer': self._deserializer,\n'cache_size': self._cache_size,\n'metrics': self.metrics is not None,\n}\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; Store[Any]\n</code></pre> <p>Create a new store instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Store[Any]</code>         \u2013 <p>Store instance.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; Store[Any]:\n\"\"\"Create a new store instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    Returns:\n        Store instance.\n    \"\"\"\nconfig = config.copy()  # Avoid messing with callers version\nconnector_type = config.pop('connector_type')\nconnector_config = config.pop('connector_config')\nconnector = import_class(connector_type)\nconfig['connector'] = connector.from_config(connector_config)\nreturn cls(**config)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.evict","title":"evict()","text":"<pre><code>evict(key: ConnectorKeyT) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def evict(self, key: ConnectorKeyT) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nwith Timer() as timer:\nwith Timer() as connector_timer:\nself.connector.evict(key)\nif self.metrics is not None:\nctime = connector_timer.elapsed_ns\nself.metrics.add_time('store.evict.connector', key, ctime)\nself.cache.evict(key)\nif self.metrics is not None:\nself.metrics.add_time('store.evict', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): EVICT {key} in '\nf'{timer.elapsed_ms:.3f} ms',\n)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.exists","title":"exists()","text":"<pre><code>exists(key: ConnectorKeyT) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def exists(self, key: ConnectorKeyT) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nwith Timer() as timer:\nres = self.cache.exists(key)\nif not res:\nwith Timer() as connector_timer:\nres = self.connector.exists(key)\nif self.metrics is not None:\nctime = connector_timer.elapsed_ns\nself.metrics.add_time('store.exists.connector', key, ctime)\nif self.metrics is not None:\nself.metrics.add_time('store.exists', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): EXISTS {key} in '\nf'{timer.elapsed_ms:.3f} ms',\n)\nreturn res\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.get","title":"get()","text":"<pre><code>get(\nkey: ConnectorKeyT,\n*,\ndeserializer: DeserializerT | None = None,\ndefault: object | None = None\n) -&gt; Any | None\n</code></pre> <p>Get the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optionally override the default deserializer for the store instance.</p> </li> <li> default             (<code>object | None</code>)         \u2013 <p>An optional value to be returned if an object associated with the key does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any | None</code>         \u2013 <p>Object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def get(\nself,\nkey: ConnectorKeyT,\n*,\ndeserializer: DeserializerT | None = None,\ndefault: object | None = None,\n) -&gt; Any | None:\n\"\"\"Get the object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n        deserializer: Optionally override the default deserializer for the\n            store instance.\n        default: An optional value to be returned if an object\n            associated with the key does not exist.\n    Returns:\n        Object or `None` if the object does not exist.\n    \"\"\"\ntimer = Timer()\ntimer.start()\nif self.is_cached(key):\nvalue = self.cache.get(key)\ntimer.stop()\nif self.metrics is not None:\nself.metrics.add_counter('store.get.cache_hits', key, 1)\nself.metrics.add_time('store.get', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): GET {key} in '\nf'{timer.elapsed_ms:.3f} ms (cached=True)',\n)\nreturn value\nwith Timer() as connector_timer:\nvalue = self.connector.get(key)\nif self.metrics is not None:\nctime = connector_timer.elapsed_ns\nself.metrics.add_counter('store.get.cache_misses', key, 1)\nself.metrics.add_time('store.get.connector', key, ctime)\nif value is not None:\nwith Timer() as deserializer_timer:\nif deserializer is not None:\nresult = deserializer(value)\nelse:\nresult = self.deserializer(value)\nif self.metrics is not None:\ndtime = deserializer_timer.elapsed_ns\nobj_size = len(value)\nself.metrics.add_time('store.get.deserialize', key, dtime)\nself.metrics.add_attribute(\n'store.get.object_size',\nkey,\nobj_size,\n)\nself.cache.set(key, result)\nelse:\nresult = default\ntimer.stop()\nif self.metrics is not None:\nself.metrics.add_time('store.get', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): GET {key} in '\nf'{timer.elapsed_ms:.3f} ms (cached=False)',\n)\nreturn result\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.is_cached","title":"is_cached()","text":"<pre><code>is_cached(key: ConnectorKeyT) -&gt; bool\n</code></pre> <p>Check if an object associated with the key is cached locally.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the object is cached.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def is_cached(self, key: ConnectorKeyT) -&gt; bool:\n\"\"\"Check if an object associated with the key is cached locally.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If the object is cached.\n    \"\"\"\nreturn self.cache.exists(key)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.proxy","title":"proxy()","text":"<pre><code>proxy(\nobj: T | NonProxiableT,\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nskip_nonproxiable: bool = False,\n**kwargs: Any\n) -&gt; Proxy[T] | NonProxiableT\n</code></pre> <p>Create a proxy that will resolve to an object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T | NonProxiableT</code>)         \u2013 <p>The object to place in store and return a proxy for.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If the proxy should evict the object once resolved.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optionally override the default serializer for the store instance.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optionally override the default deserializer for the store instance.</p> </li> <li> skip_nonproxiable             (<code>bool</code>)         \u2013 <p>Return non-proxiable types (e.g., built-in constants like <code>bool</code> or <code>None</code>) rather than raising a <code>NonProxiableTypeError</code>.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional keyword arguments to pass to <code>Connector.put()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Proxy[T] | NonProxiableT</code>         \u2013 <p>A proxy of the object unless <code>obj</code> is a non-proxiable type             <code>skip_nonproxiable is True</code> in which case <code>obj</code> is             returned directly.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NonProxiableTypeError</code>           \u2013         <p>If <code>obj</code> is a non-proxiable type. This behavior can be overridden by setting <code>skip_nonproxiable=True</code>.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def proxy(\nself,\nobj: T | NonProxiableT,\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nskip_nonproxiable: bool = False,\n**kwargs: Any,\n) -&gt; Proxy[T] | NonProxiableT:\n\"\"\"Create a proxy that will resolve to an object in the store.\n    Args:\n        obj: The object to place in store and return a proxy for.\n        evict: If the proxy should evict the object once resolved.\n        serializer: Optionally override the default serializer for the\n            store instance.\n        deserializer: Optionally override the default deserializer for the\n            store instance.\n        skip_nonproxiable: Return non-proxiable types (e.g., built-in\n            constants like `bool` or `None`) rather than raising a\n            [`NonProxiableTypeError`][proxystore.store.exceptions.NonProxiableTypeError].\n        kwargs: Additional keyword arguments to pass to\n            [`Connector.put()`][proxystore.connectors.connector.Connector.put].\n    Returns:\n        A proxy of the object unless `obj` is a non-proxiable type \\\n        `#!python skip_nonproxiable is True` in which case `obj` is \\\n        returned directly.\n    Raises:\n        NonProxiableTypeError: If `obj` is a non-proxiable type. This\n            behavior can be overridden by setting\n            `#!python skip_nonproxiable=True`.\n    \"\"\"\nif isinstance(obj, _NON_PROXIABLE_TYPES):\nif skip_nonproxiable:\n# MyPy raises the following error which is not correct:\n#     Incompatible return value type (got \"Optional[bool]\",\n#     expected \"Optional[Proxy[T]]\")  [return-value]\nreturn obj  # type: ignore[return-value]\nelse:\nraise NonProxiableTypeError(\nf'Object of {type(obj)} is not proxiable.',\n)\nwith Timer() as timer:\nkey = self.put(obj, serializer=serializer, **kwargs)\nfactory: StoreFactory[ConnectorT, T] = StoreFactory(\nkey,\nstore_config=self.config(),\ndeserializer=deserializer,\nevict=evict,\nmetrics=self.metrics is not None,\n)\nproxy = Proxy(factory)\nif self.metrics is not None:\nself.metrics.add_time('store.proxy', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): PROXY {key} in '\nf'{timer.elapsed_ms:.3f} ms',\n)\nreturn proxy\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.proxy_batch","title":"proxy_batch()","text":"<pre><code>proxy_batch(\nobjs: Sequence[T | NonProxiableT],\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nskip_nonproxiable: bool = False,\n**kwargs: Any\n) -&gt; list[Proxy[T] | NonProxiableT]\n</code></pre> <p>Create proxies that will resolve to an object in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[T | NonProxiableT]</code>)         \u2013 <p>The objects to place in store and return a proxies for.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If a proxy should evict its object once resolved.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optionally override the default serializer for the store instance.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optionally override the default deserializer for the store instance.</p> </li> <li> skip_nonproxiable             (<code>bool</code>)         \u2013 <p>Return non-proxiable types (e.g., built-in constants like <code>bool</code> or <code>None</code>) rather than raising a <code>NonProxiableTypeError</code>.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional keyword arguments to pass to <code>Connector.put_batch()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Proxy[T] | NonProxiableT]</code>         \u2013 <p>A list of proxies of each object or the object itself if said             object is not proxiable and <code>skip_nonproxiable is True</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NonProxiableTypeError</code>           \u2013         <p>If <code>obj</code> is a non-proxiable type. This behavior can be overridden by setting <code>skip_nonproxiable=True</code>.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def proxy_batch(  # type: ignore[misc]\nself,\nobjs: Sequence[T | NonProxiableT],\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nskip_nonproxiable: bool = False,\n**kwargs: Any,\n) -&gt; list[Proxy[T] | NonProxiableT]:\n\"\"\"Create proxies that will resolve to an object in the store.\n    Args:\n        objs: The objects to place in store and return a proxies for.\n        evict: If a proxy should evict its object once resolved.\n        serializer: Optionally override the default serializer for the\n            store instance.\n        deserializer: Optionally override the default deserializer for the\n            store instance.\n        skip_nonproxiable: Return non-proxiable types (e.g., built-in\n            constants like `bool` or `None`) rather than raising a\n            [`NonProxiableTypeError`][proxystore.store.exceptions.NonProxiableTypeError].\n        kwargs: Additional keyword arguments to pass to\n            [`Connector.put_batch()`][proxystore.connectors.connector.Connector.put_batch].\n    Returns:\n        A list of proxies of each object or the object itself if said \\\n        object is not proxiable and `#!python skip_nonproxiable is True`.\n    Raises:\n        NonProxiableTypeError: If `obj` is a non-proxiable type. This\n            behavior can be overridden by setting\n            `#!python skip_nonproxiable=True`.\n    \"\"\"\nwith Timer() as timer:\n# Find if there are non-proxiable types and if that's okay\nnon_proxiable: list[tuple[int, Any]] = []\nfor i, obj in enumerate(objs):\nif isinstance(obj, _NON_PROXIABLE_TYPES):\nnon_proxiable.append((i, obj))\nif len(non_proxiable) &gt; 0 and not skip_nonproxiable:\nraise NonProxiableTypeError(\nf'Input sequence contains {len(non_proxiable)} '\n'objects that are not proxiable.',\n)\n# Pop non-proxiable types so we can batch proxy the proxiable ones\nnon_proxiable_indicies = [i for i, _ in non_proxiable]\nproxiable_objs = [\nobj\nfor i, obj in enumerate(objs)\nif i not in non_proxiable_indicies\n]\nkeys = self.put_batch(\nproxiable_objs,\nserializer=serializer,\n**kwargs,\n)\nproxies: list[Proxy[T]] = [\nself.proxy_from_key(\nkey,\nevict=evict,\ndeserializer=deserializer,\n)\nfor key in keys\n]\n# Put non-proxiable objects back in their original positions.\n# The indices of non_proxiable must still be sorted\nfor original_index, original_object in non_proxiable:\nproxies.insert(original_index, original_object)\nif self.metrics is not None:\nself.metrics.add_time('store.proxy_batch', keys, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): PROXY_BATCH ({len(proxies)} items) '\nf'in {timer.elapsed_ms:.3f} ms',\n)\nreturn cast(List[Union[Proxy[T], NonProxiableT]], proxies)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.proxy_from_key","title":"proxy_from_key()","text":"<pre><code>proxy_from_key(\nkey: ConnectorKeyT,\n*,\nevict: bool = False,\ndeserializer: DeserializerT | None = None\n) -&gt; Proxy[T]\n</code></pre> <p>Create a proxy that will resolve to an object already in the store.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>The key associated with an object already in the store.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If the proxy should evict the object once resolved.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optionally override the default deserializer for the store instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Proxy[T]</code>         \u2013 <p>A proxy of the object.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def proxy_from_key(\nself,\nkey: ConnectorKeyT,\n*,\nevict: bool = False,\ndeserializer: DeserializerT | None = None,\n) -&gt; Proxy[T]:\n\"\"\"Create a proxy that will resolve to an object already in the store.\n    Args:\n        key: The key associated with an object already in the store.\n        evict: If the proxy should evict the object once resolved.\n        deserializer: Optionally override the default deserializer for the\n            store instance.\n    Returns:\n        A proxy of the object.\n    \"\"\"\nfactory: StoreFactory[ConnectorT, T] = StoreFactory(\nkey,\nstore_config=self.config(),\ndeserializer=deserializer,\nevict=evict,\nmetrics=self.metrics is not None,\n)\nlogger.debug(f'Store(name=\"{self.name}\"): PROXY_FROM_KEY {key}')\nreturn Proxy(factory)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.locked_proxy","title":"locked_proxy()","text":"<pre><code>locked_proxy(\nobj: T | NonProxiableT,\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nskip_nonproxiable: bool = True,\n**kwargs: Any\n) -&gt; ProxyLocker[T] | NonProxiableT\n</code></pre> <p>Proxy an object and return <code>ProxyLocker</code>.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T | NonProxiableT</code>)         \u2013 <p>The object to place in store and return a proxy for.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If the proxy should evict the object once resolved.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optionally override the default serializer for the store instance.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optionally override the default deserializer for the store instance.</p> </li> <li> skip_nonproxiable             (<code>bool</code>)         \u2013 <p>Return non-proxiable types (e.g., built-in constants like <code>bool</code> or <code>None</code>) rather than raising a <code>NonProxiableTypeError</code>.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional keyword arguments to pass to <code>Connector.put()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ProxyLocker[T] | NonProxiableT</code>         \u2013 <p>A proxy wrapped in a             <code>ProxyLocker</code> unless <code>obj</code> is a             non-proxiable type <code>skip_nonproxiable is True</code> in which             case <code>obj</code> is returned directly.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NonProxiableTypeError</code>           \u2013         <p>If <code>obj</code> is a non-proxiable type. This behavior can be overridden by setting <code>skip_nonproxiable=True</code>.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def locked_proxy(\nself,\nobj: T | NonProxiableT,\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nskip_nonproxiable: bool = True,\n**kwargs: Any,\n) -&gt; ProxyLocker[T] | NonProxiableT:\n\"\"\"Proxy an object and return [`ProxyLocker`][proxystore.proxy.ProxyLocker].\n    Args:\n        obj: The object to place in store and return a proxy for.\n        evict: If the proxy should evict the object once resolved.\n        serializer: Optionally override the default serializer for the\n            store instance.\n        deserializer: Optionally override the default deserializer for the\n            store instance.\n        skip_nonproxiable: Return non-proxiable types (e.g., built-in\n            constants like `bool` or `None`) rather than raising a\n            [`NonProxiableTypeError`][proxystore.store.exceptions.NonProxiableTypeError].\n        kwargs: Additional keyword arguments to pass to\n            [`Connector.put()`][proxystore.connectors.connector.Connector.put].\n    Returns:\n        A proxy wrapped in a \\\n        [`ProxyLocker`][proxystore.proxy.ProxyLocker] unless `obj` is a \\\n        non-proxiable type `#!python skip_nonproxiable is True` in which \\\n        case `obj` is returned directly.\n    Raises:\n        NonProxiableTypeError: If `obj` is a non-proxiable type. This\n            behavior can be overridden by setting\n            `#!python skip_nonproxiable=True`.\n    \"\"\"\npossible_proxy = self.proxy(\nobj,\nevict=evict,\nserializer=serializer,\ndeserializer=deserializer,\nskip_nonproxiable=skip_nonproxiable,\n**kwargs,\n)\nif isinstance(possible_proxy, Proxy):\nreturn ProxyLocker(possible_proxy)\nreturn possible_proxy\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.put","title":"put()","text":"<pre><code>put(\nobj: Any,\n*,\nserializer: SerializerT | None = None,\n**kwargs: Any\n) -&gt; ConnectorKeyT\n</code></pre> <p>Put an object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>Object to put in the store.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optionally override the default serializer for the store instance.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional keyword arguments to pass to <code>Connector.put()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorKeyT</code>         \u2013 <p>A key which can be used to retrieve the object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If the output of <code>serializer</code> is not bytes.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def put(\nself,\nobj: Any,\n*,\nserializer: SerializerT | None = None,\n**kwargs: Any,\n) -&gt; ConnectorKeyT:\n\"\"\"Put an object in the store.\n    Args:\n        obj: Object to put in the store.\n        serializer: Optionally override the default serializer for the\n            store instance.\n        kwargs: Additional keyword arguments to pass to\n            [`Connector.put()`][proxystore.connectors.connector.Connector.put].\n    Returns:\n        A key which can be used to retrieve the object.\n    Raises:\n        TypeError: If the output of `serializer` is not bytes.\n    \"\"\"\ntimer = Timer()\ntimer.start()\nwith Timer() as serialize_timer:\nif serializer is not None:\nobj = serializer(obj)\nelse:\nobj = self.serializer(obj)\nif not isinstance(obj, bytes):\nraise TypeError('Serializer must produce bytes.')\nwith Timer() as connector_timer:\nkey = self.connector.put(obj, **kwargs)\ntimer.stop()\nif self.metrics is not None:\nctime = connector_timer.elapsed_ns\nstime = serialize_timer.elapsed_ns\nself.metrics.add_attribute('store.put.object_size', key, len(obj))\nself.metrics.add_time('store.put.serialize', key, stime)\nself.metrics.add_time('store.put.connector', key, ctime)\nself.metrics.add_time('store.put', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): PUT {key} in '\nf'{timer.elapsed_ms:.3f} ms',\n)\nreturn key\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.put_batch","title":"put_batch()","text":"<pre><code>put_batch(\nobjs: Sequence[Any],\n*,\nserializer: SerializerT | None = None,\n**kwargs: Any\n) -&gt; list[ConnectorKeyT]\n</code></pre> <p>Put multiple objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[Any]</code>)         \u2013 <p>Sequence of objects to put in the store.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optionally override the default serializer for the store instance.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional keyword arguments to pass to <code>Connector.put_batch()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ConnectorKeyT]</code>         \u2013 <p>A list of keys which can be used to retrieve the objects.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If the output of <code>serializer</code> is not bytes.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def put_batch(\nself,\nobjs: Sequence[Any],\n*,\nserializer: SerializerT | None = None,\n**kwargs: Any,\n) -&gt; list[ConnectorKeyT]:\n\"\"\"Put multiple objects in the store.\n    Args:\n        objs: Sequence of objects to put in the store.\n        serializer: Optionally override the default serializer for the\n            store instance.\n        kwargs: Additional keyword arguments to pass to\n            [`Connector.put_batch()`][proxystore.connectors.connector.Connector.put_batch].\n    Returns:\n        A list of keys which can be used to retrieve the objects.\n    Raises:\n        TypeError: If the output of `serializer` is not bytes.\n    \"\"\"\ntimer = Timer()\ntimer.start()\ndef _serialize(obj: Any) -&gt; bytes:\nif serializer is not None:\nobj = serializer(obj)\nelse:\nobj = self.serializer(obj)\nif not isinstance(obj, bytes):\nraise TypeError('Serializer must produce bytes.')\nreturn obj\nwith Timer() as serialize_timer:\n_objs = list(map(_serialize, objs))\nwith Timer() as connector_timer:\nkeys = self.connector.put_batch(_objs, **kwargs)\ntimer.stop()\nif self.metrics is not None:\nctime = connector_timer.elapsed_ns\nstime = serialize_timer.elapsed_ns\nsizes = sum(len(obj) for obj in _objs)\nself.metrics.add_attribute(\n'store.put_batch.object_sizes',\nkeys,\nsizes,\n)\nself.metrics.add_time('store.put_batch.serialize', keys, stime)\nself.metrics.add_time('store.put_batch.connector', keys, ctime)\nself.metrics.add_time('store.put_batch', keys, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): PUT_BATCH ({len(keys)} items) in '\nf'{timer.elapsed_ms:.3f} ms',\n)\nreturn keys\n</code></pre>"},{"location":"api/store/cache/","title":"proxystore.store.cache","text":"<code>proxystore/store/cache.py</code> <p>Simple Cache Implementation.</p>"},{"location":"api/store/cache/#proxystore.store.cache.LRUCache","title":"LRUCache","text":"<pre><code>LRUCache(maxsize: int = 16) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[KeyT, ValueT]</code></p> <p>Simple LRU Cache.</p> <p>Parameters:</p> <ul> <li> maxsize             (<code>int</code>)         \u2013 <p>Maximum number of value to cache.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>maxsize &lt;= 0</code>.</p> </li> </ul> Source code in <code>proxystore/store/cache.py</code> <pre><code>def __init__(self, maxsize: int = 16) -&gt; None:\nif maxsize &lt; 0:\nraise ValueError('Cache size must by &gt;= 0')\nself.maxsize = maxsize\nself.data: dict[KeyT, ValueT] = {}\nself.lru: list[KeyT] = []\n# Count hits/misses\nself.hits = 0\nself.misses = 0\n</code></pre>"},{"location":"api/store/cache/#proxystore.store.cache.LRUCache.evict","title":"evict()","text":"<pre><code>evict(key: KeyT) -&gt; None\n</code></pre> <p>Evict key from cache.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def evict(self, key: KeyT) -&gt; None:\n\"\"\"Evict key from cache.\"\"\"\nif key in self.data:\ndel self.data[key]\nself.lru.remove(key)\n</code></pre>"},{"location":"api/store/cache/#proxystore.store.cache.LRUCache.exists","title":"exists()","text":"<pre><code>exists(key: KeyT) -&gt; bool\n</code></pre> <p>Check if key is in cache.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def exists(self, key: KeyT) -&gt; bool:\n\"\"\"Check if key is in cache.\"\"\"\nreturn key in self.data\n</code></pre>"},{"location":"api/store/cache/#proxystore.store.cache.LRUCache.get","title":"get()","text":"<pre><code>get(\nkey: KeyT, default: ValueT | None = None\n) -&gt; ValueT | None\n</code></pre> <p>Get value for key if it exists else returns default.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def get(self, key: KeyT, default: ValueT | None = None) -&gt; ValueT | None:\n\"\"\"Get value for key if it exists else returns default.\"\"\"\nif self.exists(key):\n# Move to front b/c most recently used\nself.hits += 1\nself.lru.remove(key)\nself.lru.insert(0, key)\nreturn self.data[key]\nelse:\nself.misses += 1\nreturn default\n</code></pre>"},{"location":"api/store/cache/#proxystore.store.cache.LRUCache.set","title":"set()","text":"<pre><code>set(key: KeyT, value: ValueT) -&gt; None\n</code></pre> <p>Set key to value.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def set(self, key: KeyT, value: ValueT) -&gt; None:\n\"\"\"Set key to value.\"\"\"\nif self.maxsize == 0:\nreturn\nif len(self.data) &gt;= self.maxsize:\nlru_key = self.lru.pop()\ndel self.data[lru_key]\nself.lru.insert(0, key)\nself.data[key] = value\n</code></pre>"},{"location":"api/store/endpoint/","title":"proxystore.store.endpoint","text":"<code>proxystore/store/endpoint.py</code> <p>EndpointStore Implementation.</p>"},{"location":"api/store/endpoint/#proxystore.store.endpoint.EndpointStore","title":"EndpointStore","text":"<pre><code>EndpointStore(\nname: str,\nendpoints: Sequence[str | uuid.UUID],\nproxystore_dir: str | None = None,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[EndpointConnector]</code></p> <p>Store wrapper for ProxyStore Endpoints.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance (default: None).</p> </li> <li> endpoints             (<code>Sequence[str | uuid.UUID]</code>)         \u2013 <p>Sequence of valid and running endpoint UUIDs to use. At least one of these endpoints must be accessible by this process.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to [<code>home_dir()</code>[proxystore.utils.home_dir].</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/endpoint.py</code> <pre><code>def __init__(\nself,\nname: str,\nendpoints: Sequence[str | uuid.UUID],\nproxystore_dir: str | None = None,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The EndpointStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = EndpointConnector(\nendpoints=endpoints,\nproxystore_dir=proxystore_dir,\n)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/exceptions/","title":"proxystore.store.exceptions","text":"<code>proxystore/store/exceptions.py</code> <p>Exceptions for Stores.</p>"},{"location":"api/store/exceptions/#proxystore.store.exceptions.StoreError","title":"StoreError","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception class for store errors.</p>"},{"location":"api/store/exceptions/#proxystore.store.exceptions.StoreExistsError","title":"StoreExistsError","text":"<p>         Bases: <code>StoreError</code></p> <p>Exception raised when a store with the same name already exists.</p>"},{"location":"api/store/exceptions/#proxystore.store.exceptions.ProxyStoreFactoryError","title":"ProxyStoreFactoryError","text":"<p>         Bases: <code>StoreError</code></p> <p>Exception raised when a proxy was not created by a Store.</p>"},{"location":"api/store/exceptions/#proxystore.store.exceptions.ProxyResolveMissingKeyError","title":"ProxyResolveMissingKeyError","text":"<pre><code>ProxyResolveMissingKeyError(\nkey: base.ConnectorKeyT,\nstore_type: type[base.Store[Any]],\nstore_name: str,\n) -&gt; None\n</code></pre> <p>         Bases: <code>Exception</code></p> <p>Exception raised when the key associated with a proxy is missing.</p> <p>Init ProxyResolveMissingKeyError.</p> <p>Parameters:</p> <ul> <li> key             (<code>base.ConnectorKeyT</code>)         \u2013 <p>Key associated with target object that could not be found in the store.</p> </li> <li> store_type             (<code>type[base.Store[Any]]</code>)         \u2013 <p>Type of store that the key could not be found in.</p> </li> <li> store_name             (<code>str</code>)         \u2013 <p>Name of store that the key could not be found in.</p> </li> </ul> Source code in <code>proxystore/store/exceptions.py</code> <pre><code>def __init__(\nself,\nkey: base.ConnectorKeyT,\nstore_type: type[base.Store[Any]],\nstore_name: str,\n) -&gt; None:\n\"\"\"Init ProxyResolveMissingKeyError.\n    Args:\n        key: Key associated with target object that could not be found in\n            the store.\n        store_type: Type of store that the key could not be found in.\n        store_name: Name of store that the key could not be found in.\n    \"\"\"\nself.key = key\nself.store_type = store_type\nself.store_name = store_name\nsuper().__init__(\nf\"Proxy cannot resolve target object with key='{self.key}' \"\nf\"from {self.store_type.__name__}(name='{self.store_name}'): \"\n'store returned NoneType with key.',\n)\n</code></pre>"},{"location":"api/store/exceptions/#proxystore.store.exceptions.NonProxiableTypeError","title":"NonProxiableTypeError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when proxying an unproxiable type.</p>"},{"location":"api/store/file/","title":"proxystore.store.file","text":"<code>proxystore/store/file.py</code> <p>FileStore Implementation.</p>"},{"location":"api/store/file/#proxystore.store.file.FileStore","title":"FileStore","text":"<pre><code>FileStore(\nname: str,\nstore_dir: str,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[FileConnector]</code></p> <p>Store wrapper for shared filesystems.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> store_dir             (<code>str</code>)         \u2013 <p>Path to directory to store data in. Note this directory will be deleted upon closing the store.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/file.py</code> <pre><code>def __init__(\nself,\nname: str,\nstore_dir: str,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The FileStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = FileConnector(store_dir)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/globus/","title":"proxystore.store.globus","text":"<code>proxystore/store/globus.py</code> <p>GlobusStore Implementation.</p>"},{"location":"api/store/globus/#proxystore.store.globus.GlobusStore","title":"GlobusStore","text":"<pre><code>GlobusStore(\nname: str,\nendpoints: GlobusEndpoints\n| list[GlobusEndpoint]\n| dict[str, dict[str, str]],\npolling_interval: int = 1,\nsync_level: int\n| Literal[\n\"exists\", \"size\", \"mtime\", \"checksum\"\n] = \"mtime\",\ntimeout: int = 60,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[GlobusConnector]</code></p> <p>Store wrapper for Globus transfers.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> endpoints             (<code>GlobusEndpoints | list[GlobusEndpoint] | dict[str, dict[str, str]]</code>)         \u2013 <p>Globus endpoints to keep in sync. If passed as a <code>dict</code>, the dictionary must match the format expected by <code>GlobusEndpoints.from_dict()</code>.</p> </li> <li> polling_interval             (<code>int</code>)         \u2013 <p>Interval in seconds to check if Globus tasks have finished.</p> </li> <li> sync_level             (<code>int | Literal['exists', 'size', 'mtime', 'checksum']</code>)         \u2013 <p>Globus transfer sync level.</p> </li> <li> timeout             (<code>int</code>)         \u2013 <p>Timeout in seconds for waiting on Globus tasks.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/globus.py</code> <pre><code>def __init__(\nself,\nname: str,\nendpoints: GlobusEndpoints\n| list[GlobusEndpoint]\n| dict[str, dict[str, str]],\npolling_interval: int = 1,\nsync_level: int\n| Literal['exists', 'size', 'mtime', 'checksum'] = 'mtime',\ntimeout: int = 60,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The GlobusStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = GlobusConnector(\nendpoints=endpoints,\npolling_interval=polling_interval,\nsync_level=sync_level,\ntimeout=timeout,\n)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/local/","title":"proxystore.store.local","text":"<code>proxystore/store/local.py</code> <p>LocalStore Implementation.</p>"},{"location":"api/store/local/#proxystore.store.local.LocalStore","title":"LocalStore","text":"<pre><code>LocalStore(\nname: str,\nstore_dict: dict[LocalKey, bytes] | None = None,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[LocalConnector]</code></p> <p>Store wrapper for local in-process storage.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> store_dict             (<code>dict[LocalKey, bytes] | None</code>)         \u2013 <p>Dictionary to store data in. If not specified, a new empty dict will be generated.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/local.py</code> <pre><code>def __init__(\nself,\nname: str,\nstore_dict: dict[LocalKey, bytes] | None = None,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The LocalStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = LocalConnector(store_dict)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/metrics/","title":"proxystore.store.metrics","text":"<code>proxystore/store/metrics.py</code> <p>Utilities for recording Store operation metrics.</p> <p>See the Performance Guide to learn more about interacting with metrics recorded for <code>Store</code> operations.</p>"},{"location":"api/store/metrics/#proxystore.store.metrics.KeyT","title":"KeyT  <code>module-attribute</code>","text":"<pre><code>KeyT = Union[ConnectorKeyT, Sequence[ConnectorKeyT]]\n</code></pre> <p>Key types supported by <code>StoreMetrics</code>.</p>"},{"location":"api/store/metrics/#proxystore.store.metrics.ProxyT","title":"ProxyT  <code>module-attribute</code>","text":"<pre><code>ProxyT = Union[Proxy[Any], Sequence[Proxy[Any]]]\n</code></pre> <p>Proxy types supported by <code>StoreMetrics</code>.</p> <p>When a <code>ProxyT</code> is passed, the keys are extracted from the proxies.</p>"},{"location":"api/store/metrics/#proxystore.store.metrics.TimeStats","title":"TimeStats  <code>dataclass</code>","text":"<p>Tracks time statistics of a reoccuring event.</p> <p>Attributes:</p> <ul> <li> count             (<code>int</code>)         \u2013 <p>Number of times this event as occurred.</p> </li> <li> avg_time_ms             (<code>float</code>)         \u2013 <p>Average time in milliseconds of the event.</p> </li> <li> min_time_ms             (<code>float</code>)         \u2013 <p>Minimum time in milliseconds of all event occurrences.</p> </li> <li> max_time_ms             (<code>float</code>)         \u2013 <p>Maximum time in milliseconds of all event occurrences.</p> </li> <li> last_time_ms             (<code>float</code>)         \u2013 <p>Time in milliseconds of the most recent event occurrence.</p> </li> <li> last_timestamp             (<code>float</code>)         \u2013 <p>The UNIX timestamp (seconds) of when the last event time was recorded.</p> </li> </ul>"},{"location":"api/store/metrics/#proxystore.store.metrics.TimeStats.as_dict","title":"as_dict()","text":"<pre><code>as_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the dataclass to a <code>dict</code>.</p> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Convert the dataclass to a [`dict`][dict].\"\"\"\nreturn dataclasses.asdict(self)\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.Metrics","title":"Metrics  <code>dataclass</code>","text":"<p>Records metrics and attributes for events.</p> <p>Attributes:</p> <ul> <li> attributes             (<code>dict[str, Any]</code>)         \u2013 <p>A mapping of attributes to their values.</p> </li> <li> counters             (<code>dict[str, int]</code>)         \u2013 <p>A mapping of counter names to the integer value of the counter.</p> </li> <li> times             (<code>dict[str, TimeStats]</code>)         \u2013 <p>A mapping of events to a summary of the statistics recorded over occurrences of that event.</p> </li> </ul>"},{"location":"api/store/metrics/#proxystore.store.metrics.Metrics.as_dict","title":"as_dict()","text":"<pre><code>as_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the dataclass to a <code>dict</code>.</p> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Convert the dataclass to a [`dict`][dict].\"\"\"\nreturn dataclasses.asdict(self)\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics","title":"StoreMetrics","text":"<pre><code>StoreMetrics() -&gt; None\n</code></pre> <p>Record and query metrics on <code>Store</code> operations.</p> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def __init__(self) -&gt; None:\nself._metrics: dict[int, Metrics] = defaultdict(Metrics)\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics.add_attribute","title":"add_attribute()","text":"<pre><code>add_attribute(name: str, key: KeyT, value: Any) -&gt; None\n</code></pre> <p>Add an attribute associated with the key.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of attribute.</p> </li> <li> key             (<code>KeyT</code>)         \u2013 <p>Key to add attribute to.</p> </li> <li> value             (<code>Any</code>)         \u2013 <p>Attribute value.</p> </li> </ul> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def add_attribute(self, name: str, key: KeyT, value: Any) -&gt; None:\n\"\"\"Add an attribute associated with the key.\n    Args:\n        name: Name of attribute.\n        key: Key to add attribute to.\n        value: Attribute value.\n    \"\"\"\nself._metrics[_hash_key(key)].attributes[name] = value\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics.add_counter","title":"add_counter()","text":"<pre><code>add_counter(name: str, key: KeyT, value: int) -&gt; None\n</code></pre> <p>Add to a counter.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of counter.</p> </li> <li> key             (<code>KeyT</code>)         \u2013 <p>Key associated with the counter.</p> </li> <li> value             (<code>int</code>)         \u2013 <p>Amount to increment counter by.</p> </li> </ul> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def add_counter(self, name: str, key: KeyT, value: int) -&gt; None:\n\"\"\"Add to a counter.\n    Args:\n        name: Name of counter.\n        key: Key associated with the counter.\n        value: Amount to increment counter by.\n    \"\"\"\ncounters = self._metrics[_hash_key(key)].counters\nif name in counters:\ncounters[name] += value\nelse:\ncounters[name] = value\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics.add_time","title":"add_time()","text":"<pre><code>add_time(name: str, key: KeyT, time_ns: int) -&gt; None\n</code></pre> <p>Record a new time for an event.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Event or operation the time is for.</p> </li> <li> key             (<code>KeyT</code>)         \u2013 <p>Key associated with the event.</p> </li> <li> time_ns             (<code>int</code>)         \u2013 <p>The time in nanoseconds of the event.</p> </li> </ul> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def add_time(self, name: str, key: KeyT, time_ns: int) -&gt; None:\n\"\"\"Record a new time for an event.\n    Args:\n        name: Event or operation the time is for.\n        key: Key associated with the event.\n        time_ns: The time in nanoseconds of the event.\n    \"\"\"\ntimes = self._metrics[_hash_key(key)].times\nif name not in times:\ntimes[name] = TimeStats()\ntimes[name].add_time(time_ns / 1000)\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics.aggregate_times","title":"aggregate_times()","text":"<pre><code>aggregate_times() -&gt; dict[str, TimeStats]\n</code></pre> <p>Aggregate time statistics over all keys.</p> <p>Returns:</p> <ul> <li> <code>dict[str, TimeStats]</code>         \u2013 <p>Dictionary mapping event names to the time statistics aggregated             for that event.</p> </li> </ul> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def aggregate_times(self) -&gt; dict[str, TimeStats]:\n\"\"\"Aggregate time statistics over all keys.\n    Returns:\n        Dictionary mapping event names to the time statistics aggregated \\\n        for that event.\n    \"\"\"\ntimes: dict[str, TimeStats] = defaultdict(TimeStats)\nfor metrics in self._metrics.values():\nfor key, value in metrics.times.items():\ntimes[key] += value\nreturn times\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics.get_metrics","title":"get_metrics()","text":"<pre><code>get_metrics(key_or_proxy: KeyT | ProxyT) -&gt; Metrics | None\n</code></pre> <p>Get the metrics associated with a key.</p> <p>Parameters:</p> <ul> <li> key_or_proxy             (<code>KeyT | ProxyT</code>)         \u2013 <p>Key to get associated metrics. If a proxy or sequence of proxies, the key(s) will be extracted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Metrics | None</code>         \u2013 <p>Metrics associated with the key or <code>None</code> if the key does not             exist.</p> </li> </ul> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def get_metrics(self, key_or_proxy: KeyT | ProxyT) -&gt; Metrics | None:\n\"\"\"Get the metrics associated with a key.\n    Args:\n        key_or_proxy: Key to get associated metrics. If a proxy or\n            sequence of proxies, the key(s) will be extracted.\n    Returns:\n        Metrics associated with the key or `None` if the key does not \\\n        exist.\n    \"\"\"\nkey_hash = _hash_key(key_or_proxy)\nif key_hash in self._metrics:\nreturn copy.deepcopy(self._metrics[key_hash])\nreturn None\n</code></pre>"},{"location":"api/store/multi/","title":"proxystore.store.multi","text":"<code>proxystore/store/multi.py</code> <p>MultiStore Implementation.</p>"},{"location":"api/store/multi/#proxystore.store.multi.MultiStore","title":"MultiStore","text":"<pre><code>MultiStore(\nname: str,\nconnectors: dict[str, tuple[Connector[Any], Policy]],\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[MultiConnector]</code></p> <p>Store wrapper for <code>MultiConnector</code>.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> connectors             (<code>dict[str, tuple[Connector[Any], Policy]]</code>)         \u2013 <p>Mapping of names to tuples of a <code>Connector</code> and <code>Policy</code>.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/multi.py</code> <pre><code>def __init__(\nself,\nname: str,\nconnectors: dict[str, tuple[Connector[Any], Policy]],\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The MultiStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = MultiConnector(connectors)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/redis/","title":"proxystore.store.redis","text":"<code>proxystore/store/redis.py</code> <p>RedisStore Implementation.</p>"},{"location":"api/store/redis/#proxystore.store.redis.RedisStore","title":"RedisStore","text":"<pre><code>RedisStore(\nname: str,\nhostname: str,\nport: int,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[RedisConnector]</code></p> <p>Store wrapper for Redis servers.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> hostname             (<code>str</code>)         \u2013 <p>Redis server hostname.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Redis server port.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/redis.py</code> <pre><code>def __init__(\nself,\nname: str,\nhostname: str,\nport: int,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The RedisStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = RedisConnector(hostname, port)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/utils/","title":"proxystore.store.utils","text":"<code>proxystore/store/utils.py</code> <p>Store utilities.</p>"},{"location":"api/store/utils/#proxystore.store.utils.ConnectorKeyT","title":"ConnectorKeyT  <code>module-attribute</code>","text":"<pre><code>ConnectorKeyT = Tuple[Any, Ellipsis]\n</code></pre> <p>Connector key type alias.</p>"},{"location":"api/store/utils/#proxystore.store.utils.get_key","title":"get_key()","text":"<pre><code>get_key(proxy: Proxy[T]) -&gt; ConnectorKeyT\n</code></pre> <p>Extract the key from the proxy's factory.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>Proxy[T]</code>)         \u2013 <p>Proxy instance to get key from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorKeyT</code>         \u2013 <p>The key, a NamedTuple unique to the         <code>Store</code> that created the proxy..</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ProxyStoreFactoryError</code>           \u2013         <p>If the proxy's factory is not an instance of <code>StoreFactory</code>.</p> </li> </ul> Source code in <code>proxystore/store/utils.py</code> <pre><code>def get_key(proxy: Proxy[T]) -&gt; ConnectorKeyT:\n\"\"\"Extract the key from the proxy's factory.\n    Args:\n        proxy: Proxy instance to get key from.\n    Returns:\n        The key, a NamedTuple unique to the \\\n        [`Store`][proxystore.store.base.Store] that created the proxy..\n    Raises:\n        ProxyStoreFactoryError: If the proxy's factory is not an instance of\n            [`StoreFactory`][proxystore.store.base.StoreFactory].\n    \"\"\"\nfactory = proxy.__factory__\nif isinstance(factory, base.StoreFactory):\nreturn factory.key\nelse:\nraise ProxyStoreFactoryError(\n'The proxy must contain a factory with type '\nf'{type(base.StoreFactory).__name__}. {type(factory).__name__} '\n'is not supported.',\n)\n</code></pre>"},{"location":"api/store/utils/#proxystore.store.utils.resolve_async","title":"resolve_async()","text":"<pre><code>resolve_async(proxy: Proxy[T]) -&gt; None\n</code></pre> <p>Begin resolving proxy asynchronously.</p> <p>Useful if the user knows a proxy will be needed soon and wants to resolve the proxy concurrently with other computation.</p> <pre><code>from proxystore.store.utils import resolve_async\nresolve_async(my_proxy)\ncomputation_without_proxy(...)\n# p is hopefully resolved\ncomputation_with_proxy(my_proxy, ...)\n</code></pre> Note <p>The asynchronous resolving functionality is implemented by <code>StoreFactory</code>. Factories that are not of this type will error when used with this function.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>Proxy[T]</code>)         \u2013 <p>Proxy instance to begin asynchronously resolving.</p> </li> </ul> Source code in <code>proxystore/store/utils.py</code> <pre><code>def resolve_async(proxy: Proxy[T]) -&gt; None:\n\"\"\"Begin resolving proxy asynchronously.\n    Useful if the user knows a proxy will be needed soon and wants to\n    resolve the proxy concurrently with other computation.\n    ```python\n    from proxystore.store.utils import resolve_async\n    resolve_async(my_proxy)\n    computation_without_proxy(...)\n    # p is hopefully resolved\n    computation_with_proxy(my_proxy, ...)\n    ```\n    Note:\n        The asynchronous resolving functionality is implemented\n        by [`StoreFactory`][proxystore.store.base.StoreFactory]. Factories that\n        are not of this type will error when used with this function.\n    Args:\n        proxy: Proxy instance to begin asynchronously resolving.\n    \"\"\"\nif not is_resolved(proxy):\nproxy.__factory__.resolve_async()\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":"<p>Figure 1: High-level overview of how the ProxyStore components fit together.</p> <p>ProxyStore is composed of three main components: the <code>Proxy</code>, <code>Connector</code>, and <code>Store</code>.</p> <p>The <code>Proxy</code> model provides pass-by-reference semantics and just-in-time object resolution transparently to consumers.</p> <p>The <code>Connector</code> is a <code>Protocol</code> that defines the low-level interface to a mediated communication channel or object store. Many <code>Connector</code> implementations are provided in the <code>proxystore.connectors</code> module, and users can easily create their own.</p> <p>The <code>Store</code> is a high-level abstraction of an object store and the intended means by which an application uses ProxyStore. The <code>Store</code> is initialized with a <code>Connector</code> and provides extra functionality like caching and serialization. Most important is that the <code>.proxy()</code> method is provided which can produce a <code>Proxy</code> of an arbitrary object put in the store.</p>"},{"location":"concepts/connector/","title":"Connector","text":"<p>The <code>Connector</code> is a <code>Protocol</code> that defines the low-level interface to a mediated communication channel or object store. The <code>Connector</code> methods operate of <code>bytes</code> of data and keys which are tuples of metadata that can identify a unique object.</p> <p>The protocol is as follows: Connector Protocol<pre><code>KeyT = TypeVar('KeyT', bound=NamedTuple)\nclass Connector(Protocol[KeyT]):\ndef close(self) -&gt; None: ...\ndef config(self) -&gt; dict[str, Any]: ...\ndef from_config(self, config: dict[str, Any]) -&gt; Connector[KeyT]: ...\ndef evict(self, key: KeyT) -&gt; None: ...\ndef exists(self, key: KeyT) -&gt; bool: ...\ndef get(self, key: KeyT) -&gt; bytes | None: ...\ndef get_batch(self, Sequence[KeyT]) -&gt; list[bytes | None]: ...\ndef put(self, obj: bytes) -&gt; KeyT: ...\ndef put_batch(self, objs: Sequence[bytes]) -&gt; list[KeyT]: ...\n</code></pre> Implementing a custom <code>Connector</code> requires creating a class which implements the above methods. Note that the custom class does not need to inherit from <code>Connector</code> because it is a <code>Protocol</code>.</p> <p>Many <code>Connector</code> implementations are provided in the <code>proxystore.connectors</code> module, and users can easily create their own. A <code>Connector</code> instance is used by the <code>Store</code> to interact with the store.</p>"},{"location":"concepts/proxy/","title":"Proxy","text":"<p>Proxies are commonly used to add additional functionality to their target object or enforce assertions prior to forwarding operations to the target. For example, a proxy can wrap sensitive objects with access control or provide caching for expensive operations.</p> <p>Two valuable properties that a proxy can provide are transparency and lazy resolution. A transparent proxy behaves identically to its target object by forwarding all operations on itself to the target. For example, given a proxy <code>p</code> of an arbitrary object <code>v</code>, the types of <code>v</code> and <code>p</code> will be equivalent, i.e., <code>isinstance(p, type(v))</code> and any operation on <code>p</code> will invoke the corresponding operation on <code>v</code>.</p> <p>A lazy or virtual proxy provides just-in-time resolution of its target object. In this case, the proxy is initialized with a factory rather than the target object. A factory is any object that is callable like a function and returns the target object. The proxy is lazy in that it does not call the factory to retrieve the target until it is first accessed. This process is referred to as resolving the proxy. Functionally, proxies have both pass-by-reference and pass-by-value attributes. The eventual user of the proxied data gets a copy, but unnecessary copies are avoided when the proxy is passed between multiple functions.</p>"},{"location":"concepts/proxy/#creating-proxies","title":"Creating Proxies","text":"<pre><code>from proxystore.proxy import Proxy\ndef resolve_object(...):\n# Function that produces the object of interest\nreturn obj\np = Proxy(resolve_object)\n</code></pre> <p><code>resolve_object()</code> will be called when the proxy <code>p</code> does its just-in-time resolution, and then <code>p</code> will behave exactly like <code>obj</code>. A factory for a <code>Proxy</code> can be any callable object (i.e., object which implements <code>__call__</code>).</p> <p>Proxies are powerful because they can intercept and redefine functionality of an object while emulating the rest of the objects behavior.</p> <pre><code>import numpy as np\nfrom proxystore.proxy import Proxy\nx = np.array([1, 2, 3])\nclass MyFactory():\ndef __init__(self, obj):\nself.obj = obj\ndef __class__(self):\nreturn self.obj\np = Proxy(MyFactory(x))\nassert isinstance(p, Proxy) # (1)!\nassert isinstance(p, np.ndarray)\nassert np.array_equal(p, [1, 2, 3]) # (2)!\nassert np.sum(p) == 6\ny = x + p\nassert np.array_equal(y, [2, 4, 6])\n</code></pre> <ol> <li>A proxy is an instance of its wrapped object.</li> <li>The proxy can do everything the numpy array can.</li> </ol> <p>The ProxyStore <code>Proxy</code> is built on the proxy from <code>lazy-object-proxy</code> which intercepts all calls to the object's magic functions (<code>__func_name__()</code> functions) and forwards the calls to the factory that was passed to the proxy constructor to retrieve the object that should be wrapped.</p> <p>Generally, a proxy is only ever resolved once. However, when a proxy is serialized, only the factory is serialized, and when the proxy is deserialized again and used, the factory will be called again to resolve the object.</p>"},{"location":"concepts/proxy/#interacting-with-proxies","title":"Interacting with Proxies","text":"<p>While a proxy can be used just as one would normally use the proxy's target object, additional functions are provided for interacting with the proxy directly.</p> <pre><code>from proxystore import proxy\np = proxy.Proxy(...)\n# Check if a proxy has been resolved yet\nproxy.is_resolved(p)\n# Force a proxy to resolve itself\nproxy.resolve(p)\n# Extract the wrapped object from the proxy\nx = proxy.extract(p)\nassert not isinstance(x, proxy.Proxy)\n</code></pre>"},{"location":"concepts/store/","title":"Store","text":"<p>A <code>Store</code> is initialized with a <code>Connector</code> instance and provides extra functionality. Similar to the <code>Connector</code>, the <code>Store</code> exposes <code>evict</code>, <code>exist</code>, <code>get</code>, and <code>put</code> operations; however, these operations act on Python objects rather than <code>bytes</code>. The <code>Store</code> will (de)serialize objects accordingly before invoking the corresponding operation on the <code>Connector</code>. The <code>Store</code> also provides caching of operations to reduce communication costs, and objects are cached after deserialization to avoid duplicate deserialization.</p> <p>However, instead of the application directly invoking these aforementioned operations, the proxy method, also provided by the <code>Store</code>, is used. Calling <code>Store.proxy()</code> puts an object in the mediated channel and returns a proxy (see example below). The object is serialized before being put in the mediated channel, a factory with the key returned by the <code>Connector</code> and other information necessary to retrieve the object from the mediated channel is generated, and then a new proxy, internalized with the factory, is returned.</p> Base Store Usage<pre><code>from proxystore.connectors.redis import RedisConnector\nfrom proxystore.proxy import Proxy\nfrom proxystore.store import Store\nfrom proxystore.store import register_store\ndef my_function(x: MyDataType) -&gt; ...:\nassert isinstance(x, MyDataType)  # (1)!\n# More computation...\nstore = Store('my-store', RedisConnector(...)) # (2)!\nregister_store(store)  # (3)!\nmy_object = MyDataType(...) # (4)!\np = store.proxy(my_object)\nisinstance(p, Proxy)\nmy_function(p) # (5)!\n</code></pre> <ol> <li><code>x</code> is resolved from \"my-store\" on the first use of <code>x</code>.</li> <li>The <code>Connector</code> defines the low-level communication method used by the <code>Store</code>.</li> <li>Registering <code>store</code> globally enables proxies to reuse the same instance    to improve performance.</li> <li>Store the object and get a proxy.</li> <li>Always succeeds regardless of if <code>p</code> is the true object or a proxy.</li> </ol>"},{"location":"concepts/store/#asynchronous-resolving","title":"Asynchronous Resolving","text":"<p>It is common in distributed computation for inputs to functions executed remotely to not be needed immediately upon execution. Proxies created by a <code>Store</code> support asynchronous resolution to overlap communication and computation.</p> <pre><code>from proxystore.store.utils import resolve_async\ndef complex_function(large_proxied_input):\nresolve_async(large_proxied_input)\n# More computation...\n# First access to the proxy will not be as expensive because\n# of the asynchronous resolution\ncompute_input(large_proxied_input)\n</code></pre>"},{"location":"concepts/store/#caching","title":"Caching","text":"<p>The <code>Store</code> provides built in caching functionality. Caches are local to the Python process but will speed up the resolution when multiple proxies refer to the same object.</p> <pre><code>from proxystore.store import Store\n# Cache size of 16 is the default\nStore('mystore', connector=..., cache_size=16)\n</code></pre>"},{"location":"concepts/store/#transactional-guarantees","title":"Transactional Guarantees","text":"<p>ProxyStore is designed around optimizing the communication of ephemeral data (e.g., inputs and outputs of functions) which is typically write-once, read-many. Thus, ProxyStore does not provide <code>update</code> semantics on keys.</p>"},{"location":"concepts/store/#serialization","title":"Serialization","text":"<p>All <code>Store</code> operation uses ProxyStore's provided serialization utilities (<code>proxystore.serialize</code>) by default. However, the <code>Store</code> can be initialized with custom default serializers or deserializers of the form:</p> <p><pre><code>serializer = Callable[[Any], bytes]\ndeserializer = Callable[[bytes], Any]\n</code></pre> Most methods also support specifying an alternative serializer or deserializer to the default.</p> <p>In some cases, data may already be serialized in which case an identity function can be passed as the serializer/deserializer (e.g., <code>lambda x: x</code>). Implementing a custom serializer may be beneficial for complex structures where pickle/cloudpickle (the default serializers used by ProxyStore) are innefficient. E.g.,</p> <pre><code>import torch\nimport io\nfrom proxystore.serialize import serialize\nfrom proxystore.store import Store\ndef serialize_torch_model(obj: Any) -&gt; bytes:\nif isinstance(obj, torch.nn.Module):\nbuffer = io.BytesIO()\ntorch.save(model, buffer)\nreturn buffer.read()\nelse:\n# Fallback for unsupported types\nreturn serialize(obj)\nmymodel = torch.nn.Module()\nstore = Store(...)\nkey = store.put(mymodel, serializer=serialize_torch_model)\n</code></pre> <p>Rather than providing a custom serializer or deserializer to each method invocation, a default serializer and deserializer can be provided when initializing a new <code>Store</code>. See Issue #146 for further discussion on where custom serializers can be helpful.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#getting-started-for-local-development","title":"Getting Started for Local Development","text":"<p>We recommend using Tox to setup the development environment. This will create a new virtual environment with all of the required packages installed and ProxyStore installed in editable mode with the necessary extras options.</p> <pre><code>$ git clone https://github.com/proxystore/proxystore\n$ cd proxystore\n$ tox --devenv venv -e py310\n$ . venv/bin/activate\n</code></pre> <p>Warning</p> <p>Running Tox in a Conda environment is possible but it may conflict with Tox's ability to find the correct Python versions. E.g., if your Conda environment is Python 3.9, running <code>$ tox -e p38</code> may still use Python 3.9.</p> <p>To install manually: <pre><code>$ git clone https://github.com/proxystore/proxystore\n$ cd proxystore\n$ python -m venv venv\n$ . venv/bin/activate\n$ pip install -e .[dev,docs,endpoints,...]\n</code></pre></p>"},{"location":"contributing/#continuous-integration","title":"Continuous Integration","text":"<p>ProxyStore uses pre-commit and Tox for continuous integration (test, linting, etc.).</p>"},{"location":"contributing/#linting-and-type-checking-pre-commit","title":"Linting and Type Checking (pre-commit)","text":"<p>To use pre-commit, install the hook and then run against files.</p> <pre><code>$ pre-commit install\n$ pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#tests-tox","title":"Tests (tox)","text":"<p>The entire CI workflow can be run with <code>$ tox</code>. This will test against multiple versions of Python and can be slow.</p> <p>Module-level unit-test are located in the <code>tests/</code> directory and its structure is intended to match that of <code>proxystore/</code>. E.g. the tests for <code>proxystore/store/cache.py</code> are located in <code>tests/store/cache_test.py</code>; however, additional test files can be added as needed. Tests should be narrowly focused and target a single aspect of the code's functionality, tests should not test internal implementation details of the code, and tests should not be dependent on the order in which they are run.</p> <p>Code that is useful for building tests but is not a test itself belongs in the <code>testing/</code> directory.</p> <pre><code># Run all tests in tests/\n$ tox -e py39\n# Run a specific test\n$ tox -e py39 -- tests/factory_test.py::test_lambda_factory\n</code></pre> <p>Many of the tests are asyncio tests. The asyncio default event loop is used by default, but uvloop can be used instead by passing <code>--use-uvloop</code> to pytest.</p>"},{"location":"contributing/#tests-docker","title":"Tests (docker)","text":"<p>The test suite mocks certain third-party programs that cannot be installed via pip (e.g., Margo, UCX, Redis). For Margo and UCX, a Docker image is provided at proxystore/images with the software pre-built and Python installed. The tox environments <code>py{version}-dim</code> can be run in the container to validate changes against the un-mocked software.</p> <pre><code>$ docker pull ghcr.io/proxystore/proxystore-dim:nightly\n# Be sure to change the path to your proxystore repo directory\n$ docker run --rm -it --network host -v /path/to/proxystore:/proxystore ghcr.io/proxystore/proxystore-dim:nightly\n# Inside container\n$ tox -e py310-dim\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<p>If code changes require an update to the documentation (e.g., for function signature changes, new modules, etc.), the documentation can be built using MKDocs.</p> <pre><code># Manually\n$ pip install -e .[docs]\n$ mkdocs build --strict  # Build only to site/index.html\n$ mkdocs serve           # Serve locally\n# With tox (will only build, does not serve)\n$ tox -e docs\n</code></pre> <p>Docstrings are automatically generated, but it is recommended to check the generated docstrings to make sure details/links/etc. are correct.</p>"},{"location":"contributing/issues-pull-requests/","title":"Issues and Pull Requests","text":""},{"location":"contributing/issues-pull-requests/#issues","title":"Issues","text":"<p>Issue Tracker</p> <p>We use GitHub issues to report problems, request and track changes, and discuss future ideas. If you open an issue for a specific problem, please follow the template guides.</p>"},{"location":"contributing/issues-pull-requests/#pull-requests","title":"Pull Requests","text":"<p>We use the standard GitHub contribution cycle where all contributions are made via pull requests (including code owners!).</p> <ol> <li>Fork the repository and clone to your local machine.</li> <li>Create local changes.<ul> <li>Changes should conform to the style and testing guidelines, referenced   above.</li> <li>Preferred commit message format (source):<ul> <li>separate subject from body with a blank line,</li> <li>limit subject line to 50 characters,</li> <li>capitalize first word of subject line,</li> <li>do not end the subject line with a period,</li> <li>use the imperative mood for subject lines,</li> <li>include related issue numbers at end of subject line,</li> <li>wrap body at 72 characters, and</li> <li>use the body to explain what/why rather than how.   Example: <code>Fix concurrency bug in Store (#42)</code></li> </ul> </li> </ul> </li> <li>Push commits to your fork.<ul> <li>Please squash commits fixing mistakes to keep the git history clean.   For example, if commit \"b\" follows commit \"a\" and only fixes a small typo   from \"a\", please squash \"a\" and \"b\" into a single, correct commit.   This keeps the commit history readable and easier to search through when   debugging (e.g., git blame/bisect).</li> </ul> </li> <li>Open a pull request in this repository.<ul> <li>The pull request should include a description of the motivation for the   PR and included changes. A PR template is provided to guide this process.</li> </ul> </li> </ol>"},{"location":"contributing/releases/","title":"Releases","text":""},{"location":"contributing/releases/#release-timeline","title":"Release Timeline","text":"<p>Releases are created on an as-needed basis. Milestones are the Issue Tracker are used to track features to be included in upcoming releases.</p>"},{"location":"contributing/releases/#creating-releases","title":"Creating Releases","text":"<ol> <li>Choose the next version number, referred to as <code>{VERSION}</code> for the    rest of the instructions. ProxyStore versioning follows semver    (<code>major.minor.patch</code>) with optional PEP-440    pre-release/post-release/dev-release segments. Major/minor/patch numbers    start at 0 and pre-release/post-release/dev-release segments start at 1.</li> <li>Update the version in <code>pyproject.toml</code> to <code>{VERSION}</code>.</li> <li>Commit and merge the version updates/changelogs into main.</li> <li>Tag the release commit and push (typically this is the commit updating the    version numbers).    <pre><code>$ git tag -s v{VERSION} -m \"ProxyStore v{VERSION}\"\n$ git push origin v{VERSION}\n</code></pre>    Note the version number is prepended by \"v\" for the tags so we can    distinguish release tags from non-release tags.</li> <li>Create a new release on GitHub using the tag. The title should be    <code>ProxyStore v{VERSION}</code>.</li> <li>Official release:<ol> <li>Use the \"Generate release notes\" option and set the previous tag as the previous official release tag. E.g., for <code>v0.4.1</code>, the previous release tag should be <code>v0.4.0</code> and NOT <code>v0.4.1a1</code>.</li> <li>Add an \"Upgrade Steps\" section at the top (see previous releases for examples).</li> <li>Review the generated notes and edit as needed. PRs are organized by tag, but some PRs will be missing tags and need to be moved from the \"Other Changes\" section to the correct section.</li> <li>Select \"Set as the latest release.\"</li> </ol> </li> <li>Unnofficial release: (alpha/dev builds)<ol> <li>Do NOT generate release notes. The body can be along the lines of \"Development pre-prelease for <code>V{VERSION}</code>.\"</li> <li>Leave the previous tag as \"auto.\"</li> <li>Select \"Set as a pre-release.\"</li> </ol> </li> </ol>"},{"location":"contributing/style-guide/","title":"Style Guide","text":"<p>The Python code and docstring format mostly follows Google's Python Style Guide, but the pre-commit config is the authoritative source for code format compliance.</p> <p>Nits:</p> <ul> <li>Avoid imports in <code>__init__.py</code> (reduces the likelihood of circular imports).</li> <li>Prefer pure functions where possible.</li> <li>Define all class attributes inside <code>__init__</code> so all attributes are visible   in one place. Attributes that are defined later can be set as <code>None</code>   as a placeholder.</li> <li>Prefer f-strings (<code>f'name: {name}</code>) over string format   (<code>'name: {}'.format(name)</code>). Never use the <code>%</code> operator.</li> <li>Prefer typing.NamedTuple over collections.namedtuple.</li> <li>Exception messages should read as complete sentences with punctuation.   Logging messages can forgo trailing punctuation.   <pre><code>raise ValueError('Name must contain alphanumeric characters only.')\nlogger.info(f'New connection opened to {address}')\n</code></pre></li> <li>Document all exceptions that may be raised by a function in the docstring.</li> </ul>"},{"location":"guides/","title":"Guides","text":"<ul> <li>Globus Compute</li> <li>Endpoints Overview</li> <li>Endpoints Debugging</li> <li>Performance Tracking</li> </ul>"},{"location":"guides/endpoints-debugging/","title":"Endpoints Debugging","text":"<p>Last updated 2 May 2023</p> <p>This guide outlines some common trouble-shooting steps to take if you are encountering issues using ProxyStore Endpoints.</p>"},{"location":"guides/endpoints-debugging/#test-a-local-endpoint","title":"Test a Local Endpoint","text":"<p>Consider you configured and started an endpoint as follows: <pre><code>$ proxystore-endpoint configure myendpoint\nINFO: Configured endpoint myendpoint &lt;f4dc841d-377e-4785-8d66-8eade34f63cd&gt;. Start with:\nINFO:   $ proxystore-endpoint start myendpoint\n$ proxystore-endpoint start myendpoint\nINFO: Starting endpoint process as daemon.\nINFO: Logs will be written to ~/.local/share/proxystore/myendpoint/log.txt\n</code></pre></p>"},{"location":"guides/endpoints-debugging/#check-endpoint-logs","title":"Check Endpoint Logs","text":"<p>Endpoint logs are written to a directory in <code>$XDG_DATA_HOME/proxystore</code> which in this case is <code>~/.local/share/proxystore/myendpoint</code> (see <code>home_dir()</code> for the full specification). <pre><code>$ tail -n 1 ~/.local/share/proxystore/myendpoint/log.txt\nINFO  (uvicorn.error) :: Uvicorn running on http://127.0.1.1:8766 (Press CTRL+C to quit)\n</code></pre> The logs are the first place to check for any potential issues.</p>"},{"location":"guides/endpoints-debugging/#monitor-the-endpoint","title":"Monitor the Endpoint","text":"<p>Debug level logging can be enabled when starting the endpoint, and the endpoint can be run directly in the terminal instead of as a daemon process via the <code>--no-detach</code> flag. These two options are helpful for live monitoring the endpoint. <pre><code>$ proxystore-endpoint --log-level DEBUG start myendpoint --no-detach\n</code></pre></p>"},{"location":"guides/endpoints-debugging/#use-the-test-cli","title":"Use the Test CLI","text":"<p>The <code>proxystore-endpoint</code> CLI provides a <code>test</code> subcommand for testing endpoint commands. See the CLI Reference. <pre><code>$ proxystore-endpoint test myendpoint exists abcdef\nINFO: Object exists: False\n</code></pre> As expected, an object with key <code>abcdef</code> does not exist in the store, but we got a valid response so we know the endpoint is running correctly. You can also validate that this request was logged by the endpoint.</p>"},{"location":"guides/endpoints-debugging/#invoke-a-rest-request","title":"Invoke a REST Request","text":"<p>Endpoints serve a REST API so <code>curl</code> can be used to check if an endpoint is accessible. Note the <code>proxystore-endpoint test</code> CLI is preferred for debugging. The correct address the endpoint is listening on can be found in the logs. <pre><code>$ curl http://127.0.0.1:8765/exists?key=abcdef\n{\"exists\": false}\n</code></pre></p>"},{"location":"guides/endpoints-debugging/#test-a-remote-endpoint","title":"Test a Remote Endpoint","text":"<p>Consider I have an endpoint running on system A with UUID <code>aaaa0259-5a8c-454b-b17d-61f010d874d4</code> and another on System B with UUID <code>bbbbab4d-c73a-44ee-a316-58ec8857e83a</code>.</p>"},{"location":"guides/endpoints-debugging/#check-relay-server-connections","title":"Check Relay Server Connections","text":"<p>Both endpoints must be connected to the same relay server to form a peer connection. First, check the <code>relay_server</code> value in the endpoint config is correct and not <code>null</code>. The endpoint config is found in the <code>config.json</code> file in the endpoint directory (e.g., <code>~/.local/share/proxystore/myendpoint/config.json</code>). Restart your endpoints if you had to change the configuration.</p> <p>Second, confirm the endpoint connects to the relay server when started by checking the endpoint logs for a line like this. <pre><code>INFO  (proxystore.p2p.relay_client) :: Established client connection to relay server at ws://localhost:8765 with client uuid=aaaa0259-5a8c-454b-b17d-61f010d874d4 and name=myendpoint\n</code></pre></p>"},{"location":"guides/endpoints-debugging/#use-the-test-cli_1","title":"Use the Test CLI","text":"<p>The <code>proxystore-endpoint test</code> CLI can be used to establish a peer connection between two endpoints and invoke remote operations. Here, we will request the endpoint on system A (named \"myendpoint\") to invoke an <code>exists</code> operation on the endpoint on system B. <pre><code>$ proxystore-endpoint test --remote bbbbab4d-c73a-44ee-a316-58ec8857e83a myendpoint exists abcdef\nINFO: Object exists: False\n</code></pre></p> <p>You will get an error if the peer connection fails. For example: <pre><code>ERROR: Endpoint returned HTTP error code 400. Request to peer bbbbab4d-c73a-44ee-a316-58ec8857e83a failed: ...\n</code></pre> If this happens, check the logs for both endpoints for further error messages.</p>"},{"location":"guides/endpoints/","title":"Peer-to-Peer Endpoints","text":"<p>Last updated 2 May 2023</p> <p>ProxyStore Endpoints are in-memory object stores with peering capabilities. Endpoints enable data transfer with proxies between multiple sites using NAT traversal.</p> <p>Warning</p> <p>Endpoints are experimental and the interfaces and underlying implementations will likely change. Refer to the API docs for the most up-to-date information.</p> <p>Warning</p> <p>Endpoints do not have user authentication yet, so use at your own risk.</p>"},{"location":"guides/endpoints/#overview","title":"Overview","text":"<p>At its core, the <code>Endpoint</code> is an in-memory data store built on asyncio. Endpoints provide a REST API, served using <code>Quart</code>, and ProxyStore provides the <code>EndpointConnector</code> as the primary interface for clients to interact with endpoints.</p> <p></p> <p>Figure 1: ProxyStore Endpoints overview. Clients can make requests to any endpoint and those request will be forwarded to the correct endpoint. Endpoints establish peer-to-peer connections using UDP hole-punching and a publicly accessible relay server.</p> <p>Unlike popular in-memory data stores (Redis, Memcached, etc.), ProxyStore endpoints can operate as peers even from behind different NATs without the need to open ports or SSH tunnels. To achieve direct data transfer between peers, endpoints use the WebRTC standard to determine how the peers can connect.</p> <p>As shown in Fig. 1, endpoints use a commonly accessible relay server to facilitate peer connections. When an endpoint is started, the Endpoint registers with the relay server. Then, when an endpoint needs to make a request from a peer, (1) the endpoint creates an offer and asks the relay server to forward the offer to the peer endpoint. The relay server forwards the offer (2) and the peer endpoint creates an answer to the received offer. The peer endpoint returns the answer to the original endpoint via the relay server (3, 4).</p> <p>The offer and answer contain information about the local and remote sessions of the endpoints which can be used to complete the peer-to-peer connection (5). (Note: this is a great simplification and more details can be found at https://webrtc.org/getting-started/peer-connections.) The peers will then keep a data channel open between themselves for the remainder of their lifetime.</p> <p>Clients interacting with an endpoint via the REST API and typical object store operations (get, set, etc.) specify a key and an endpoint UUID. Endpoints that receive a request with a different endpoint UUID will attempt a peer connection to the endpoint if one does not exist already and forward the request along and facilitate returning the response back to the client.</p>"},{"location":"guides/endpoints/#endpoint-cli","title":"Endpoint CLI","text":"<p>Endpoints can be configure and started with the <code>proxystore-endpoint</code> command.</p> <pre><code>$ proxystore-endpoint configure my-endpoint --relay-server wss://relay-address.com\nConfigured endpoint my-endpoint &lt;12b8f3b6-6c0e-4141-b851-870895e3eb3c&gt;.\n\nTo start the endpoint:\n   $ proxystore-endpoint start my-endpoint\n</code></pre> <p>Endpoint configurations are stored to <code>$PROXYSTORE_HOME/{endpoint-name}</code> or <code>$XDG_DATA_HOME/proxystore/{endpoint-name}</code> (see <code>home_dir()</code>) and contain the name, UUID, host address, port, relay server address, and more.</p> <p>Tip</p> <p>By default, <code>$XDG_DATA_HOME/proxystore</code> will usually resolve to <code>~/.local/share/proxystore</code>. You can change this behavior by setting <code>$PROXYSTORE_HOME</code> in your <code>~/.bashrc</code> or similar configuration file. <pre><code>export PROXYSTORE_HOME=\"$HOME/.proxystore\"\n</code></pre></p> <ol> <li>Name: readable name of the endpoint. Used for management in the CLI and    to improve log readability.</li> <li>UUID: primary identifier of the endpoint. The relay server will    use this UUID to keep track of endpoints.</li> <li>Host address: address of the host the endpoint was last started on.    Each time the endpoint is started, this address is updated.</li> <li>Port: port the endpoint will listening on. Defaults to 8765.</li> <li>Relay server address: address of relay server to use for peer    connections. All endpoints that may peer with each other must use the same    relay server. Relay servers are optional, and if unspecified, the    endpoint will operate without peering functionalities.</li> </ol> <p>Tip</p> <p>Endpoints provide no data persistence by default, but this can be enabled by passing the <code>--persist</code> flag when configuring the endpoint or by setting <code>\"database_path\"</code> in the config. When set, blobs stored by the endpoint will be written to a SQLite database file. Note this will result in slower performance.</p> <p>An up-to-date configuration description can found in the <code>EndpointConfig</code> docstring.</p> <p>Starting the endpoint will load the configuration from the ProxyStore home directory, initialize the endpoint, and start a Quart app using the host and port.</p> <pre><code>$ proxystore-endpoint start my-endpoint\n</code></pre>"},{"location":"guides/endpoints/#endpointconnector","title":"EndpointConnector","text":"<p>The primary interface to endpoints is the <code>EndpointConnector</code>.</p> <p>Note</p> <p>This section assumes familiarity with proxies and the <code>Store</code> interface. See the Get Started guide before getting started with endpoints.</p> Endpoint Client Example<pre><code>from proxystore.connectors.endpoint import EndpointConnector\nfrom proxystore.store import Store\nconnector = EndpointConnector(\nendpoints=[\n'5349ffce-edeb-4a8b-94a6-ab16ade1c1a1',\n'd62910f6-0d29-452e-80b7-e0cd601949db',\n...\n],\n)\nstore = Store(name='default', connector=connector)\np = store.proxy(my_object)\n</code></pre> <p>The <code>EndpointConnector</code> takes a list of endpoint UUIDs. This list represents any endpoint that proxies created by this store may interact with to resolve themselves. The <code>EndpointConnector</code> will use this list to find its home endpoint, the endpoint that will be used to issue operations to. To find the home endpoint, the ProxyStore home directory will be scanned for any endpoint configurations matching the one of the UUIDs. If a match is found, the <code>EndpointConnector</code> will attempt to connect to the endpoint using the host and port in the configuration. This process is repeated until a reachable endpoint is found. While the user could specify the home endpoint directly, the home endpoint may change when a proxy travels to a different machine.</p>"},{"location":"guides/endpoints/#proxy-lifecycle","title":"Proxy Lifecycle","text":"<p>Figure 2: Flow of data when transferring objects via proxies and endpoints.</p> <p>In distributed systems, proxies created from an <code>EndpointConnector</code> can be used to facilitate simple and fast data communication. The flow of data and their associated proxies are shown in Fig. 2.</p> <ol> <li>Host A creates a proxy of the target object. The serialized target    is placed in Host A's home/local endpoint (Endpoint 1).    The proxy contains the key referencing the target, the endpoint UUID with    the target data (Endpoint 1's UUID), and the list of    all endpoint UUIDs configured with the    <code>EndpointConnector</code>    (the UUIDs of Endpoints 1 and 2).</li> <li>Host A communicates the proxy object to Host B. This communication is    cheap because the proxy is just a thin reference to the object.</li> <li>Host B receives the proxy and attempts to use the proxy initiating the    proxy resolve process. The proxy requests the data from Host B's    home endpoint (Endpoint 2).</li> <li>Endpoint 2 sees that the proxy is requesting data from a different endpoint    (Endpoint 1) so Endpoint 2 initiates a peer connection to Endpoint 1 and    requests the data.</li> <li>Endpoint 1 sends the data to Endpoint 2.</li> <li>Endpoint 2 replies to Host B's request for the data with the data received    from Endpoint 2. Host B deserializes the target object and the proxy    is resolved.</li> </ol>"},{"location":"guides/endpoints/#hosting-a-relay-server","title":"Hosting a Relay Server","text":"<p>Currently, ProxyStore does not provided any publicly host relay servers, though we hope to in the future! Hosting your own relay server is simple if you have a host accessible from the internet (e.g., a compute instance from a cloud provider or a machine behind a NAT with an open port) and the ProxyStore package installed.</p> <pre><code>$ proxystore-relay --port 3579\n</code></pre>"},{"location":"guides/globus-compute/","title":"Globus Compute with ProxyStore","text":"<p>Last updated 2 May 2023</p> <p>This guide walks through integrating ProxyStore into a Globus Compute application. A more complete example of using ProxyStore with Globus Compute can be found in the <code>examples/</code>.</p> <p>Note</p> <p>Some familiarity with using Globus Compute and ProxyStore is assumed. Check out the Globus Compute Quickstart and ProxyStore Get Started to learn more.</p>"},{"location":"guides/globus-compute/#installation","title":"Installation","text":"<p>Create a new virtual environment of your choosing and install Globus Compute and ProxyStore.</p> <p>Note</p> <p>The below versions represent the latest versions of these packages available when this guide was written. These instructions should generally work with newer versions as well.</p> <pre><code>$ python -m venv venv\n$ . venv/bin/activate\n$ pip install globus-compute-sdk==2.0.1 globus-compute-endpoint==2.0.1 proxystore==0.5.*\n</code></pre>"},{"location":"guides/globus-compute/#using-globus-compute","title":"Using Globus Compute","text":"<p>We will first configure and start a Globus Compute endpoint.</p> <pre><code>$ globus-compute-endpoint configure proxystore-example\n$ globus-compute-endpoint start proxystore-example\n</code></pre> <p>After configuring the endpoint, you will get back an endpoint UUID which we will need in the next step.</p> <p>Below is a modified example based on the example Globus Compute app from the Quickstart guide. example.py<pre><code>from globus_compute_sdk import Executor\nENDPOINT_UUID = '5b994a7d-8d7c-48d1-baa1-0fda09ea1687' # (1)!\ndef average(x: list[float]) -&gt; float:  # (2)!\nreturn sum(x) / len(x)\nwith Executor(endpoint_id=ENDPOINT_UUID) as gce:  # (3)!\nx = list(range(1, 100000))\nfuture = gce.submit(average, x)  # (4)!\nprint(future.result())  # (5)!\n</code></pre></p> <ol> <li>Your endpoint's UUID.</li> <li>Define the function that will be executed remotely.</li> <li>Create the Globus Compute executor.</li> <li>Submit the function for execution.</li> <li>Wait on the result future.</li> </ol> <p>Running this script will return <code>50000</code>. <pre><code>$ python example.py\n50000.0\n</code></pre></p>"},{"location":"guides/globus-compute/#using-proxystore","title":"Using ProxyStore","text":"<p>Now we will update our script to use ProxyStore. This takes three steps:</p> <ol> <li>Initialize a <code>Connector</code> and    <code>Store</code>. The <code>Connector</code> is the interface    to the byte-level communication channel that will be used, and the <code>Store</code>    is the high-level interface provided by ProxyStore.</li> <li>Register the <code>Store</code> instance globally. This is not strictly necessary, but    is an optimization which enables proxies to share the same original <code>Store</code>    instance, because the <code>Store</code> and <code>Connector</code> can have state (e.g., caches,    open connections, etc.).</li> <li>Proxy the function inputs.</li> </ol> example.py<pre><code>from globus_compute_sdk import Executor\nfrom proxystore.connectors.file import FileConnector\nfrom proxystore.store import register_store\nfrom proxystore.store import Store\nENDPOINT_UUID = '5b994a7d-8d7c-48d1-baa1-0fda09ea1687'\ndef average(x: list[float]) -&gt; float:\nreturn sum(x) / len(x)\nstore = Store('my-store', FileConnector('./proxystore-cache'))  # (1)!\nregister_store(store) # (2)!\nwith Executor(endpoint_id=ENDPOINT_UUID) as gce:\nx = list(range(1, 100000))\np = store.proxy(x) # (3)!\nfuture = gce.submit(average, p)\nprint(future.result())\nstore.close() # (4)!\n</code></pre> <ol> <li>Create a new store using the file system for mediated communication.</li> <li>Register the store instance so states (e.g., caches, etc.) can be shared.</li> <li>Proxy the input data.</li> <li>Close the <code>Store</code> to cleanup any resources.</li> </ol> <p>Tip</p> <p>The <code>Store</code> can also be used as a context manager that will automatically clean up resources.</p> <pre><code>with Store('my-store', FileConnector('./proxystore-cache')) as store:\nx = list(range(1, 100000))\np = store.proxy(x)\nfuture = gce.submit(average, p)\nprint(future.result())\n</code></pre> <p>We can also use ProxyStore to return data via the same communication method.</p> example.py<pre><code>def average(x: list[float]) -&gt; float:\nfrom proxystore.proxy import Proxy # (1)!\nfrom proxystore.store import get_store\navg = sum(x) / len(x)\nif isinstance(x, Proxy): # (2)!\nstore = get_store(x)\navg = store.proxy(avg)\nreturn avg\n</code></pre> <ol> <li>Globus Compute functions will be executed in a different process so we must    import inside the function.</li> <li>If our input data was communicated via a proxy, we get the same <code>Store</code> that    create our input proxy which we then use to proxy the output.</li> </ol>"},{"location":"guides/globus-compute/#closing-thoughts","title":"Closing Thoughts","text":"<p>While this example is trivial, the target function is still executed on the local machine and the data sizes are small, the key takeaway is that the <code>Proxy</code> model simplifies the process of moving data via alternate means between the Globus Compute client and executors.</p> <p>More complex applications where the Globus Compute endpoints live elsewhere (e.g., on an HPC) cluster or that move larger data will benefit from the various <code>Connector</code> implementations provided.</p> <p>Checkout the other Guides to learn about more advanced ProxyStore features.</p>"},{"location":"guides/performance/","title":"Performance Tracking","text":"<p>Last updated 2 May 2023</p> <p>The <code>Store</code> can record metrics on executed operations (e.g., <code>get</code> and <code>put</code>). Metric collection is disabled by default and can be enabled by passing <code>metrics=True</code> to a <code>Store</code> constructor.</p>"},{"location":"guides/performance/#enabling-metrics","title":"Enabling Metrics","text":"<pre><code>import dataclasses\nfrom proxystore.connectors.file import FileConnector\nfrom proxystore.store import register_store\nfrom proxystore.store.base import Store\nstore = Store(\nname='example-store',\nconnector=FileConnector('/tmp/proxystore-dump'),\nmetrics=True,  # (1)!\n)\nregister_store(store)\nassert store.metrics is not None\n</code></pre> <ol> <li>Metric tracking is not enabled by default.</li> </ol> <p>Metrics are accessed via the <code>Store.metrics</code> property. This property will be <code>None</code> when metrics are disabled.</p> <p>Warning</p> <p>Metrics are local to each <code>Store</code> instance. In multi-process applications or applications that instantiate multiple <code>Store</code> instances, <code>Store.metrics</code> will only represent a partial view of the overall performance.</p> <p>Three types of metrics are collected.</p> <ul> <li>Attributes: arbitrary attributes associated with an operation.</li> <li>Counters: scalar counters that represent the number of times an event occurs.</li> <li>Times: durations of events.</li> </ul>"},{"location":"guides/performance/#a-simple-example","title":"A Simple Example","text":"<p>Consider executing a <code>get</code> and <code>put</code> operation on <code>store</code>. <pre><code>&gt;&gt;&gt; key = store.put([0, 1, 2, 3, 4, 5])\n&gt;&gt;&gt; store.get(key)\n</code></pre></p> <p>We can inspect the metrics recorded for operations on <code>key</code>. <pre><code>&gt;&gt;&gt; metrics = store.metrics.get_metrics(key)\n&gt;&gt;&gt; tuple(field.name for field in dataclasses.fields(metrics))\n('attributes', 'counters', 'times')\n</code></pre></p> <p><code>metrics</code> is an instance of <code>Metrics</code> which is a <code>dataclass</code> with three fields: <code>attributes</code>, <code>counters</code>, and <code>times</code>. We can further inspect these fields. <pre><code>&gt;&gt;&gt; metrics.attributes\n{'store.get.object_size': 219, 'store.put.object_size': 219}\n&gt;&gt;&gt; metrics.counters\n{'store.get.cache_misses': 1}\n&gt;&gt;&gt; metrics.times\n{\n'store.put.serialize': TimeStats(\ncount=1, avg_time_ms=9.9, min_time_ms=9.9, max_time_ms=9.9\n),\n'store.put.connector': TimeStats(\ncount=1, avg_time_ms=36.9, min_time_ms=36.9, max_time_ms=36.9\n),\n'store.put': TimeStats(\ncount=1, avg_time_ms=53.4, min_time_ms=53.4, max_time_ms=53.4\n),\n'store.get.connector': TimeStats(\ncount=1, avg_time_ms=16.1, min_time_ms=16.1, max_time_ms=16.1\n),\n'store.get.deserialize': TimeStats(\ncount=1, avg_time_ms=7.6, min_time_ms=7.6, max_time_ms=7.6\n),\n'store.get': TimeStats(\ncount=1, avg_time_ms=45.6, min_time_ms=45.6, max_time_ms=45.6\n),\n}\n</code></pre></p> <p>Operations or events are represented by a hierarchical namespace. E.g., <code>store.get.object_size</code> is the serialized object size from the call to <code>Store.get()</code>. In <code>metrics.attributes</code>, we see the serialized object was 219 bytes. In <code>metrics.counters</code>, we see we had one cache miss when getting the object. In <code>metrics.times</code>, we see statistics about the duration of each operation. For example, <code>store.get</code> is the overall time <code>Store.get()</code> took, <code>store.get.connector</code> is the time spent calling <code>Connector.get()</code>, and <code>store.get.deserialize</code> is the time spent deserializing the object returned by <code>Connector.get()</code>.</p> <p>If we get the object again, we'll see the metrics change. <pre><code>&gt;&gt;&gt; store.get(key)\n&gt;&gt;&gt; metrics = store.metrics.get_metrics(key)\n&gt;&gt;&gt; metrics.counters\n{'store.get.cache_hits': 1, 'store.get.cache_misses': 1}\n&gt;&gt;&gt; metrics.times['store.get']\nTimeStats(count=2, avg_time_ms=24.4, min_time_ms=3.2, max_time_ms=45.6)\n</code></pre> Here, we see that the second get resulted in a cache hit, and our average time for <code>store.get</code> dropped significantly.</p> <p>Attributes of a <code>TimeStats</code> instance can be directly accessed. <pre><code>&gt;&gt;&gt; metrics.times['store.get'].avg_time_ms\n24.4\n</code></pre></p>"},{"location":"guides/performance/#metrics-with-proxies","title":"Metrics with Proxies","text":"<p>Metrics are also tracked on proxy operations. <pre><code>&gt;&gt;&gt; proxy = store.proxy(target)\n# Access the proxy to force it to resolve.\n&gt;&gt;&gt; assert target_proxy[0] == 0\n&gt;&gt;&gt; metrics = store.metrics.get_metrics(proxy)\n&gt;&gt;&gt; metrics.times\n{\n'factory.call': TimeStats(...)\n'factory.resolve': TimeStats(...),\n'store.get': TimeStats(...),\n'store.get.connector': TimeStats(...),\n'store.get.deserialize': TimeStats(...),\n'store.proxy': TimeStats(...),\n'store.put': TimeStats(...),\n'store.put.connector': TimeStats(...),\n'store.put.serialize': TimeStats(...),\n}\n</code></pre> Calling <code>Store.proxy()</code> internally called <code>Store.put()</code>. Accessing the proxy internally resolved the factory so we also see metrics about the <code>factory</code> and <code>store.get</code>.</p> <p>Warning</p> <p>For metrics to appropriately be tracked when a proxy is resolved, the <code>Store</code> needs to be registered globally with <code>register_store()</code>. Otherwise, the factory will initialize a second <code>Store</code> to register and record its metrics to the second instance.</p>"},{"location":"guides/performance/#metrics-for-batch-operations","title":"Metrics for Batch Operations","text":"<p>For batch <code>Store</code> operations, metrics are recorded for the entire batch. I.e., the batch of keys is treated as a single super key.</p> <pre><code>&gt;&gt;&gt; keys = store.put_batch(['value1', 'value2', 'value3'])\n&gt;&gt;&gt; metrics = store.metrics.get_metrics(keys)\n&gt;&gt;&gt; metrics.times\n{\n'store.put_batch.serialize': TimeStats(...),\n'store.put_batch.connector': TimeStats(...),\n'store.put_batch': TimeStats(...)\n}\n</code></pre>"},{"location":"guides/performance/#aggregating-metrics","title":"Aggregating Metrics","text":"<p>Rather than accessing metrics associated with a specific key (or batched key), time statistics can be aggregated over all keys.</p> <p><pre><code>&gt;&gt;&gt; store.metrics.aggregate_times()\n{\n'factory.call': TimeStats(...),\n'factory.resolve': TimeStats(...),\n'store.get': TimeStats(...),\n'store.get.connector': TimeStats(...),\n'store.get.deserialize': TimeStats(...),\n'store.proxy': TimeStats(...),\n'store.put': TimeStats(...),\n'store.put.connector': TimeStats(...),\n'store.put.serialize': TimeStats(...),\n'store.put_batch': TimeStats(...),\n'store.put_batch.connector': TimeStats(...),\n'store.put_batch.serialize': TimeStats(...),\n}\n</code></pre> Each of these <code>TimeStats</code> represents the aggregate over all keys.</p> <p>The Python code used to generate the above examples can be found at github.com/proxystore/proxystore/examples/store_metrics.py.</p>"},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#citing-proxystore","title":"Citing ProxyStore","text":"<p>If you use ProxyStore or any of this code in your work, please cite the following paper.</p> <p>J. Gregory Pauloski, Valerie Hayot-Sasson, Logan Ward, Nathaniel Hudson, Charlie Sabino, Matt Baughman, Kyle Chard, and Ian Foster. \"Accelerating Communications in Federated Applications with Transparent Object Proxies.\" arXiv, 2023.</p> <pre><code>@misc{pauloski2023proxystore,\n    author = {J. Gregory Pauloski and Valerie Hayot-Sasson and Logan Ward and Nathaniel Hudson and Charlie Sabino and Matt Baughman and Kyle Chard and Ian Foster},\n    title = {{Accelerating Communications in Federated Applications with Transparent Object Proxies}},\n    archiveprefix = {arXiv},\n    eprint = {2305.09593},\n    primaryclass = {cs.DC},\n    year = {2023}\n}\n</code></pre>"},{"location":"publications/#featured-papers","title":"Featured Papers","text":"<ul> <li>Nicholson Collier, Justin M. Wozniak, Abby Stevens, Yadu Babuji, Micka\u00ebl Binois, Arindam Fadikar, Alexandra W\u00fcrth, Kyle Chard, and Jonathan Ozik. \"Developing Distributed High-performance Computing Capabilities of an Open Science Platform for Robust Epidemic Analysis.\" arXiv, 2023.</li> <li>Logan Ward, J. Gregory Pauloski, Valerie Hayot-Sasson, Ryan Chard, Yadu Babuji, Ganesh Sivaraman, Sutanay Choudhury, Kyle Chard, Rajeev Thakur, and Ian Foster. \"Cloud Services Enable Efficient AI-Guided Simulation Workflows across Heterogeneous Resources.\" In Proceedings of Heterogeneity in Computing Workshop of the International Parallel and Distributed Processing Symposium. 2023.</li> <li>Maxim Zvyagin et al. \"GenSLMs: Genome-scale language models reveal SARS-CoV-2 evolutionary dynamics.\" bioRxiv, 2022.</li> <li>Logan Ward, Ganesh Sivaraman, J. Gregory Pauloski, Yadu Babuji, Ryan Chard, Naveen Dandu, Paul C. Redfern, Rajeev S. Assary, Kyle Chard, Larry A. Curtiss, Rajeev Thakur, and Ian Foster. \"Colmena: Scalable machine-learning-based steering of ensemble simulations for high performance computing.\" In IEEE/ACM Workshop on Machine Learning in High Performance Computing Environments. IEEE, 2021.</li> </ul>"}]}