{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#proxystore","title":"ProxyStore","text":"<p>ProxyStore provides a unique interface to object stores through transparent object proxies that is designed to simplify the use of object stores for transferring large objects in distributed applications. ProxyStore's goals are to:</p> <ul> <li>Improve productivity. ProxyStore enables easy decoupling of   communication from the rest of the code, allowing developers to focus   on functionality and performance.</li> <li>Improve compatibility. Consumers of data can be agnostic to the   communication method because object proxies handle the communication   behind the scenes.</li> <li>Improve performance. Transport methods and object stores can be changed   at runtime to optimal choices for the given data without the consumers   being aware of the change.</li> </ul> <p>Read more about ProxyStore's concepts here.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install proxystore\n$ pip install proxystore[all]\n</code></pre> <p>See the Installation guide for more information about the available extra install options. For local development, see the Contributing guide.</p> <p>Additional features are available in the <code>proxystore-extensions</code> package.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Complete documentation for ProxyStore is available at docs.proxystore.dev.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#integration-examples","title":"Integration Examples","text":"<p>Examples of integrating ProxyStore into distributed applications built on FuncX and Parsl are on GitHub.</p>"},{"location":"examples/#benchmarks","title":"Benchmarks","text":"<p>ProxyStore benchmarks are maintained at github.com/proxystore/benchmarks. These benchmarks can be used as reference for ProxyStore usage or to test your own extensions for ProxyStore.</p>"},{"location":"get-started/","title":"Get Started","text":"ProxyStore allows developers to communicate objects via *proxies*. Proxies   act as lightweight references that resolve to a *target* object upon use.   Communication via proxies gives applications the illusion that objects   are moving through a specified path (e.g., through a network   socket, cloud server, workflow engine, etc.) while the true path the data   takes is different. Transporting the lightweight proxies through the   application or systems can be far more efficient and reduce overheads."},{"location":"get-started/#overview","title":"Overview","text":"<p>ProxyStore provides a unique interface to object stores through transparent object proxies that is designed to simplify the use of object stores for transferring large objects in distributed applications.</p> <p>Proxies are used to intercept and redefine operations on a target object. A transparent proxy behaves identically to its target object because the proxy forwards all operations on itself to the target. A lazy proxy provides just-in-time resolution of the target object via a factory function. Factories return the target object when called, and a proxy, initialized with a factory, will delay calling the factory to retrieve the target object until the first time the proxy is accessed.</p> <p>ProxyStore uses lazy transparent object proxies as the interface to object stores. When an object is proxied, the object is placed in the specified object store, a factory containing the information needed to retrieve the object from the store is created, and a proxy, initialized with the factory, is returned. The resulting proxy is essentially a lightweight reference to the target that will resolve itself to the target and behave as the target once the proxy is first used. Thus, proxies can be used anywhere in-place of the true object and will resolve themselves without the program being aware.</p> <p>ProxyStore provides the proxy interface to a number of commonly used object stores as well as the <code>Proxy</code> and <code>Factory</code> building blocks to allow developers to create powerful just-in-time resolution functionality for Python objects.</p>"},{"location":"get-started/#usage","title":"Usage","text":"<p>ProxyStore is intended to be used via the <code>Store</code> interface which provide the <code>Store.proxy()</code> method for placing objects in stores and creating proxies that will resolve to the associated object in the store.</p> <p>A <code>Store</code> is initialized with a <code>Connector</code> which serves as the low-level interface to an byte-level object store. ProxyStore provides many <code>Connector</code> implementations and third-party code can provide custom implementations provided they meet the <code>Connector</code> protocol specification.</p> <p>The following example uses the <code>RedisConnector</code> to interface with an already running Redis server using proxies.</p> <pre><code>from proxystore.connectors.redis import RedisConnector\nfrom proxystore.store import get_store\nfrom proxystore.store import register_store\nfrom proxystore.store import Store\nstore = Store(name='my-store', RedisConnector(hostname='localhost', port=1234))\nregister_store(store)\n# A registered store can be retrieved by name\nstore = get_store('my-store')\n# Stores have basic get/set functionality\nkey = store.set(my_object)\nassert my_object == store.get(key)\n# Place an object in the store and return a proxy\np = store.proxy(my_object)\n# The proxy, when used, will behave as the target\nassert isinstance(p, type(my_object))\n</code></pre> <p>This proxy, <code>p</code>, can be cheaply serialized and communicated to any arbitrary Python process as if it were the target object itself. Once the proxy is used on the remote process, the underlying factory function will be executed to retrieve the target object from the Redis server.</p> <p>Using the <code>Store</code> store interface allows developers to write code without needing to worry about how data communication is handled and reduces the number of lines of code that need to be changed when adding or changing the communication methods.</p> <p>For example, if you want to execute a function and the input data may be passed directly, via a key to an object in Redis, or as a filepath to a serialized object on disk, you will need boilerplate code that looks like:</p> <pre><code>def my_function(input: MyDataType | str | ...) -&gt; None:\nif is_filepath(input_data):\ndata = read_and_deserialize(input)\nelif is_redis_key(input_data):\ndata = redis_client.get(input)\nelif is_other_communication_method(input_data):\n...\nelif isinstance(input, MyDataType):\ndata = input\nelse:\nraise ValueError(...)\n# Compute using the data\n</code></pre> <p>This function is hard to type and must be extended every time a new communication method is used. With proxies, all of the boilerplate code can be removed because the proxy will contain within itself all of the necessary code to resolve the object.</p> <pre><code>def my_function(input: MyDataType) -&gt; None:\n# Always true even if input is a proxy\nassert isinstance(input, MyDataType)\n# Compute using the data\n</code></pre> <p>In this model, only the producer of the data needs to be aware of which ProxyStore backend to use, and no modification to consumer code are ever required.</p> <p>How is this more efficient?</p> <p>The ProxyStore model can improve application performance in many ways:</p> <ol> <li>Unused proxies are not resolved so not resources/time were wasted on the    communication.</li> <li>Object communication always takes place between the producer, the store, and    the consumer meaning communication is not wasted on intermediate processes    which have a proxy but do not use it.</li> <li>Different backends can be used that are optimized for specific usage    patterns.</li> <li>Proxies have built-in caching for frequently used objects.</li> </ol> <p>See the Concepts to learn more!</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#base-install","title":"Base Install","text":"<p>We always recommend installing packages inside of your virtual environment of choice. E.g., <pre><code>$ python -m venv venv\n$ . venv/bin/activate\n</code></pre></p> <p>Once your virtual environment is activated, install ProxyStore with <code>pip</code>. <pre><code>$ pip install proxystore\n</code></pre></p>"},{"location":"installation/#extras-options","title":"Extras Options","text":"<p>The base installation is designed to be as lightweight as possible, but ProxyStore provides many features with extra dependencies that can be installed with the appropriate extras option.</p> Install Purpose <code>pip install proxystore[all]</code> Install all extras except <code>dev</code> and <code>docs</code> <code>pip install proxystore[endpoints]</code> Use ProxyStore Endpoints <code>pip install proxystore[redis]</code> Use the <code>RedisConnector</code> <code>pip install proxystore[zmq]</code> Use the <code>ZeroMQConnector</code> <code>pip install proxystore[dev]</code> Development dependencies <code>pip install proxystore[docs]</code> Documentation dependencies <p>Multiple extras options can be install at the same time.</p> <pre><code>$ pip install proxystore[endpoints,redis]\n</code></pre> <p>Or everything can be installed at once (this does not install the development packages).</p> <pre><code>$ pip install proxystore[all]\n</code></pre>"},{"location":"installation/#distributed-in-memory-connectors","title":"Distributed In-Memory Connectors","text":"<p>The <code>MargoConnector</code> and <code>UCXConnector</code> have additional manual installation steps to be completed before they can be used.</p> <ul> <li>Margo:<ul> <li>Install Mochi-Margo and the dependencies</li> <li>Install Py-Mochi-Margo</li> </ul> </li> <li>UCX:<ul> <li>Install UCX</li> <li>Install UCX-Py</li> </ul> </li> </ul>"},{"location":"installation/#proxystore-extensions","title":"ProxyStore Extensions","text":"<p>Additional features are available in the <code>proxystore-extensions</code> package (Repository and Docs). Features in the extensions package tend to be more experimental or have heavier dependencies. <pre><code>$ pip install proxystore-extensions\n</code></pre></p>"},{"location":"known-issues/","title":"Known Issues","text":"<ul> <li>ProxyStore Endpoints are not supported for   Python 3.7 on ARM-based Macs because   aiortc does not have the corresponding   wheels. The base ProxyStore package can still be installed on this   software/hardware configurations---just not with the <code>endpoints</code> extras.</li> <li>Newer versions of UCX-Py   no longer support Python 3.7.</li> </ul>"},{"location":"api/","title":"proxystore","text":"<code>proxystore/__init__.py</code> <p>ProxyStore is a library for decoupling object communication from code.</p> <p>Legacy Documentation: Documentation for ProxyStore versions older than v0.4.1 are hosted at proxystore.readthedocs.io/.</p>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>proxystore</li> <li>proxystore.connectors<ul> <li>connector</li> <li>dim<ul> <li>margo</li> <li>ucx</li> <li>utils</li> <li>zmq</li> </ul> </li> <li>endpoint</li> <li>file</li> <li>globus</li> <li>local</li> <li>multi</li> <li>redis</li> </ul> </li> <li>proxystore.endpoint<ul> <li>cli</li> <li>client</li> <li>commands</li> <li>config</li> <li>constants</li> <li>endpoint</li> <li>exceptions</li> <li>messages</li> <li>serve</li> <li>storage</li> </ul> </li> <li>proxystore.factory</li> <li>proxystore.globus</li> <li>proxystore.p2p<ul> <li>chunks</li> <li>client</li> <li>connection</li> <li>counter</li> <li>exceptions</li> <li>manager</li> <li>messages</li> <li>relay</li> <li>task</li> </ul> </li> <li>proxystore.proxy</li> <li>proxystore.serialize</li> <li>proxystore.store<ul> <li>base</li> <li>cache</li> <li>endpoint</li> <li>exceptions</li> <li>file</li> <li>globus</li> <li>local</li> <li>metrics</li> <li>multi</li> <li>redis</li> <li>utils</li> </ul> </li> <li>proxystore.timer</li> <li>proxystore.utils</li> <li>proxystore.warnings</li> </ul>"},{"location":"api/cli/","title":"CLI Reference","text":""},{"location":"api/cli/#cli-reference","title":"CLI Reference","text":"<p>This page provides documentation for our command line tools.</p>"},{"location":"api/cli/#proxystore-globus-auth","title":"proxystore-globus-auth","text":"<p>Perform Globus authentication for the Transfer service.</p> <p>Collections or scopes options can be strung together. E.g., request transfer scope for multiple collections with:</p> <p>$ proxystore-globus-auth -c UUID -c UUID -c UUID</p> <p>Usage:</p> <pre><code>proxystore-globus-auth [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--collection</code>, <code>-c</code> text Globus Collection UUID to request transfer scopes for. None <code>--scope</code>, <code>-s</code> text Additional scope to request. None <code>--delete</code> boolean Delete existing tokens. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint","title":"proxystore-endpoint","text":"<p>Manage and start ProxyStore Endpoints.</p> <p>Usage:</p> <pre><code>proxystore-endpoint [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--log-level</code> choice (<code>ERROR</code> | <code>WARNING</code> | <code>INFO</code> | <code>DEBUG</code>) Minimum logging level. <code>INFO</code> <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>configure: Configure a new endpoint.</li> <li>help: Show available commands and options.</li> <li>list: List all user endpoints.</li> <li>remove: Remove an endpoint.</li> <li>start: Start an endpoint.</li> <li>stop: Stop a detached endpoint.</li> <li>test: Execute test commands on an endpoint.</li> <li>version: Show the ProxyStore version.</li> </ul>"},{"location":"api/cli/#proxystore-endpoint-configure","title":"proxystore-endpoint configure","text":"<p>Configure a new endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint configure [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--port</code> integer Port to listen on. <code>8765</code> <code>--relay-server</code> text Optional relay server address. None <code>--max-memory</code> integer Optional maximum memory to use. None <code>--dump-dir</code> text Directory to dump object to if max-memory exceeded. None <code>--peer-channels</code> integer Datachannels to use per peer connection. <code>1</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-help","title":"proxystore-endpoint help","text":"<p>Show available commands and options.</p> <p>Usage:</p> <pre><code>proxystore-endpoint help [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-list","title":"proxystore-endpoint list","text":"<p>List all user endpoints.</p> <p>Usage:</p> <pre><code>proxystore-endpoint list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-remove","title":"proxystore-endpoint remove","text":"<p>Remove an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint remove [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-start","title":"proxystore-endpoint start","text":"<p>Start an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint start [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--detach</code> / <code>--no-detach</code> boolean Run as daemon. <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-stop","title":"proxystore-endpoint stop","text":"<p>Stop a detached endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint stop [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-test","title":"proxystore-endpoint test","text":"<p>Execute test commands on an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint test [OPTIONS] NAME COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--remote</code> text Optional UUID of remote endpoint to use. None <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>evict: Evict object from an endpoint.</li> <li>exists: Check if object exists in an endpoint.</li> <li>get: Get an object from an endpoint.</li> <li>put: Put an object in an endpoint.</li> </ul>"},{"location":"api/cli/#proxystore-endpoint-test-name-evict","title":"proxystore-endpoint test NAME evict","text":"<p>Evict object from an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint test NAME evict [OPTIONS] KEY\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-test-name-exists","title":"proxystore-endpoint test NAME exists","text":"<p>Check if object exists in an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint test NAME exists [OPTIONS] KEY\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-test-name-get","title":"proxystore-endpoint test NAME get","text":"<p>Get an object from an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint test NAME get [OPTIONS] KEY\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-test-name-put","title":"proxystore-endpoint test NAME put","text":"<p>Put an object in an endpoint.</p> <p>Usage:</p> <pre><code>proxystore-endpoint test NAME put [OPTIONS] DATA\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-endpoint-version","title":"proxystore-endpoint version","text":"<p>Show the ProxyStore version.</p> <p>Usage:</p> <pre><code>proxystore-endpoint version [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#proxystore-relay","title":"proxystore-relay","text":"<p>Run a relay server instance.</p> <p>The relay server is used by clients to establish peer-to-peer WebRTC connections.</p> <p>Usage:</p> <pre><code>proxystore-relay [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--host</code> text Address to listen on. <code>0.0.0.0</code> <code>--port</code> integer Port to listen on. <code>8765</code> <code>--certfile</code> text Certificate file for serving with TLS. None <code>--keyfile</code> text Private key file associated with the certfile. None <code>--log-dir</code> text Write server logs to this directory. None <code>--log-level</code> choice (<code>CRITICAL</code> | <code>ERROR</code> | <code>WARNING</code> | <code>INFO</code> | <code>DEBUG</code>) Minimum logging level. <code>INFO</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/factory/","title":"proxystore.factory","text":"<code>proxystore/factory.py</code> <p>Factory implementations.</p> <p>Factories are callable classes that wrap up the functionality needed to resolve a proxy, where resolving is the process of retrieving the object from wherever it is stored such that the proxy can act as the object.</p>"},{"location":"api/factory/#proxystore.factory.Factory","title":"Factory","text":"<pre><code>Factory() -&gt; None\n</code></pre> <p>         Bases: <code>Generic[T]</code></p> <p>Abstract Factory Class.</p> <p>A factory is a callable object that when called, returns an object. The <code>Proxy</code> constructor takes an instance of a factory and calls the factory when the proxy does its just-in-time resolution.</p> Note <p>If a custom factory is not-pickleable, <code>__getnewargs_ex__</code> may need to be implemented. Writing custom pickling functions is also beneifical to ensure that a pickled factory does not contain the object itself, just what is needed to resolve the object to keep the final pickled factory as small as possible.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def __init__(self) -&gt; None:\nraise NotImplementedError\n</code></pre>"},{"location":"api/factory/#proxystore.factory.Factory.__call__","title":"__call__()","text":"<pre><code>__call__() -&gt; T\n</code></pre> <p>Alias <code>Factory.resolve()</code>.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def __call__(self) -&gt; T:\n\"\"\"Alias [`Factory.resolve()`][proxystore.factory.Factory.resolve].\"\"\"\nreturn self.resolve()\n</code></pre>"},{"location":"api/factory/#proxystore.factory.Factory.resolve","title":"resolve()","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Resolve and return object.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Resolve and return object.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"api/factory/#proxystore.factory.SimpleFactory","title":"SimpleFactory","text":"<pre><code>SimpleFactory(obj: T) -&gt; None\n</code></pre> <p>         Bases: <code>Factory[T]</code></p> <p>Simple Factory that stores object as class attribute.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T</code>)         \u2013 <p>Object to produce when factory is called.</p> </li> </ul> Source code in <code>proxystore/factory.py</code> <pre><code>def __init__(self, obj: T) -&gt; None:\nself._obj = obj\n</code></pre>"},{"location":"api/factory/#proxystore.factory.SimpleFactory.resolve","title":"resolve()","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Return the object.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Return the object.\"\"\"\nreturn self._obj\n</code></pre>"},{"location":"api/factory/#proxystore.factory.LambdaFactory","title":"LambdaFactory","text":"<pre><code>LambdaFactory(\ntarget: Callable[..., T], *args: Any, **kwargs: Any\n) -&gt; None\n</code></pre> <p>         Bases: <code>Factory[T]</code></p> <p>Factory that takes any callable object.</p> <p>Parameters:</p> <ul> <li> target             (<code>Callable[..., T]</code>)         \u2013 <p>Callable object (function, class, lambda) to be invoked when the factory is resolved.</p> </li> <li> args             (<code>Any</code>)         \u2013 <p>Argument tuple for target invocation.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Dictionary of keyword arguments for target invocation.</p> </li> </ul> Source code in <code>proxystore/factory.py</code> <pre><code>def __init__(\nself,\ntarget: Callable[..., T],\n*args: Any,\n**kwargs: Any,\n) -&gt; None:\nself._target = target\nself._args = args\nself._kwargs = kwargs\n</code></pre>"},{"location":"api/factory/#proxystore.factory.LambdaFactory.resolve","title":"resolve()","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Return the target object.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Return the target object.\"\"\"\nreturn self._target(*self._args, **self._kwargs)\n</code></pre>"},{"location":"api/globus/","title":"proxystore.globus","text":"<code>proxystore/globus.py</code> <p>Globus OAuth tools.</p> <p>ProxyStore provides the <code>proxystore-globus-auth</code> CLI tool to give consent to the ProxyStore Globus Application.</p> <pre><code># basic authentication\nproxystore-globus-auth\n# delete old tokens\nproxystore-globus-auth --delete\n# give consent for specific collections\nproxystore-globus-auth --collections COLLECTION_UUID COLLECTION_UUID ...\n# specify additional scopes\nproxystore-globus-auth --scopes SCOPE SCOPE ...\n</code></pre> <p>Based on Parsl's implementation and the Globus examples.</p>"},{"location":"api/globus/#proxystore.globus.GlobusAuthFileError","title":"GlobusAuthFileError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised if the Globus Auth token file cannot be read.</p>"},{"location":"api/globus/#proxystore.globus.load_tokens_from_file","title":"load_tokens_from_file()","text":"<pre><code>load_tokens_from_file(\nfilepath: str,\n) -&gt; dict[str, dict[str, Any]]\n</code></pre> <p>Load a set of saved tokens.</p> <p>Parameters:</p> <ul> <li> filepath             (<code>str</code>)         \u2013 <p>Filepath containing JSON tokens to load.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, dict[str, Any]]</code>         \u2013 <p>JSON data from tokens file.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def load_tokens_from_file(filepath: str) -&gt; dict[str, dict[str, Any]]:\n\"\"\"Load a set of saved tokens.\n    Args:\n        filepath: Filepath containing JSON tokens to load.\n    Returns:\n        JSON data from tokens file.\n    \"\"\"\nwith open(filepath) as f:\nreturn json.load(f)\n</code></pre>"},{"location":"api/globus/#proxystore.globus.save_tokens_to_file","title":"save_tokens_to_file()","text":"<pre><code>save_tokens_to_file(\nfilepath: str, tokens: globus_sdk.OAuthTokenResponse\n) -&gt; None\n</code></pre> <p>Save a set of tokens for later use.</p> <p>Parameters:</p> <ul> <li> filepath             (<code>str</code>)         \u2013 <p>Filepath to write tokens to.</p> </li> <li> tokens             (<code>globus_sdk.OAuthTokenResponse</code>)         \u2013 <p>Tokens returned by the Globus API.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def save_tokens_to_file(\nfilepath: str,\ntokens: globus_sdk.OAuthTokenResponse,\n) -&gt; None:\n\"\"\"Save a set of tokens for later use.\n    Args:\n        filepath: Filepath to write tokens to.\n        tokens: Tokens returned by the Globus API.\n    \"\"\"\nwith open(filepath, 'w') as f:\njson.dump(tokens.by_resource_server, f, indent=4)\n</code></pre>"},{"location":"api/globus/#proxystore.globus.authenticate","title":"authenticate()","text":"<pre><code>authenticate(\nclient_id: str,\nredirect_uri: str | None = None,\nrequested_scopes: Iterable[str] | None = None,\n) -&gt; globus_sdk.OAuthTokenResponse\n</code></pre> <p>Perform Native App auth flow.</p> <p>This will print a link to <code>auth.globus.org</code> where the user will continue the authentication process. Then the function will wait on the user to input the authorization code.</p> <p>Parameters:</p> <ul> <li> client_id             (<code>str</code>)         \u2013 <p>Globus app ID.</p> </li> <li> redirect_uri             (<code>str | None</code>)         \u2013 <p>The page to direct users to after authentication.</p> </li> <li> requested_scopes             (<code>Iterable[str] | None</code>)         \u2013 <p>Iterable of scopes on the token being requested.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>globus_sdk.OAuthTokenResponse</code>         \u2013 <p>Tokens returned by the Globus API.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def authenticate(\nclient_id: str,\nredirect_uri: str | None = None,\nrequested_scopes: Iterable[str] | None = None,\n) -&gt; globus_sdk.OAuthTokenResponse:\n\"\"\"Perform Native App auth flow.\n    This will print a link to `auth.globus.org` where the user will\n    continue the authentication process. Then the function will wait on\n    the user to input the authorization code.\n    Args:\n        client_id: Globus app ID.\n        redirect_uri: The page to direct users to after authentication.\n        requested_scopes: Iterable of scopes on the token being requested.\n    Returns:\n        Tokens returned by the Globus API.\n    \"\"\"\nclient = globus_sdk.NativeAppAuthClient(client_id=client_id)\nclient.oauth2_start_flow(\nredirect_uri=redirect_uri,\nrefresh_tokens=True,\nrequested_scopes=requested_scopes,\n)\nurl = client.oauth2_get_authorize_url()\nclick.secho('Please visit the following url to authenticate:', fg='cyan')\nclick.echo(url)\nauth_code = click.prompt(\nclick.style('Enter the auth code:', fg='cyan'),\nprompt_suffix=' ',\n)\nauth_code = auth_code.strip()\nreturn client.oauth2_exchange_code_for_tokens(auth_code)\n</code></pre>"},{"location":"api/globus/#proxystore.globus.get_authorizer","title":"get_authorizer()","text":"<pre><code>get_authorizer(\nclient_id: str, tokens_file: str\n) -&gt; globus_sdk.RefreshTokenAuthorizer\n</code></pre> <p>Get an authorizer for the Globus SDK.</p> <p>Parameters:</p> <ul> <li> client_id             (<code>str</code>)         \u2013 <p>Globus app ID.</p> </li> <li> tokens_file             (<code>str</code>)         \u2013 <p>Filepath to saved Globus Auth tokens.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>globus_sdk.RefreshTokenAuthorizer</code>         \u2013 <p>Authorizer than can be used with other parts of the Globus SDK.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>GlobusAuthFileError</code>           \u2013         <p>If <code>tokens_file</code> cannot be parsed.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def get_authorizer(\nclient_id: str,\ntokens_file: str,\n) -&gt; globus_sdk.RefreshTokenAuthorizer:\n\"\"\"Get an authorizer for the Globus SDK.\n    Args:\n        client_id: Globus app ID.\n        tokens_file: Filepath to saved Globus Auth tokens.\n    Returns:\n        Authorizer than can be used with other parts of the Globus SDK.\n    Raises:\n        GlobusAuthFileError: If `tokens_file` cannot be parsed.\n    \"\"\"\ntry:\ntokens = load_tokens_from_file(tokens_file)\nexcept OSError as e:\nraise GlobusAuthFileError(\nf'Error loading tokens from {tokens_file}: {e}.',\n) from e\ntransfer_tokens = tokens['transfer.api.globus.org']\nauth_client = globus_sdk.NativeAppAuthClient(client_id=client_id)\nreturn globus_sdk.RefreshTokenAuthorizer(\ntransfer_tokens['refresh_token'],\nauth_client,\naccess_token=transfer_tokens['access_token'],\nexpires_at=transfer_tokens['expires_at_seconds'],\non_refresh=functools.partial(save_tokens_to_file, tokens_file),\n)\n</code></pre>"},{"location":"api/globus/#proxystore.globus.proxystore_authenticate","title":"proxystore_authenticate()","text":"<pre><code>proxystore_authenticate(\nproxystore_dir: str | None = None,\ncollections: list[str] | None = None,\nadditional_scopes: list[str] | None = None,\n) -&gt; str\n</code></pre> <p>Perform auth flow for ProxyStore native app.</p> <p>This is a wrapper around <code>authenticate()</code> which stores tokens in the ProxyStore home directory and requests the appropriate scopes for ProxyStore.</p> Alert <p>Globus Connect Server v5 uses consents rather than activations so users need to consent to the Transfer service accessing the specific mapped collection on behalf of the user. Read more here.</p> <p>Parameters:</p> <ul> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> <li> collections             (<code>list[str] | None</code>)         \u2013 <p>Globus Collection UUIDs to request transfer scopes for.</p> </li> <li> additional_scopes             (<code>list[str] | None</code>)         \u2013 <p>Extra scopes to include in the authorization request.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Path to saved tokens file.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def proxystore_authenticate(\nproxystore_dir: str | None = None,\ncollections: list[str] | None = None,\nadditional_scopes: list[str] | None = None,\n) -&gt; str:\n\"\"\"Perform auth flow for ProxyStore native app.\n    This is a wrapper around [`authenticate()`][proxystore.globus.authenticate]\n    which stores tokens in the ProxyStore home directory and requests the\n    appropriate scopes for ProxyStore.\n    Alert:\n        Globus Connect Server v5 uses consents rather than activations so\n        users need to consent to the Transfer service accessing the\n        specific mapped collection on behalf of the user. Read more\n        [here](https://docs.globus.org/globus-connect-server/migrating-to-v5.4/application-migration/#activation_is_replaced_by_consent){target=_blank}.\n    Args:\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n        collections: Globus Collection UUIDs to request transfer scopes for.\n        additional_scopes: Extra scopes to include in the authorization\n            request.\n    Returns:\n        Path to saved tokens file.\n    \"\"\"\nproxystore_dir = home_dir() if proxystore_dir is None else proxystore_dir\ntokens_file = os.path.join(proxystore_dir, _TOKENS_FILE)\nos.makedirs(proxystore_dir, exist_ok=True)\nscopes = _get_proxystore_scopes(collections, additional_scopes)\ntokens = authenticate(\nclient_id=_APPLICATION_ID,\nredirect_uri=_REDIRECT_URI,\nrequested_scopes=scopes,\n)\nsave_tokens_to_file(tokens_file, tokens)\nreturn tokens_file\n</code></pre>"},{"location":"api/globus/#proxystore.globus.get_proxystore_authorizer","title":"get_proxystore_authorizer()","text":"<pre><code>get_proxystore_authorizer(\nproxystore_dir: str | None = None,\n) -&gt; globus_sdk.RefreshTokenAuthorizer\n</code></pre> <p>Get an authorizer for the ProxyStore native app.</p> <p><code>proxystore_authenticate()</code> or the CLI <code>proxystore-globus-auth</code> should be performed prior to calling this function to ensure tokens have been acquired.</p> <p>Parameters:</p> <ul> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>globus_sdk.RefreshTokenAuthorizer</code>         \u2013 <p>Authorizer than can be used with other parts of the Globus SDK.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def get_proxystore_authorizer(\nproxystore_dir: str | None = None,\n) -&gt; globus_sdk.RefreshTokenAuthorizer:\n\"\"\"Get an authorizer for the ProxyStore native app.\n    [`proxystore_authenticate()`][proxystore.globus.proxystore_authenticate]\n    or the CLI `#!bash proxystore-globus-auth` should be performed prior to\n    calling this function to ensure tokens have been acquired.\n    Args:\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Authorizer than can be used with other parts of the Globus SDK.\n    \"\"\"\nproxystore_dir = home_dir() if proxystore_dir is None else proxystore_dir\ntokens_file = os.path.join(proxystore_dir, _TOKENS_FILE)\nreturn get_authorizer(client_id=_APPLICATION_ID, tokens_file=tokens_file)\n</code></pre>"},{"location":"api/globus/#proxystore.globus.cli","title":"cli()","text":"<pre><code>cli(\ncollection: list[str], scope: list[str], delete: bool\n) -&gt; None\n</code></pre> <p>Perform Globus authentication for the Transfer service.</p> <p>Collections or scopes options can be strung together. E.g., request transfer scope for multiple collections with:</p> <p>$ proxystore-globus-auth -c UUID -c UUID -c UUID</p> Source code in <code>proxystore/globus.py</code> <pre><code>@click.command()\n@click.option(\n'--collection',\n'-c',\nmetavar='UUID',\nmultiple=True,\nhelp='Globus Collection UUID to request transfer scopes for.',\n)\n@click.option(\n'--scope',\n'-s',\nmetavar='SCOPE',\nmultiple=True,\nhelp='Additional scope to request.',\n)\n@click.option(\n'--delete',\nis_flag=True,\ndefault=False,\nhelp='Delete existing tokens.',\n)\ndef cli(collection: list[str], scope: list[str], delete: bool) -&gt; None:\n\"\"\"Perform Globus authentication for the Transfer service.\n    Collections or scopes options can be strung together. E.g.,\n    request transfer scope for multiple collections with:\n    $ proxystore-globus-auth -c UUID -c UUID -c UUID\n    \"\"\"\nif delete:\ntokens_file = os.path.join(home_dir(), _TOKENS_FILE)\nfp = click.format_filename(tokens_file)\nif os.path.exists(tokens_file):\nos.remove(tokens_file)\nclick.echo(f'Deleted tokens file: {fp}')\nreturn\nelse:\nclick.echo(f'Tokens file does not exist: {fp}')\nraise SystemExit(1)\ntry:\nget_proxystore_authorizer()\nexcept GlobusAuthFileError:\ntokens_file = proxystore_authenticate(\ncollections=collection,\nadditional_scopes=scope,\n)\nget_proxystore_authorizer()\nclick.echo(f'Tokens saved to: {click.format_filename(tokens_file)}')\nelse:\nclick.echo(\n'Globus authorization is already completed.\\n\\n'\n'To re-authenticate, delete your tokens and try again.\\n'\n'  $ proxystore-globus-auth --delete',\n)\n</code></pre>"},{"location":"api/legacy-docs/","title":"Legacy Docs","text":"<p>Legacy documentation for ProxyStore versions prior to v0.4.1 can be found at proxystore.readthedocs.io.</p>"},{"location":"api/proxy/","title":"proxystore.proxy","text":"<code>proxystore/proxy.py</code> <p>Proxy implementation and helpers.</p>"},{"location":"api/proxy/#proxystore.proxy.Proxy","title":"Proxy","text":"<pre><code>Proxy(factory: FactoryType[T]) -&gt; None\n</code></pre> <p>         Bases: <code>slots.Proxy</code>, <code>Generic[T]</code></p> <p>Lazy Object Proxy.</p> <p>An extension of the Proxy from lazy-object-proxy with modified pickling behavior.</p> <p>An object proxy acts as a thin wrapper around a Python object, i.e. the proxy behaves identically to the underlying object. The proxy is initialized with a callable factory object. The factory returns the underlying object when called, i.e. 'resolves' the proxy. The does just-in-time resolution, i.e., the proxy does not call the factory until the first access to the proxy (hence, the lazy aspect of the proxy).</p> <p>The factory contains the mechanisms to appropriately resolve the object, e.g., which in the case for ProxyStore means requesting the correct object from the backend store.</p> <pre><code>x = np.array([1, 2, 3])\nf = ps.factory.SimpleFactory(x)\np = ps.proxy.Proxy(f)\nassert isinstance(p, np.ndarray)\nassert np.array_equal(p, [1, 2, 3])\n</code></pre> Note <p>The <code>factory</code>, by default, is only ever called once during the lifetime of a proxy instance.</p> Note <p>When a proxy instance is pickled, only the <code>factory</code> is pickled, not the wrapped object. Thus, proxy instances can be pickled and passed around cheaply, and once the proxy is unpickled and used, the <code>factory</code> will be called again to resolve the object.</p> Warning <p>Python bindings to other languages (e.g., C, C++) may throw type errors when receiving a <code>Proxy</code> instance. Casting the proxy or extracting the target object may be needed.</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; from proxystore.proxy import Proxy\n&gt;&gt;&gt; s = 'mystring'\n&gt;&gt;&gt; p = Proxy(lambda: s)\n&gt;&gt;&gt; io.StringIO(p)\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: initial_value must be str or None, not Proxy\n&gt;&gt;&gt; io.StringIO(str(p))  # succeeds\n</code></pre> <p>Parameters:</p> <ul> <li> factory             (<code>FactoryType[T]</code>)         \u2013 <p>Callable object that returns the underlying object when called.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If <code>factory</code> is not callable.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def __init__(self, factory: FactoryType[T]) -&gt; None:\nif not callable(factory):\nraise TypeError('factory must be callable')\nsuper().__init__(factory)\n</code></pre>"},{"location":"api/proxy/#proxystore.proxy.ProxyLocker","title":"ProxyLocker","text":"<pre><code>ProxyLocker(proxy: Proxy[T]) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[T]</code></p> <p>Proxy locker that prevents resolution of wrapped proxies.</p> <p>The class prevents unintended access to a wrapped proxy to ensure a proxy is not resolved. The wrapped proxy can be retrieved with <code>proxy = ProxyLocker(proxy).unlock()</code>.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>Proxy[T]</code>)         \u2013 <p>Proxy to lock.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def __init__(self, proxy: Proxy[T]) -&gt; None:\nself._proxy = proxy\n</code></pre>"},{"location":"api/proxy/#proxystore.proxy.ProxyLocker.unlock","title":"unlock()","text":"<pre><code>unlock() -&gt; Proxy[T]\n</code></pre> <p>Retrieve the locked proxy.</p> <p>Returns:</p> <ul> <li> <code>Proxy[T]</code>         \u2013 <p>Proxy object.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def unlock(self) -&gt; Proxy[T]:\n\"\"\"Retrieve the locked proxy.\n    Returns:\n        Proxy object.\n    \"\"\"\nreturn super().__getattribute__('_proxy')\n</code></pre>"},{"location":"api/proxy/#proxystore.proxy.extract","title":"extract()","text":"<pre><code>extract(proxy: proxystore.proxy.Proxy[T]) -&gt; T\n</code></pre> <p>Return object wrapped by proxy.</p> <p>If the proxy has not been resolved yet, this will force the proxy to be resolved prior.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>proxystore.proxy.Proxy[T]</code>)         \u2013 <p>Proxy instance to extract from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code>         \u2013 <p>Object wrapped by proxy.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def extract(proxy: proxystore.proxy.Proxy[T]) -&gt; T:\n\"\"\"Return object wrapped by proxy.\n    If the proxy has not been resolved yet, this will force\n    the proxy to be resolved prior.\n    Args:\n        proxy: Proxy instance to extract from.\n    Returns:\n        Object wrapped by proxy.\n    \"\"\"\nreturn proxy.__wrapped__\n</code></pre>"},{"location":"api/proxy/#proxystore.proxy.is_resolved","title":"is_resolved()","text":"<pre><code>is_resolved(proxy: proxystore.proxy.Proxy[T]) -&gt; bool\n</code></pre> <p>Check if a proxy is resolved.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>proxystore.proxy.Proxy[T]</code>)         \u2013 <p>Proxy instance to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p><code>True</code> if <code>proxy</code> is resolved (i.e., the <code>factory</code> has been called)         and <code>False</code> otherwise.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def is_resolved(proxy: proxystore.proxy.Proxy[T]) -&gt; bool:\n\"\"\"Check if a proxy is resolved.\n    Args:\n        proxy: Proxy instance to check.\n    Returns:\n        `True` if `proxy` is resolved (i.e., the `factory` has been called) \\\n        and `False` otherwise.\n    \"\"\"\nreturn proxy.__resolved__\n</code></pre>"},{"location":"api/proxy/#proxystore.proxy.resolve","title":"resolve()","text":"<pre><code>resolve(proxy: proxystore.proxy.Proxy[T]) -&gt; None\n</code></pre> <p>Force a proxy to resolve itself.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>proxystore.proxy.Proxy[T]</code>)         \u2013 <p>Proxy instance to force resolve.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def resolve(proxy: proxystore.proxy.Proxy[T]) -&gt; None:\n\"\"\"Force a proxy to resolve itself.\n    Args:\n        proxy: Proxy instance to force resolve.\n    \"\"\"\nproxy.__wrapped__  # noqa: B018\n</code></pre>"},{"location":"api/serialize/","title":"proxystore.serialize","text":"<code>proxystore/serialize.py</code> <p>Serialization functions.</p>"},{"location":"api/serialize/#proxystore.serialize.SerializationError","title":"SerializationError","text":"<p>         Bases: <code>Exception</code></p> <p>Base Serialization Exception.</p>"},{"location":"api/serialize/#proxystore.serialize.serialize","title":"serialize()","text":"<pre><code>serialize(obj: Any) -&gt; bytes\n</code></pre> <p>Serialize object.</p> <p>Objects are serialized using pickle (protocol 4) except for bytes or str objects. If pickle fails, cloudpickle is used as a fallback.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>Object to serialize.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>         \u2013 <p>Bytes that can be passed to         <code>deserialize()</code>.</p> </li> </ul> Source code in <code>proxystore/serialize.py</code> <pre><code>def serialize(obj: Any) -&gt; bytes:\n\"\"\"Serialize object.\n    Objects are serialized using\n    [pickle](https://docs.python.org/3/library/pickle.html){target=_blank}\n    (protocol 4) except for [bytes][] or [str][] objects.\n    If pickle fails,\n    [cloudpickle](https://github.com/cloudpipe/cloudpickle){target=_blank}\n    is used as a fallback.\n    Args:\n        obj: Object to serialize.\n    Returns:\n        Bytes that can be passed to \\\n        [`deserialize()`][proxystore.serialize.deserialize].\n    \"\"\"\nif isinstance(obj, bytes):\nidentifier = b'01\\n'\nelif isinstance(obj, str):\nidentifier = b'02\\n'\nobj = obj.encode()\nelse:\n# Use cloudpickle if pickle fails\ntry:\nidentifier = b'03\\n'\n# Pickle protocol 4 is available in Python 3.7 and later but not\n# the default in Python 3.7 so manually specify it.\nobj = pickle.dumps(obj, protocol=4)\nexcept Exception:\nidentifier = b'04\\n'\nobj = cloudpickle.dumps(obj)\nassert isinstance(identifier, bytes)\nassert isinstance(obj, bytes)\nreturn identifier + obj\n</code></pre>"},{"location":"api/serialize/#proxystore.serialize.deserialize","title":"deserialize()","text":"<pre><code>deserialize(data: bytes) -&gt; Any\n</code></pre> <p>Deserialize object.</p> <p>Parameters:</p> <ul> <li> data             (<code>bytes</code>)         \u2013 <p>Bytes produced by <code>serialize()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>         \u2013 <p>The deserialized object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>data</code> is not of type <code>bytes</code>.</p> </li> <li> <code>SerializationError</code>           \u2013         <p>If the identifier of <code>data</code> is missing or invalid. The identifier is prepended to the string in <code>serialize()</code> to indicate which serialization method was used (e.g., no serialization, pickle, etc.).</p> </li> </ul> Source code in <code>proxystore/serialize.py</code> <pre><code>def deserialize(data: bytes) -&gt; Any:\n\"\"\"Deserialize object.\n    Args:\n        data: Bytes produced by\n            [`serialize()`][proxystore.serialize.serialize].\n    Returns:\n        The deserialized object.\n    Raises:\n        ValueError: If `data` is not of type `bytes`.\n        SerializationError: If the identifier of `data` is missing or\n            invalid. The identifier is prepended to the string in\n            [`serialize()`][proxystore.serialize.serialize] to indicate which\n            serialization method was used (e.g., no serialization, pickle,\n            etc.).\n    \"\"\"\nif not isinstance(data, bytes):\nraise ValueError(\nf'Expected data to be of type bytes, not {type(data)}.',\n)\nidentifier, separator, data = data.partition(b'\\n')\nif separator == b'' or len(identifier) != len(b'00'):\nraise SerializationError(\n'Data does not have required identifier for deserialization.',\n)\nif identifier == b'01':\nreturn data\nelif identifier == b'02':\nreturn data.decode()\nelif identifier == b'03':\nreturn pickle.loads(data)\nelif identifier == b'04':\nreturn cloudpickle.loads(data)\nelse:\nraise SerializationError(\nf'Unknown identifier {identifier!r} for deserialization,',\n)\n</code></pre>"},{"location":"api/timer/","title":"proxystore.timer","text":"<code>proxystore/timer.py</code> <p>Timing utilities.</p>"},{"location":"api/timer/#proxystore.timer.Timer","title":"Timer","text":"<pre><code>Timer() -&gt; None\n</code></pre> <p>Performance timer with nanosecond precision.</p> Example <pre><code>from proxystore.timer import Timer\nwith Timer() as timer:\n...\nprint(timer.elapsed_ms)\n</code></pre> Example <pre><code>from proxystore.timer import Timer\ntimer = Timer()\ntimer.start()\n...\ntimer.stop()\nprint(timer.elapsed_ms)\n</code></pre> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013         <p>If the elapsed time is accessed before the timer is stopped or the context block is exited.</p> </li> </ul> Source code in <code>proxystore/timer.py</code> <pre><code>def __init__(self) -&gt; None:\nself._start = 0\nself._end = 0\nself._running = False\n</code></pre>"},{"location":"api/timer/#proxystore.timer.Timer.elapsed_ns","title":"elapsed_ns  <code>property</code>","text":"<pre><code>elapsed_ns: int\n</code></pre> <p>Elapsed time in nanoseconds.</p>"},{"location":"api/timer/#proxystore.timer.Timer.elapsed_ms","title":"elapsed_ms  <code>property</code>","text":"<pre><code>elapsed_ms: float\n</code></pre> <p>Elapsed time in milliseconds.</p>"},{"location":"api/timer/#proxystore.timer.Timer.elapsed_s","title":"elapsed_s  <code>property</code>","text":"<pre><code>elapsed_s: float\n</code></pre> <p>Elapsed time in seconds.</p>"},{"location":"api/timer/#proxystore.timer.Timer.start","title":"start()","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the timer.</p> Source code in <code>proxystore/timer.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start the timer.\"\"\"\nself._running = True\nself._start = time.perf_counter_ns()\n</code></pre>"},{"location":"api/timer/#proxystore.timer.Timer.stop","title":"stop()","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the timer.</p> Source code in <code>proxystore/timer.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Stop the timer.\"\"\"\nself._end = time.perf_counter_ns()\nself._running = False\n</code></pre>"},{"location":"api/utils/","title":"proxystore.utils","text":"<code>proxystore/utils.py</code> <p>General purpose utility functions.</p>"},{"location":"api/utils/#proxystore.utils.chunk_bytes","title":"chunk_bytes()","text":"<pre><code>chunk_bytes(\ndata: bytes, chunk_size: int\n) -&gt; Generator[bytes, None, None]\n</code></pre> <p>Yield chunks of binary data.</p> <p>Parameters:</p> <ul> <li> data             (<code>bytes</code>)         \u2013 <p>Data to be chunked.</p> </li> <li> chunk_size             (<code>int</code>)         \u2013 <p>Chunk size in bytes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Generator[bytes, None, None]</code>         \u2013 <p>Generator that yields chunks of bytes.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def chunk_bytes(\ndata: bytes,\nchunk_size: int,\n) -&gt; Generator[bytes, None, None]:\n\"\"\"Yield chunks of binary data.\n    Args:\n        data: Data to be chunked.\n        chunk_size: Chunk size in bytes.\n    Returns:\n        Generator that yields chunks of bytes.\n    \"\"\"\nlength = len(data)\nfor index in range(0, length, chunk_size):\nyield data[index : min(index + chunk_size, length)]\n</code></pre>"},{"location":"api/utils/#proxystore.utils.create_key","title":"create_key()","text":"<pre><code>create_key(obj: Any) -&gt; str\n</code></pre> <p>Generate key for the object.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>Object to create key for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>A random 128 bit string.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def create_key(obj: Any) -&gt; str:\n\"\"\"Generate key for the object.\n    Args:\n        obj: Object to create key for.\n    Returns:\n        A random 128 bit string.\n    \"\"\"\nreturn str(random.getrandbits(128))\n</code></pre>"},{"location":"api/utils/#proxystore.utils.fullname","title":"fullname()","text":"<pre><code>fullname(obj: Any) -&gt; str\n</code></pre> <p>Return full name of object.</p> Source code in <code>proxystore/utils.py</code> <pre><code>def fullname(obj: Any) -&gt; str:\n\"\"\"Return full name of object.\"\"\"\nif hasattr(obj, '__module__'):\nmodule = obj.__module__\nelse:\nmodule = obj.__class__.__module__\nif hasattr(obj, '__name__'):\nname = obj.__name__\nelse:\nname = obj.__class__.__name__\nif module is None or module == str.__module__:\nreturn name\nreturn f'{module}.{name}'\n</code></pre>"},{"location":"api/utils/#proxystore.utils.get_class_path","title":"get_class_path()","text":"<pre><code>get_class_path(cls: type[Any]) -&gt; str\n</code></pre> <p>Get the fully qualified path of a type.</p> Example <pre><code>&gt;&gt;&gt; from proxystore.connectors.connector import Connector\n&gt;&gt;&gt; get_class_path(Connector)\n'proxystore.connectors.connector.Connector'\n</code></pre> <p>Parameters:</p> <ul> <li> cls             (<code>type[Any]</code>)         \u2013 <p>Class type to get fully qualified path of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Fully qualified path of <code>cls</code>.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def get_class_path(cls: type[Any]) -&gt; str:\n\"\"\"Get the fully qualified path of a type.\n    Example:\n        ```python\n        &gt;&gt;&gt; from proxystore.connectors.connector import Connector\n        &gt;&gt;&gt; get_class_path(Connector)\n        'proxystore.connectors.connector.Connector'\n        ```\n    Args:\n        cls: Class type to get fully qualified path of.\n    Returns:\n        Fully qualified path of `cls`.\n    \"\"\"\nreturn f'{cls.__module__}.{cls.__qualname__}'\n</code></pre>"},{"location":"api/utils/#proxystore.utils.import_class","title":"import_class()","text":"<pre><code>import_class(path: str) -&gt; type[Any]\n</code></pre> <p>Import class via its fully qualified path.</p> Example <pre><code>&gt;&gt;&gt; import_class('proxystore.connectors.connector.Connector')\n&lt;class 'proxystore.connectors.connector.Connector'&gt;\n</code></pre> <p>Parameters:</p> <ul> <li> path             (<code>str</code>)         \u2013 <p>Fully qualified path of class to import.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Any]</code>         \u2013 <p>Imported class.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ImportError</code>           \u2013         <p>If a class at the <code>path</code> is not found.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def import_class(path: str) -&gt; type[Any]:\n\"\"\"Import class via its fully qualified path.\n    Example:\n        ```python\n        &gt;&gt;&gt; import_class('proxystore.connectors.connector.Connector')\n        &lt;class 'proxystore.connectors.connector.Connector'&gt;\n        ```\n    Args:\n        path: Fully qualified path of class to import.\n    Returns:\n        Imported class.\n    Raises:\n        ImportError: If a class at the `path` is not found.\n    \"\"\"\nmodule_path, _, name = path.rpartition('.')\nif len(module_path) == 0:\nraise ImportError(\nf'Class path must contain at least one module. Got {path}',\n)\nmodule = importlib.import_module(module_path)\nreturn getattr(module, name)\n</code></pre>"},{"location":"api/utils/#proxystore.utils.home_dir","title":"home_dir()","text":"<pre><code>home_dir() -&gt; str\n</code></pre> <p>Return the absolute path to the proxystore home directory.</p> <p>If set, <code>$PROXYSTORE_HOME</code> is preferred. Otherwise, <code>$XDG_DATA_HOME/proxystore</code> is returned where <code>$XDG_DATA_HOME</code> defaults to <code>$HOME/.local/share</code> if unset.</p> Source code in <code>proxystore/utils.py</code> <pre><code>def home_dir() -&gt; str:\n\"\"\"Return the absolute path to the proxystore home directory.\n    If set, `$PROXYSTORE_HOME` is preferred. Otherwise,\n    `$XDG_DATA_HOME/proxystore` is returned where `$XDG_DATA_HOME` defaults\n    to `$HOME/.local/share` if unset.\n    \"\"\"\npath = os.environ.get('PROXYSTORE_HOME')\nif path is None:\nprefix = os.environ.get('XDG_DATA_HOME') or os.path.expanduser(\n'~/.local/share',\n)\npath = os.path.join(prefix, 'proxystore')\nreturn os.path.abspath(path)\n</code></pre>"},{"location":"api/utils/#proxystore.utils.hostname","title":"hostname()","text":"<pre><code>hostname() -&gt; str\n</code></pre> <p>Return current hostname.</p> Source code in <code>proxystore/utils.py</code> <pre><code>def hostname() -&gt; str:\n\"\"\"Return current hostname.\"\"\"\nreturn socket.gethostname()\n</code></pre>"},{"location":"api/utils/#proxystore.utils.bytes_to_readable","title":"bytes_to_readable()","text":"<pre><code>bytes_to_readable(size: int, precision: int = 3) -&gt; str\n</code></pre> <p>Convert bytes to human readable value.</p> Note <p>This method uses base-10 values for KB, MB, GB, etc. instead of base-2 values (i.e., KiB, MiB, GiB, etc.).</p> <p>Parameters:</p> <ul> <li> size             (<code>int</code>)         \u2013 <p>Byte value to make readable.</p> </li> <li> precision             (<code>int</code>)         \u2013 <p>Number of decimal places.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>String with human readable number of bytes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If size is negative.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def bytes_to_readable(size: int, precision: int = 3) -&gt; str:\n\"\"\"Convert bytes to human readable value.\n    Note:\n        This method uses base-10 values for KB, MB, GB, etc. instead of\n        base-2 values (i.e., KiB, MiB, GiB, etc.).\n    Args:\n        size: Byte value to make readable.\n        precision: Number of decimal places.\n    Returns:\n        String with human readable number of bytes.\n    Raises:\n        ValueError: If size is negative.\n    \"\"\"\nkb = int(1e3)\nmb = int(1e6)\ngb = int(1e9)\ntb = int(1e12)\nsize_ = float(size)\nif 0 &lt;= size &lt; kb:\nsuffix = 'B'\nelif kb &lt;= size &lt; mb:\nsuffix = 'KB'\nsize_ /= kb\nelif mb &lt;= size &lt; gb:\nsuffix = 'MB'\nsize_ /= mb\nelif gb &lt;= size &lt; tb:\nsuffix = 'GB'\nsize_ /= gb\nelif tb &lt;= size:\nsuffix = 'TB'\nsize_ /= tb\nelse:\nraise ValueError(f'Size ({size}) cannot be negative.')\nvalue = str(round(size_, precision))\nvalue = value.rstrip('0').rstrip('.')\nreturn f'{value} {suffix}'\n</code></pre>"},{"location":"api/utils/#proxystore.utils.readable_to_bytes","title":"readable_to_bytes()","text":"<pre><code>readable_to_bytes(size: str) -&gt; int\n</code></pre> <p>Convert string with bytes units to the integer value of bytes.</p> Example <pre><code>&gt;&gt;&gt; readable_to_bytes('1.2 KB')\n1200\n&gt;&gt;&gt; readable_to_bytes('0.6 MiB')\n629146\n</code></pre> <p>Parameters:</p> <ul> <li> size             (<code>str</code>)         \u2013 <p>String to parse for bytes size.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Integer number of bytes parsed from the string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the input string contains more than two parts (i.e., a value and a unit).</p> </li> <li> <code>ValueError</code>           \u2013         <p>If the unit is not one of KB, MB, GB, TB, KiB, MiB, GiB, or TiB.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If the value cannot be cast to a float.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def readable_to_bytes(size: str) -&gt; int:\n\"\"\"Convert string with bytes units to the integer value of bytes.\n    Example:\n        ```python\n        &gt;&gt;&gt; readable_to_bytes('1.2 KB')\n        1200\n        &gt;&gt;&gt; readable_to_bytes('0.6 MiB')\n        629146\n        ```\n    Args:\n        size: String to parse for bytes size.\n    Returns:\n        Integer number of bytes parsed from the string.\n    Raises:\n        ValueError: If the input string contains more than two parts (i.e., a\n            value and a unit).\n        ValueError: If the unit is not one of KB, MB, GB, TB, KiB, MiB, GiB,\n            or TiB.\n        ValueError: If the value cannot be cast to a float.\n    \"\"\"\nunits_to_bytes = {\n'b': 1,\n'kb': int(1e3),\n'mb': int(1e6),\n'gb': int(1e9),\n'tb': int(1e12),\n'kib': int(2**10),\n'mib': int(2**20),\n'gib': int(2**30),\n'tib': int(2**40),\n}\n# Try casting size to value (will only work if no units)\ntry:\nreturn int(float(size))\nexcept ValueError:\npass\n# Ensure space between value and unit\nsize = re.sub(r'([a-zA-Z]+)', r' \\1', size.strip())\nparts = [s.strip() for s in size.split()]\nif len(parts) != 2:\nraise ValueError(\n'Input string \"{size}\" must contain only a value and a unit.',\n)\nvalue, unit = parts\ntry:\nvalue_size = decimal.Decimal(value)\nexcept decimal.InvalidOperation as e:\nraise ValueError(f'Unable to interpret \"{value}\" as a float.') from e\ntry:\nunit_size = units_to_bytes[unit.lower()]\nexcept KeyError as e:\nraise ValueError(f'Unknown unit type {unit}.') from e\nreturn int(value_size * unit_size)\n</code></pre>"},{"location":"api/warnings/","title":"proxystore.warnings","text":"<code>proxystore/warnings.py</code> <p>Warning types.</p>"},{"location":"api/warnings/#proxystore.warnings.ExperimentalWarning","title":"ExperimentalWarning","text":"<p>         Bases: <code>Warning</code></p> <p>ProxyStore experimental feature warning.</p>"},{"location":"api/connectors/","title":"proxystore.connectors","text":"<code>proxystore/connectors/__init__.py</code> <p>Connector implementations.</p> <p>A <code>Connector</code> is an interface to a mediated communication channel or object store. Connectors operate on low-level bytes and are used by the <code>Store</code> to store and get serialized Python objects.</p> <p>Third-party code can provide custom connectors by implementing the <code>Connector</code> protocol. (Note: because <code>Connector</code> is a <code>Protocol</code>, custom connectors do not need to inherit from <code>Connector</code>.)</p> Example <pre><code>from proxystore.connectors.file import FileConnector\nconnector = FileConnector('./data-store')\nkey = connector.put(b'hello')\nconnector.get(key)\n&gt;&gt;&gt; b'hello'\nconnector.evict(key)\nconnector.exists(key)\n&gt;&gt;&gt; False\nconnector.close()\n</code></pre> Tip <p>All of the <code>Connector</code> implementations in this module can be used as context managers. Context manager support is not a required component of the <code>Connector</code> protocol. It is simply provided for convenience with the native implementations. <pre><code>from proxystore.connectors.file import FileConnector\nwith FileConnector('./data-store') as connector:\n# connector.close() will be automatically called when the\n# context manager is exited\n...\n</code></pre></p>"},{"location":"api/connectors/connector/","title":"proxystore.connectors.connector","text":"<code>proxystore/connectors/connector.py</code> <p>Connector protocol.</p>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector","title":"Connector","text":"<p>         Bases: <code>Protocol[KeyT]</code></p> <p>Connector protocol for interfacing with external object storage.</p> <p>The Connector protocol defines the interface for interacting with a byte-level object store.</p>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>Connector configuration.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    Returns:\n        Connector configuration.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; Connector[Any]\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Connector[Any]</code>         \u2013 <p>Connector instance.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; Connector[Any]:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    Returns:\n        Connector instance.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.evict","title":"evict()","text":"<pre><code>evict(key: KeyT) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def evict(self, key: KeyT) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.exists","title":"exists()","text":"<pre><code>exists(key: KeyT) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def exists(self, key: KeyT) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.get","title":"get()","text":"<pre><code>get(key: KeyT) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def get(self, key: KeyT) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[KeyT]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[KeyT]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def get_batch(self, keys: Sequence[KeyT]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; KeyT\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>KeyT</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def put(self, obj: bytes) -&gt; KeyT:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/connector/#proxystore.connectors.connector.Connector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[KeyT]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[KeyT]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[KeyT]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/connector.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[KeyT]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/connectors/endpoint/","title":"proxystore.connectors.endpoint","text":"<code>proxystore/connectors/endpoint.py</code> <p>Endpoint connector implementation.</p>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnectorError","title":"EndpointConnectorError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception resulting from request to Endpoint.</p>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointKey","title":"EndpointKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to object in an Endpoint.</p>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointKey.object_id","title":"object_id  <code>class-attribute</code>","text":"<pre><code>object_id: str\n</code></pre> <p>Unique object ID.</p>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointKey.endpoint_id","title":"endpoint_id  <code>class-attribute</code>","text":"<pre><code>endpoint_id: str | None\n</code></pre> <p>Endpoint UUID where object is stored.</p>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector","title":"EndpointConnector","text":"<pre><code>EndpointConnector(\nendpoints: Sequence[str | UUID],\nproxystore_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>Connector to ProxyStore Endpoints.</p> Warning <p>Specifying a custom <code>proxystore_dir</code> can cause problems if the <code>proxystore_dir</code> is not the same on all systems that a proxy created by this store could end up on. It is recommended to leave the <code>proxystore_dir</code> unspecified so the correct default directory will be used.</p> <p>Parameters:</p> <ul> <li> endpoints             (<code>Sequence[str | UUID]</code>)         \u2013 <p>Sequence of valid and running endpoint UUIDs to use. At least one of these endpoints must be accessible by this process.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If endpoints is an empty list.</p> </li> <li> <code>EndpointConnectorError</code>           \u2013         <p>If unable to connect to one of the endpoints provided.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def __init__(\nself,\nendpoints: Sequence[str | UUID],\nproxystore_dir: str | None = None,\n) -&gt; None:\nif len(endpoints) == 0:\nraise ValueError('At least one endpoint must be specified.')\nself.endpoints: list[UUID] = [\ne if isinstance(e, UUID) else UUID(e, version=4) for e in endpoints\n]\nself.proxystore_dir = proxystore_dir\n# Find the first locally accessible endpoint to use as our\n# home endpoint\navailable_endpoints = get_configs(\nhome_dir() if self.proxystore_dir is None else self.proxystore_dir,\n)\nfound_endpoint: EndpointConfig | None = None\nfor endpoint in available_endpoints:\nif endpoint.uuid in self.endpoints:\nlogger.debug(f'Attempting connection to {endpoint.uuid}')\nresponse = requests.get(\nf'http://{endpoint.host}:{endpoint.port}/endpoint',\n)\nif response.status_code == 200:\nuuid = response.json()['uuid']\nif str(endpoint.uuid) == uuid:\nlogger.debug(\nf'Connection to {endpoint.uuid} successful, using '\n'as local endpoint',\n)\nfound_endpoint = endpoint\nbreak\nelse:\nlogger.debug(\nf'Connection to {endpoint.uuid} returned '\n'different UUID',\n)\nelse:\nlogger.debug(f'Connection to {endpoint.uuid} failed')\nif found_endpoint is None:\nraise EndpointConnectorError(\n'Failed to find endpoint configuration matching one of the '\n'provided endpoint UUIDs.',\n)\nself.endpoint_uuid = found_endpoint.uuid\nself.endpoint_host = found_endpoint.host\nself.endpoint_port = found_endpoint.port\nself.address = f'http://{self.endpoint_host}:{self.endpoint_port}'\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\"\"\"\npass\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {\n'endpoints': [str(ep) for ep in self.endpoints],\n'proxystore_dir': self.proxystore_dir,\n}\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; EndpointConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; EndpointConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.evict","title":"evict()","text":"<pre><code>evict(key: EndpointKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>EndpointKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def evict(self, key: EndpointKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\ntry:\nclient.evict(self.address, key.object_id, key.endpoint_id)\nexcept requests.exceptions.RequestException as e:\nraise EndpointConnectorError(\nf'Evict failed with error code {e.response.status_code}.',\n) from e\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.exists","title":"exists()","text":"<pre><code>exists(key: EndpointKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>EndpointKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def exists(self, key: EndpointKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\ntry:\nreturn client.exists(self.address, key.object_id, key.endpoint_id)\nexcept requests.exceptions.RequestException as e:\nraise EndpointConnectorError(\nf'Exists failed with error code {e.response.status_code}.',\n) from e\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.get","title":"get()","text":"<pre><code>get(key: EndpointKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>EndpointKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def get(self, key: EndpointKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\ntry:\nreturn client.get(self.address, key.object_id, key.endpoint_id)\nexcept requests.exceptions.RequestException as e:\nraise EndpointConnectorError(\nf'Get failed with error code {e.response.status_code}.',\n) from e\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(\nkeys: Sequence[EndpointKey],\n) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[EndpointKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def get_batch(self, keys: Sequence[EndpointKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; EndpointKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EndpointKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def put(self, obj: bytes) -&gt; EndpointKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = EndpointKey(\nobject_id=str(uuid.uuid4()),\nendpoint_id=str(self.endpoint_uuid),\n)\ntry:\nclient.put(self.address, key.object_id, obj, key.endpoint_id)\nexcept requests.exceptions.RequestException as e:\nraise EndpointConnectorError(\nf'Put failed with error code {e.response.status_code}.',\n) from e\nreturn key\n</code></pre>"},{"location":"api/connectors/endpoint/#proxystore.connectors.endpoint.EndpointConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[EndpointKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[EndpointKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[EndpointKey]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/endpoint.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[EndpointKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    \"\"\"\nreturn [self.put(obj) for obj in objs]\n</code></pre>"},{"location":"api/connectors/file/","title":"proxystore.connectors.file","text":"<code>proxystore/connectors/file.py</code> <p>File system connector implementation.</p>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileKey","title":"FileKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in a file system directory.</p>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileKey.filename","title":"filename  <code>class-attribute</code>","text":"<pre><code>filename: str\n</code></pre> <p>Unique object filename.</p>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector","title":"FileConnector","text":"<pre><code>FileConnector(store_dir: str) -&gt; None\n</code></pre> <p>Connector to shared file system.</p> <p>Parameters:</p> <ul> <li> store_dir             (<code>str</code>)         \u2013 <p>Path to directory to store data in. Note this directory will be deleted upon closing the store.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def __init__(self, store_dir: str) -&gt; None:\nself.store_dir = os.path.abspath(store_dir)\nif not os.path.exists(self.store_dir):\nos.makedirs(self.store_dir, exist_ok=True)\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Warning <p>This will delete the <code>store_dir</code> directory.</p> Warning <p>This method should only be called at the end of the program when the connector will no longer be used, for example once all proxies have been resolved.</p> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\n    Warning:\n        This will delete the `store_dir` directory.\n    Warning:\n        This method should only be called at the end of the program\n        when the connector will no longer be used, for example once all\n        proxies have been resolved.\n    \"\"\"\nshutil.rmtree(self.store_dir)\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {'store_dir': self.store_dir}\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; FileConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; FileConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.evict","title":"evict()","text":"<pre><code>evict(key: FileKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>FileKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def evict(self, key: FileKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\npath = os.path.join(self.store_dir, key.filename)\nif os.path.exists(path):\nos.remove(path)\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.exists","title":"exists()","text":"<pre><code>exists(key: FileKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>FileKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def exists(self, key: FileKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\npath = os.path.join(self.store_dir, key.filename)\nreturn os.path.exists(path)\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.get","title":"get()","text":"<pre><code>get(key: FileKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>FileKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def get(self, key: FileKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\npath = os.path.join(self.store_dir, key.filename)\nif os.path.exists(path):\nwith open(path, 'rb') as f:\ndata = f.read()\nreturn data\nreturn None\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[FileKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[FileKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def get_batch(self, keys: Sequence[FileKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; FileKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FileKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def put(self, obj: bytes) -&gt; FileKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = FileKey(filename=str(uuid.uuid4()))\npath = os.path.join(self.store_dir, key.filename)\nwith open(path, 'wb', buffering=0) as f:\nf.write(obj)\nreturn key\n</code></pre>"},{"location":"api/connectors/file/#proxystore.connectors.file.FileConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[FileKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[FileKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[FileKey]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/file.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[FileKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    \"\"\"\nreturn [self.put(obj) for obj in objs]\n</code></pre>"},{"location":"api/connectors/globus/","title":"proxystore.connectors.globus","text":"<code>proxystore/connectors/globus.py</code> <p>Globus transfer connector implementation.</p>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoint","title":"GlobusEndpoint","text":"<pre><code>GlobusEndpoint(\nuuid: str,\nendpoint_path: str,\nlocal_path: str | None,\nhost_regex: str | Pattern[str],\n) -&gt; None\n</code></pre> <p>Globus endpoint representation.</p> <p>Parameters:</p> <ul> <li> uuid             (<code>str</code>)         \u2013 <p>UUID of Globus endpoint.</p> </li> <li> endpoint_path             (<code>str</code>)         \u2013 <p>Path within endpoint to directory to use for storing objects.</p> </li> <li> local_path             (<code>str | None</code>)         \u2013 <p>Local path (as seen by the host filesystem) that corresponds to the directory specified by <code>endpoint_path</code>.</p> </li> <li> host_regex             (<code>str | Pattern[str]</code>)         \u2013 <p>String that matches the host where the Globus endpoint exists or regex pattern than can be used to match the host. The host pattern is needed so that proxies can figure out what the local endpoint is when they are resolved.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def __init__(\nself,\nuuid: str,\nendpoint_path: str,\nlocal_path: str | None,\nhost_regex: str | Pattern[str],\n) -&gt; None:\nif not isinstance(uuid, str):\nraise TypeError('uuid must be a str.')\nif not isinstance(endpoint_path, str):\nraise TypeError('endpoint_path must be a str.')\nif not isinstance(local_path, str):\nraise TypeError('local_path must be a str.')\nif not (\nisinstance(host_regex, str) or isinstance(host_regex, Pattern)\n):\nraise TypeError('host_regex must be a str or re.Pattern.')\nself.uuid = uuid\nself.endpoint_path = endpoint_path\nself.local_path = local_path\nself.host_regex = host_regex\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoints","title":"GlobusEndpoints","text":"<pre><code>GlobusEndpoints(\nendpoints: Collection[GlobusEndpoint],\n) -&gt; None\n</code></pre> <p>A collection of Globus endpoints.</p> <p>Parameters:</p> <ul> <li> endpoints             (<code>Collection[GlobusEndpoint]</code>)         \u2013 <p>Iterable of <code>GlobusEndpoints</code> instances.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>endpoints</code> has length 0 or if multiple endpoints with             the same UUID are provided.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def __init__(self, endpoints: Collection[GlobusEndpoint]) -&gt; None:\nif len(endpoints) == 0:\nraise ValueError(\n'GlobusEndpoints must be passed at least one GlobusEndpoint '\n'object',\n)\nself._endpoints: dict[str, GlobusEndpoint] = {}\nfor endpoint in endpoints:\nif endpoint.uuid in self._endpoints:\nraise ValueError(\n'Cannot pass multiple GlobusEndpoint objects with the '\n'same Globus endpoint UUID.',\n)\nself._endpoints[endpoint.uuid] = endpoint\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoints.from_dict","title":"from_dict()  <code>classmethod</code>","text":"<pre><code>from_dict(\njson_object: dict[str, dict[str, str]]\n) -&gt; GlobusEndpoints\n</code></pre> <p>Construct an endpoints collection from a dictionary.</p> Example <pre><code>{\n\"endpoint-uuid-1\": {\n\"host_regex\": \"host1-regex\",\n\"endpoint_path\": \"/path/to/endpoint/dir\",\n\"local_path\": \"/path/to/local/dir\"\n},\n\"endpoint-uuid-2\": {\n\"host_regex\": \"host2-regex\",\n\"endpoint_path\": \"/path/to/endpoint/dir\",\n\"local_path\": \"/path/to/local/dir\"\n}\n}\n</code></pre> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>@classmethod\ndef from_dict(\ncls: type[GlobusEndpoints],\njson_object: dict[str, dict[str, str]],\n) -&gt; GlobusEndpoints:\n\"\"\"Construct an endpoints collection from a dictionary.\n    Example:\n        ```python\n        {\n          \"endpoint-uuid-1\": {\n            \"host_regex\": \"host1-regex\",\n            \"endpoint_path\": \"/path/to/endpoint/dir\",\n            \"local_path\": \"/path/to/local/dir\"\n          },\n          \"endpoint-uuid-2\": {\n            \"host_regex\": \"host2-regex\",\n            \"endpoint_path\": \"/path/to/endpoint/dir\",\n            \"local_path\": \"/path/to/local/dir\"\n          }\n        }\n        ```\n    \"\"\"  # noqa: D412\nendpoints = []\nfor ep_uuid, params in json_object.items():\nendpoints.append(\nGlobusEndpoint(\nuuid=ep_uuid,\nendpoint_path=params['endpoint_path'],\nlocal_path=params['local_path'],\nhost_regex=params['host_regex'],\n),\n)\nreturn GlobusEndpoints(endpoints)\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoints.from_json","title":"from_json()  <code>classmethod</code>","text":"<pre><code>from_json(json_file: str) -&gt; GlobusEndpoints\n</code></pre> <p>Construct a GlobusEndpoints object from a json file.</p> <p>The <code>dict</code> read from the JSON file will be passed to <code>from_dict()</code> and should match the format expected by <code>from_dict()</code>.</p> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>@classmethod\ndef from_json(cls, json_file: str) -&gt; GlobusEndpoints:\n\"\"\"Construct a GlobusEndpoints object from a json file.\n    The `dict` read from the JSON file will be passed to\n    [`from_dict()`][proxystore.store.globus.GlobusEndpoints.from_dict] and\n    should match the format expected by\n    [`from_dict()`][proxystore.store.globus.GlobusEndpoints.from_dict].\n    \"\"\"\nwith open(json_file) as f:\ndata = f.read()\nreturn cls.from_dict(json.loads(data))\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoints.dict","title":"dict()","text":"<pre><code>dict() -&gt; dict[str, dict[str, str]]\n</code></pre> <p>Convert the GlobusEndpoints to a dict.</p> <p>Note that the <code>GlobusEndpoints</code> object can be reconstructed by passing the <code>dict</code> to. <code>from_dict()</code>.</p> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def dict(self) -&gt; dict[str, dict[str, str]]:\n\"\"\"Convert the GlobusEndpoints to a dict.\n    Note that the\n    [`GlobusEndpoints`][proxystore.store.globus.GlobusEndpoints]\n    object can be reconstructed by passing the `dict` to.\n    [`from_dict()`][proxystore.store.globus.GlobusEndpoints.from_dict].\n    \"\"\"\ndata = {}\nfor endpoint in self:\ndata[endpoint.uuid] = {\n'endpoint_path': endpoint.endpoint_path,\n'local_path': endpoint.local_path,\n'host_regex': endpoint.host_regex.pattern\nif isinstance(endpoint.host_regex, Pattern)\nelse endpoint.host_regex,\n}\nreturn data\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusEndpoints.get_by_host","title":"get_by_host()","text":"<pre><code>get_by_host(host: str) -&gt; GlobusEndpoint\n</code></pre> <p>Get endpoint by host.</p> <p>Searches the endpoints for a endpoint who's <code>host_regex</code> matches <code>host</code>.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>Host to match.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GlobusEndpoint</code>         \u2013 <p>Globus endpoint.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>host</code> does not match any of the endpoints.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def get_by_host(self, host: str) -&gt; GlobusEndpoint:\n\"\"\"Get endpoint by host.\n    Searches the endpoints for a endpoint who's `host_regex` matches\n    `host`.\n    Args:\n        host: Host to match.\n    Returns:\n        Globus endpoint.\n    Raises:\n        ValueError: If `host` does not match any of the endpoints.\n    \"\"\"\nfor endpoint in self._endpoints.values():\nif re.fullmatch(endpoint.host_regex, host) is not None:\nreturn endpoint\nraise ValueError(f'Cannot find endpoint matching host {host}')\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusKey","title":"GlobusKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to object transferred with Globus.</p>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusKey.filename","title":"filename  <code>class-attribute</code>","text":"<pre><code>filename: str\n</code></pre> <p>Unique object filename.</p>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusKey.task_id","title":"task_id  <code>class-attribute</code>","text":"<pre><code>task_id: str\n</code></pre> <p>Globus transfer task ID for the file.</p>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusKey.__eq__","title":"__eq__()","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> <p>Match keys by filename only.</p> <p>This is a hack around the fact that the task_id is not created until after the filename is so there can be a state where the task_id is empty.</p> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Match keys by filename only.\n    This is a hack around the fact that the task_id is not created until\n    after the filename is so there can be a state where the task_id\n    is empty.\n    \"\"\"\nif isinstance(other, tuple):\nreturn self[0] == other[0]\nreturn False\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector","title":"GlobusConnector","text":"<pre><code>GlobusConnector(\nendpoints: GlobusEndpoints\n| list[GlobusEndpoint]\n| dict[str, dict[str, str]],\npolling_interval: int = 1,\nsync_level: int\n| Literal[exists, size, mtime, checksum] = \"mtime\",\ntimeout: int = 60,\n) -&gt; None\n</code></pre> <p>Globus transfer connector.</p> <p>The <code>GlobusConnector</code> is similar to a <code>FileConnector</code> in that objects are saved to disk but allows for the transfer of objects between two remote file systems. The two directories on the separate file systems are kept in sync via Globus transfers. The <code>GlobusConnector</code> is useful when moving data between hosts that have a Globus endpoint but may have restrictions that prevent the use of other store backends (e.g., ports cannot be opened for using a <code>RedisConnector</code>.</p> Note <p>To use Globus for data transfer, Globus authentication needs to be performed otherwise an error will be raised. Authentication can be performed on the command line with <code>proxystore-globus-auth</code>. Authentication only needs to be performed once per system.</p> <p>Parameters:</p> <ul> <li> endpoints             (<code>GlobusEndpoints | list[GlobusEndpoint] | dict[str, dict[str, str]]</code>)         \u2013 <p>Globus endpoints to keep in sync. If passed as a <code>dict</code>, the dictionary must match the format expected by <code>GlobusEndpoints.from_dict()</code>.</p> </li> <li> polling_interval             (<code>int</code>)         \u2013 <p>Interval in seconds to check if Globus tasks have finished.</p> </li> <li> sync_level             (<code>int | Literal[exists, size, mtime, checksum]</code>)         \u2013 <p>Globus transfer sync level.</p> </li> <li> timeout             (<code>int</code>)         \u2013 <p>Timeout in seconds for waiting on Globus tasks.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>GlobusAuthFileError</code>           \u2013         <p>If the Globus authentication file cannot be found.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If <code>endpoints</code> is of an incorrect type.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If the <code>len(endpoints) != 2</code> because this implementation can currently only keep two endpoints in sync.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def __init__(\nself,\nendpoints: GlobusEndpoints\n| list[GlobusEndpoint]\n| dict[str, dict[str, str]],\npolling_interval: int = 1,\nsync_level: int\n| Literal['exists', 'size', 'mtime', 'checksum'] = 'mtime',\ntimeout: int = 60,\n) -&gt; None:\nif isinstance(endpoints, GlobusEndpoints):\nself.endpoints = endpoints\nelif isinstance(endpoints, list):\nself.endpoints = GlobusEndpoints(endpoints)\nelif isinstance(endpoints, dict):\nself.endpoints = GlobusEndpoints.from_dict(endpoints)\nelse:\nraise ValueError(\n'endpoints must be of type GlobusEndpoints or a list of '\nf'GlobusEndpoint. Got {type(endpoints)}.',\n)\nif len(endpoints) != 2:\nraise ValueError(\n'ProxyStore only supports two endpoints at a time',\n)\nself.polling_interval = polling_interval\nself.sync_level = sync_level\nself.timeout = timeout\ntry:\nauthorizer = get_proxystore_authorizer()\nexcept GlobusAuthFileError as e:\nraise GlobusAuthFileError(\n'Error loading Globus auth tokens. Complete the '\n'authentication process with the proxystore-globus-auth tool.',\n) from e\nself._transfer_client = globus_sdk.TransferClient(\nauthorizer=authorizer,\n)\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Warning <p>This will delete the directory at <code>local_path</code> on each endpoint.</p> Warning <p>This method should only be called at the end of the program when the store will no longer be used, for example once all proxies have been resolved.</p> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\n    Warning:\n        This will delete the directory at `local_path` on each endpoint.\n    Warning:\n        This method should only be called at the end of the program when\n        the store will no longer be used, for example once all proxies\n        have been resolved.\n    \"\"\"\nfor endpoint in self.endpoints:\ndelete_task = globus_sdk.DeleteData(\nself._transfer_client,\nendpoint=endpoint.uuid,\nrecursive=True,\n)\ndelete_task['notify_on_succeeded'] = False\ndelete_task['notify_on_failed'] = False\ndelete_task['notify_on_inactive'] = False\ndelete_task.add_item(endpoint.endpoint_path)\ntdata = _submit_transfer_action(self._transfer_client, delete_task)\nself._wait_on_tasks(tdata['task_id'])\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {\n'endpoints': self.endpoints.dict(),\n'polling_interval': self.polling_interval,\n'sync_level': self.sync_level,\n'timeout': self.timeout,\n}\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; GlobusConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; GlobusConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.evict","title":"evict()","text":"<pre><code>evict(key: GlobusKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>GlobusKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def evict(self, key: GlobusKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nif not self.exists(key):\nreturn\npath = self._get_filepath(key.filename)\nos.remove(path)\nself._transfer_files(key.filename, delete=True)\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.exists","title":"exists()","text":"<pre><code>exists(key: GlobusKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> Note <p>If the corresponding Globus transfer is still in progress, this method will wait to make sure the transfers is successful.</p> <p>Parameters:</p> <ul> <li> key             (<code>GlobusKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def exists(self, key: GlobusKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Note:\n        If the corresponding Globus transfer is still in progress, this\n        method will wait to make sure the transfers is successful.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nif not self._validate_task_id(key.task_id):\nreturn False\nself._wait_on_tasks(key.task_id)\nreturn os.path.exists(self._get_filepath(key.filename))\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.get","title":"get()","text":"<pre><code>get(key: GlobusKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>GlobusKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def get(self, key: GlobusKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nif not self.exists(key):\nreturn None\npath = self._get_filepath(key.filename)\nwith open(path, 'rb') as f:\nreturn f.read()\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[GlobusKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[GlobusKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def get_batch(self, keys: Sequence[GlobusKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; GlobusKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GlobusKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def put(self, obj: bytes) -&gt; GlobusKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nfilename = str(uuid.uuid4())\npath = self._get_filepath(filename)\nos.makedirs(os.path.dirname(path), exist_ok=True)\nwith open(path, 'wb', buffering=0) as f:\nf.write(obj)\ntask_id = self._transfer_files(filename)\nreturn GlobusKey(filename=filename, task_id=task_id)\n</code></pre>"},{"location":"api/connectors/globus/#proxystore.connectors.globus.GlobusConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[GlobusKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[GlobusKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[GlobusKey]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/globus.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[GlobusKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    \"\"\"\nfilenames = [str(uuid.uuid4()) for _ in objs]\nfor filename, obj in zip(filenames, objs):\npath = self._get_filepath(filename)\nos.makedirs(os.path.dirname(path), exist_ok=True)\nwith open(path, 'wb', buffering=0) as f:\nf.write(obj)\ntask_id = self._transfer_files(filenames)\nreturn [\nGlobusKey(filename=filename, task_id=task_id)\nfor filename in filenames\n]\n</code></pre>"},{"location":"api/connectors/local/","title":"proxystore.connectors.local","text":"<code>proxystore/connectors/local.py</code> <p>In-process local storage connector implementation.</p>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalKey","title":"LocalKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects store in a <code>LocalConnector</code>.</p>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalKey.id","title":"id  <code>class-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique object ID.</p>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector","title":"LocalConnector","text":"<pre><code>LocalConnector(\nstore_dict: dict[LocalKey, bytes] | None = None\n) -&gt; None\n</code></pre> <p>Connector that store objects in the local process's memory.</p> Warning <p>This connector exists primarily for testing purposes.</p> <p>Parameters:</p> <ul> <li> store_dict             (<code>dict[LocalKey, bytes] | None</code>)         \u2013 <p>Dictionary to store data in. If not specified, a new empty dict will be generated.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def __init__(\nself,\nstore_dict: dict[LocalKey, bytes] | None = None,\n) -&gt; None:\nself._store: dict[LocalKey, bytes] = {}\nif store_dict is not None:\nself._store = store_dict\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\"\"\"\npass\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {'store_dict': self._store}\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; LocalConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; LocalConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.evict","title":"evict()","text":"<pre><code>evict(key: LocalKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>LocalKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def evict(self, key: LocalKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nif key in self._store:\ndel self._store[key]\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.exists","title":"exists()","text":"<pre><code>exists(key: LocalKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>LocalKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def exists(self, key: LocalKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nreturn key in self._store\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.get","title":"get()","text":"<pre><code>get(key: LocalKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>LocalKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def get(self, key: LocalKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nreturn self._store.get(key, None)\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[LocalKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[LocalKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def get_batch(self, keys: Sequence[LocalKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; LocalKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LocalKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def put(self, obj: bytes) -&gt; LocalKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = LocalKey(str(uuid.uuid4()))\nself._store[key] = obj\nreturn key\n</code></pre>"},{"location":"api/connectors/local/#proxystore.connectors.local.LocalConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[LocalKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[LocalKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[LocalKey]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/local.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[LocalKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    \"\"\"\nreturn [self.put(obj) for obj in objs]\n</code></pre>"},{"location":"api/connectors/multi/","title":"proxystore.connectors.multi","text":"<code>proxystore/connectors/multi.py</code> <p>Multi-connector implementation.</p>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.PolicyDict","title":"PolicyDict","text":"<p>         Bases: <code>TypedDict</code></p> <p>JSON compatible representation of a <code>Policy</code>.</p>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.Policy","title":"Policy  <code>dataclass</code>","text":"<p>Policy that allows validating a set of constraints.</p>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.Policy.is_valid","title":"is_valid()","text":"<pre><code>is_valid(\n*,\nsize: int | None = None,\nsubset_tags: Iterable[str] | None = None,\nsuperset_tags: Iterable[str] | None = None\n) -&gt; bool\n</code></pre> <p>Check if set of contstraints is valid for this policy.</p> Note <p>All arguments are optional keyword arguments that default to <code>None</code>. If left as the default, that constraint will not be checked against the policy.</p> <p>Parameters:</p> <ul> <li> size             (<code>int | None</code>)         \u2013 <p>Object size.</p> </li> <li> subset_tags             (<code>Iterable[str] | None</code>)         \u2013 <p>Set of tags that must be a subset of the Policy's <code>subset_tags</code> to be valid.</p> </li> <li> superset_tags             (<code>Iterable[str] | None</code>)         \u2013 <p>Set of tags that must be a superset of the Policy's <code>superset_tags</code> to be valid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the provided constraints are valid for the policy.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def is_valid(\nself,\n*,\nsize: int | None = None,\nsubset_tags: Iterable[str] | None = None,\nsuperset_tags: Iterable[str] | None = None,\n) -&gt; bool:\n\"\"\"Check if set of contstraints is valid for this policy.\n    Note:\n        All arguments are optional keyword arguments that default to\n        `None`. If left as the default, that constraint will not be\n        checked against the policy.\n    Args:\n        size: Object size.\n        subset_tags: Set of tags that must be a subset\n            of the Policy's `subset_tags` to be valid.\n        superset_tags: Set of tags that must be a superset\n            of the Policy's `superset_tags` to be valid.\n    Returns:\n        If the provided constraints are valid for the policy.\n    \"\"\"\nif size is not None and (size &lt; self.min_size or size &gt; self.max_size):\nreturn False\nif subset_tags is not None and not set(subset_tags).issubset(\nself.subset_tags,\n):\nreturn False\nif superset_tags is not None and not set(superset_tags).issuperset(\nself.superset_tags,\n):\nreturn False\nreturn True\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.Policy.as_dict","title":"as_dict()","text":"<pre><code>as_dict() -&gt; PolicyDict\n</code></pre> <p>Convert the Policy to a JSON compatible dict.</p> Usage <p>policy = Policy(...) policy_dict = policy.as_dict() Policy(**policy_dict) == policy True</p> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def as_dict(self) -&gt; PolicyDict:\n\"\"\"Convert the Policy to a JSON compatible dict.\n    Usage:\n        &gt;&gt;&gt; policy = Policy(...)\n        &gt;&gt;&gt; policy_dict = policy.as_dict()\n        &gt;&gt;&gt; Policy(**policy_dict) == policy\n        True\n    \"\"\"\n# We could use dataclasses.asdict(self) but this gives us the benefit\n# of typing on the return dict.\nreturn PolicyDict(\npriority=self.priority,\nmin_size=self.min_size,\nmax_size=self.max_size,\nsubset_tags=self.subset_tags,\nsuperset_tags=self.superset_tags,\n)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiKey","title":"MultiKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in <code>MultiConnector</code>.</p>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiKey.connector_name","title":"connector_name  <code>class-attribute</code>","text":"<pre><code>connector_name: str\n</code></pre> <p>Name of connector that the associated object is stored in.</p>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiKey.connector_key","title":"connector_key  <code>class-attribute</code>","text":"<pre><code>connector_key: Any\n</code></pre> <p>Key associated with the object.</p>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector","title":"MultiConnector","text":"<pre><code>MultiConnector(\nconnectors: dict[str, tuple[Connector[Any], Policy]]\n) -&gt; None\n</code></pre> <p>Policy based manager for a <code>Connector</code> collection.</p> <p>Parameters:</p> <ul> <li> connectors             (<code>dict[str, tuple[Connector[Any], Policy]]</code>)         \u2013 <p>Mapping of names to tuples of a <code>Connector</code> and <code>Policy</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def __init__(\nself,\nconnectors: dict[str, tuple[Connector[Any], Policy]],\n) -&gt; None:\nself.connectors = {\nname: _ConnectorPolicy(connector, policy)\nfor name, (connector, policy) in connectors.items()\n}\nnames = list(self.connectors.keys())\nself.connectors_by_priority = sorted(\nnames,\nkey=lambda name: self.connectors[name].policy.priority,\nreverse=True,\n)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Warning <p>This will call <code>close()</code> on all managed connectors.</p> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\n    Warning:\n        This will call `close()` on all managed connectors.\n    \"\"\"\nfor connector, _ in self.connectors.values():\nconnector.close()\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {\nname: (\nget_class_path(type(connector)),\nconnector.config(),\npolicy.as_dict(),\n)\nfor name, (connector, policy) in self.connectors.items()\n}\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; MultiConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; MultiConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nconnectors: dict[str, tuple[Connector[Any], Policy]] = {}\nfor name, (connector_path, connector_config, policy) in config.items():\nconnector_type = import_class(connector_path)\nconnector = connector_type.from_config(connector_config)\npolicy = Policy(**policy)\nconnectors[name] = (connector, policy)\nreturn cls(connectors=connectors)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.evict","title":"evict()","text":"<pre><code>evict(key: MultiKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>MultiKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def evict(self, key: MultiKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nconnector = self.connectors[key.connector_name].connector\nconnector.evict(key.connector_key)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.exists","title":"exists()","text":"<pre><code>exists(key: MultiKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>MultiKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def exists(self, key: MultiKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nconnector = self.connectors[key.connector_name].connector\nreturn connector.exists(key.connector_key)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.get","title":"get()","text":"<pre><code>get(key: MultiKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>MultiKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def get(self, key: MultiKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nconnector = self.connectors[key.connector_name].connector\nreturn connector.get(key.connector_key)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[MultiKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[MultiKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def get_batch(self, keys: Sequence[MultiKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.put","title":"put()","text":"<pre><code>put(\nobj: bytes,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n) -&gt; MultiKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> <li> subset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a subset of a connector's policy <code>subset_tags</code> to match.</p> </li> <li> superset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a superset of a connectors's policy <code>superset_tags</code> to match.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MultiKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013         <p>If no connector policy matches the arguments.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def put(\nself,\nobj: bytes,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n) -&gt; MultiKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n        subset_tags: Iterable of tags that must be a subset\n            of a connector's policy `subset_tags` to match.\n        superset_tags: Iterable of tags that must be a superset\n            of a connectors's policy `superset_tags` to match.\n    Returns:\n        Key which can be used to retrieve the object.\n    Raises:\n        RuntimeError: If no connector policy matches the arguments.\n    \"\"\"\nfor connector_name in self.connectors_by_priority:\nconnector, policy = self.connectors[connector_name]\nif policy.is_valid(\nsize=len(obj),\nsubset_tags=subset_tags,\nsuperset_tags=superset_tags,\n):\nkey = connector.put(obj)\nreturn MultiKey(\nconnector_name=connector_name,\nconnector_key=key,\n)\nelse:\nraise RuntimeError(\n'No connector policy was suitable for the constraints: '\nf'subset_tags={subset_tags}, superset_tags={superset_tags}.',\n)\n</code></pre>"},{"location":"api/connectors/multi/#proxystore.connectors.multi.MultiConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(\nobjs: Sequence[bytes],\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n) -&gt; list[MultiKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> <li> subset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a subset of a connector's policy <code>subset_tags</code> to match.</p> </li> <li> superset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a superset of a connectors's policy <code>superset_tags</code> to match.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[MultiKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[MultiKey]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013         <p>If no connector policy matches the arguments.</p> </li> </ul> Source code in <code>proxystore/connectors/multi.py</code> <pre><code>def put_batch(\nself,\nobjs: Sequence[bytes],\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n) -&gt; list[MultiKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n        subset_tags: Iterable of tags that must be a subset\n            of a connector's policy `subset_tags` to match.\n        superset_tags: Iterable of tags that must be a superset\n            of a connectors's policy `superset_tags` to match.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    Raises:\n        RuntimeError: If no connector policy matches the arguments.\n    \"\"\"\nreturn [\nself.put(obj, subset_tags=subset_tags, superset_tags=superset_tags)\nfor obj in objs\n]\n</code></pre>"},{"location":"api/connectors/redis/","title":"proxystore.connectors.redis","text":"<code>proxystore/connectors/redis.py</code> <p>Redis connector implementation.</p>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisKey","title":"RedisKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects store in a Redis server.</p>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisKey.redis_key","title":"redis_key  <code>class-attribute</code>","text":"<pre><code>redis_key: str\n</code></pre> <p>Unique object ID.</p>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector","title":"RedisConnector","text":"<pre><code>RedisConnector(hostname: str, port: int) -&gt; None\n</code></pre> <p>Redis server connector.</p> <p>Parameters:</p> <ul> <li> hostname             (<code>str</code>)         \u2013 <p>Redis server hostname.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Redis server port.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def __init__(self, hostname: str, port: int) -&gt; None:\nself.hostname = hostname\nself.port = port\nself._redis_client = redis.StrictRedis(host=hostname, port=port)\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\"\"\"\npass\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {'hostname': self.hostname, 'port': self.port}\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; RedisConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; RedisConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.evict","title":"evict()","text":"<pre><code>evict(key: RedisKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>RedisKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def evict(self, key: RedisKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nself._redis_client.delete(key.redis_key)\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.exists","title":"exists()","text":"<pre><code>exists(key: RedisKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>RedisKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def exists(self, key: RedisKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nreturn bool(self._redis_client.exists(key.redis_key))\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.get","title":"get()","text":"<pre><code>get(key: RedisKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>RedisKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def get(self, key: RedisKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nreturn self._redis_client.get(key.redis_key)\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[RedisKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[RedisKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def get_batch(self, keys: Sequence[RedisKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn self._redis_client.mget([key.redis_key for key in keys])\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; RedisKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RedisKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def put(self, obj: bytes) -&gt; RedisKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = RedisKey(redis_key=str(uuid.uuid4()))\nself._redis_client.set(key.redis_key, obj)\nreturn key\n</code></pre>"},{"location":"api/connectors/redis/#proxystore.connectors.redis.RedisConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[RedisKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[RedisKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[RedisKey]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/redis.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[RedisKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    \"\"\"\nkeys = [RedisKey(redis_key=str(uuid.uuid4())) for _ in objs]\nself._redis_client.mset(\n{key.redis_key: obj for key, obj in zip(keys, objs)},\n)\nreturn keys\n</code></pre>"},{"location":"api/connectors/dim/","title":"proxystore.connectors.dim","text":"<code>proxystore/connectors/dim/__init__.py</code> <p>Distributed in-memory store connectors.</p>"},{"location":"api/connectors/dim/margo/","title":"proxystore.connectors.dim.margo","text":"<code>proxystore/connectors/dim/margo.py</code> <p>Margo RPC-based distributed in-memory connector implementation.</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol","title":"Protocol","text":"<p>         Bases: <code>Enum</code></p> <p>Available Mercury plugins and transports.</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.OFI_TCP","title":"OFI_TCP  <code>class-attribute</code>","text":"<pre><code>OFI_TCP = 'ofi+tcp'\n</code></pre> <p>libfabric tcp provider (TCP/IP)</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.OFI_VERBS","title":"OFI_VERBS  <code>class-attribute</code>","text":"<pre><code>OFI_VERBS = 'ofi+verbs'\n</code></pre> <p>libfabric Verbs provider (InfiniBand or RoCE)</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.OFI_GNI","title":"OFI_GNI  <code>class-attribute</code>","text":"<pre><code>OFI_GNI = 'ofi+gni'\n</code></pre> <p>libfabric GNI provider (Cray Aries)</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.UCX_TCP","title":"UCX_TCP  <code>class-attribute</code>","text":"<pre><code>UCX_TCP = 'ucx+tcp'\n</code></pre> <p>UCX TCP/IP</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.UCX_VERBS","title":"UCX_VERBS  <code>class-attribute</code>","text":"<pre><code>UCX_VERBS = 'ucx+verbs'\n</code></pre> <p>UCX Verbs</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.SM_SHM","title":"SM_SHM  <code>class-attribute</code>","text":"<pre><code>SM_SHM = 'sm+shm'\n</code></pre> <p>Shared memory shm</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.Protocol.BMI_TCP","title":"BMI_TCP  <code>class-attribute</code>","text":"<pre><code>BMI_TCP = 'bmi+tcp'\n</code></pre> <p>BMI tcp module (TCP/IP)</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoKey","title":"MargoKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects stored across <code>MargoConnector</code>s.</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoKey.margo_key","title":"margo_key  <code>class-attribute</code>","text":"<pre><code>margo_key: str\n</code></pre> <p>Unique object key.</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoKey.obj_size","title":"obj_size  <code>class-attribute</code>","text":"<pre><code>obj_size: int\n</code></pre> <p>Object size in bytes.</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoKey.peer","title":"peer  <code>class-attribute</code>","text":"<pre><code>peer: str\n</code></pre> <p>Peer where object is located.</p>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector","title":"MargoConnector","text":"<pre><code>MargoConnector(\ninterface: str,\nport: int,\nprotocol: Protocol = Protocol.OFI_VERBS,\n) -&gt; None\n</code></pre> <p>Margo RPC-based distributed in-memory connector.</p> Note <p>The first instance of this connector created on a process will spawn a <code>MargoServer</code> that will store data. Hence, this connector just acts as an interface to that server.</p> <p>Parameters:</p> <ul> <li> interface             (<code>str</code>)         \u2013 <p>The network interface to use.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The desired port for the spawned server.</p> </li> <li> protocol             (<code>Protocol</code>)         \u2013 <p>The communication protocol to use.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def __init__(\nself,\ninterface: str,\nport: int,\nprotocol: Protocol = Protocol.OFI_VERBS,\n) -&gt; None:\nglobal server_process\nglobal client_pids\nglobal engine\nglobal _rpcs\n# raise error if modules not properly loaded\nif pymargo_import_error is not None:  # pragma: no cover\nraise pymargo_import_error\nself.protocol = protocol\nself.interface = interface\nself.host = get_ip_address(interface)\nself.port = port\nself.addr = f'{self.protocol}://{self.host}:{port}'\nif server_process is None:\nserver_process = Process(target=self._start_server)\nserver_process.start()\nif engine is None:\n# start client\nengine = Engine(\nself.protocol,\nmode=pymargo.client,\nuse_progress_thread=True,\n)\n_rpcs = {\n'set': engine.register('set'),\n'get': engine.register('get'),\n'exists': engine.register('exists'),\n'evict': engine.register('evict'),\n}\nself.engine = engine\nself._rpcs = _rpcs\nself.server_started()\nself._pid = getpid()\nclient_pids.add(self._pid)\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.server_started","title":"server_started()","text":"<pre><code>server_started() -&gt; None\n</code></pre> <p>Loop until server has started.</p> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def server_started(self) -&gt; None:  # pragma: no cover\n\"\"\"Loop until server has started.\"\"\"\nlogger.debug('Checking if server has started')\nwhile True:\nassert engine is not None\ntry:\nself._mochi_addr = engine.lookup(self.addr)\nbreak\nexcept MargoException:\npass\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.call_rpc_on","title":"call_rpc_on()  <code>staticmethod</code>","text":"<pre><code>call_rpc_on(\nengine: Engine,\naddr: str,\nrpc: RemoteFunction,\narray_str: Bulk,\nkey: str,\nsize: int,\n) -&gt; Status\n</code></pre> <p>Initiate the desired RPC call on the specified provider.</p> <p>Parameters:</p> <ul> <li> engine             (<code>Engine</code>)         \u2013 <p>The client-side engine.</p> </li> <li> addr             (<code>str</code>)         \u2013 <p>The address of Margo provider to access (e.g. tcp://172.21.2.203:6367).</p> </li> <li> rpc             (<code>RemoteFunction</code>)         \u2013 <p>The rpc to issue to the server.</p> </li> <li> array_str             (<code>Bulk</code>)         \u2013 <p>The serialized data/buffer to send to the server.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>The identifier of the data stored on the server.</p> </li> <li> size             (<code>int</code>)         \u2013 <p>The size of the the data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>A string denoting whether the communication was successful</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>@staticmethod\ndef call_rpc_on(\nengine: Engine,\naddr: str,\nrpc: RemoteFunction,\narray_str: Bulk,\nkey: str,\nsize: int,\n) -&gt; Status:\n\"\"\"Initiate the desired RPC call on the specified provider.\n    Arguments:\n        engine: The client-side engine.\n        addr: The address of Margo provider to access\n            (e.g. tcp://172.21.2.203:6367).\n        rpc: The rpc to issue to the server.\n        array_str: The serialized data/buffer to send to the server.\n        key: The identifier of the data stored on the server.\n        size: The size of the the data.\n    Returns:\n        A string denoting whether the communication was successful\n    \"\"\"\nserver_addr = engine.lookup(addr)\nreturn deserialize(rpc.on(server_addr)(array_str, size, key))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector and clean up.</p> Warning <p>This will terminate the server is no clients are still connected.</p> Warning <p>This method should only be called at the end of the program when the connector will no longer be used, for example once all proxies have been resolved.</p> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector and clean up.\n    Warning:\n        This will terminate the server is no clients are still connected.\n    Warning:\n        This method should only be called at the end of the program\n        when the connector will no longer be used, for example once all\n        proxies have been resolved.\n    \"\"\"\nglobal server_process\nglobal client_pids\nglobal engine\nclient_pids.discard(self._pid)\nlogger.info('Clean up requested')\nif len(client_pids) == 0 and server_process is not None:\nengine = None\nself._mochi_addr.shutdown()\nself.engine.finalize()\nserver_process.join()\nserver_process = None\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {\n'interface': self.interface,\n'port': self.port,\n'protocol': self.protocol,\n}\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; MargoConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; MargoConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.evict","title":"evict()","text":"<pre><code>evict(key: MargoKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>MargoKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def evict(self, key: MargoKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nlogger.debug(f'Client issuing an evict request on key {key}')\nself.call_rpc_on(\nself.engine,\nkey.peer,\nself._rpcs['evict'],\n'',\nkey.margo_key,\n0,\n)\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.exists","title":"exists()","text":"<pre><code>exists(key: MargoKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>MargoKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def exists(self, key: MargoKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nlogger.debug(f'Client issuing an exists request on key {key}')\nbuff = bytearray(4)  # equivalent to malloc\nblk = self.engine.create_bulk(buff, bulk.write_only)\nself.call_rpc_on(\nself.engine,\nkey.peer,\nself._rpcs['exists'],\nblk,\nkey.margo_key,\nlen(buff),\n)\nreturn bool(int(deserialize(bytes(buff))))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.get","title":"get()","text":"<pre><code>get(key: MargoKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>MargoKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def get(self, key: MargoKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nlogger.debug(f'Client issuing get request on key {key}')\nbuff = bytearray(key.obj_size)\nblk = self.engine.create_bulk(buff, bulk.read_write)\ns = self.call_rpc_on(\nself.engine,\nkey.peer,\nself._rpcs['get'],\nblk,\nkey.margo_key,\nkey.obj_size,\n)\nif not s.success:\nlogger.error(f'{s.error}')\nreturn None\nreturn bytes(buff)\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[MargoKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[MargoKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def get_batch(self, keys: Sequence[MargoKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; MargoKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MargoKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def put(self, obj: bytes) -&gt; MargoKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = MargoKey(\nmargo_key=str(uuid.uuid4()),\nobj_size=len(obj),\npeer=self.addr,\n)\nlogger.debug(f'Client {self.addr} issuing set request on key {key}')\nblk = self.engine.create_bulk(obj, bulk.read_only)\nself.call_rpc_on(\nself.engine,\nself.addr,\nself._rpcs['set'],\nblk,\nkey.margo_key,\nkey.obj_size,\n)\nreturn key\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[MargoKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[MargoKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[MargoKey]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[MargoKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    \"\"\"\nreturn [self.put(obj) for obj in objs]\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoServer","title":"MargoServer","text":"<pre><code>MargoServer(engine: Engine) -&gt; None\n</code></pre> <p>MargoServer implementation.</p> <p>Parameters:</p> <ul> <li> engine             (<code>Engine</code>)         \u2013 <p>The server engine created at the specified network address.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def __init__(self, engine: Engine) -&gt; None:\nself.data = {}\nself.engine = engine\nlogger.debug('Server initialized')\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoServer.set","title":"set()","text":"<pre><code>set(\nhandle: Handle, bulk_str: Bulk, bulk_size: int, key: str\n) -&gt; None\n</code></pre> <p>Obtain data from the client and store it in local dictionary.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>Bulk</code>)         \u2013 <p>The buffer containing the data to be shared.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data being transferred.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>The data key.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def set(\nself,\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: str,\n) -&gt; None:\n\"\"\"Obtain data from the client and store it in local dictionary.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer containing the data to be shared.\n        bulk_size: The size of the data being transferred.\n        key: The data key.\n    \"\"\"\nlogger.debug(f'Received set RPC for key {key}.')\ns = Status(True, None)\nlocal_buffer = bytearray(bulk_size)\nlocal_bulk = self.engine.create_bulk(local_buffer, bulk.write_only)\nself.engine.transfer(\nbulk.pull,\nhandle.get_addr(),\nbulk_str,\n0,\nlocal_bulk,\n0,\nbulk_size,\n)\nself.data[key] = local_buffer\nhandle.respond(serialize(s))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoServer.get","title":"get()","text":"<pre><code>get(\nhandle: Handle, bulk_str: Bulk, bulk_size: int, key: str\n) -&gt; None\n</code></pre> <p>Return data at a given key back to the client.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>Bulk</code>)         \u2013 <p>The buffer that will store shared data.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data to be received.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>The data's key.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def get(\nself,\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: str,\n) -&gt; None:\n\"\"\"Return data at a given key back to the client.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\nlogger.debug(f'Received get RPC for key {key}.')\ns = Status(True, None)\ntry:\nlocal_array = self.data[key]\nlocal_bulk = self.engine.create_bulk(local_array, bulk.read_only)\nself.engine.transfer(\nbulk.push,\nhandle.get_addr(),\nbulk_str,\n0,\nlocal_bulk,\n0,\nbulk_size,\n)\nexcept KeyError as error:\nlogger.error(f'key {error} not found.')\ns = Status(False, error)\nhandle.respond(serialize(s))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoServer.evict","title":"evict()","text":"<pre><code>evict(\nhandle: Handle, bulk_str: str, bulk_size: int, key: str\n) -&gt; None\n</code></pre> <p>Remove key from local dictionary.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>str</code>)         \u2013 <p>The buffer that will store shared data.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data to be received.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>The data's key.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def evict(\nself,\nhandle: Handle,\nbulk_str: str,\nbulk_size: int,\nkey: str,\n) -&gt; None:\n\"\"\"Remove key from local dictionary.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\nlogger.debug(f'Received exists RPC for key {key}')\nself.data.pop(key, None)\ns = Status(True, None)\nhandle.respond(serialize(s))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.MargoServer.exists","title":"exists()","text":"<pre><code>exists(\nhandle: Handle, bulk_str: str, bulk_size: int, key: str\n) -&gt; None\n</code></pre> <p>Check if key exists within local dictionary.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>str</code>)         \u2013 <p>The buffer that will store shared data.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data to be received.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>The data's key.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def exists(\nself,\nhandle: Handle,\nbulk_str: str,\nbulk_size: int,\nkey: str,\n) -&gt; None:\n\"\"\"Check if key exists within local dictionary.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\nlogger.debug(f'Received exists RPC for key {key}')\ns = Status(True, None)\n# converting to int then string because length appears to be 7 for\n# True with pickle protocol 4 and cannot always guarantee that that\n# protocol will be selected\nlocal_array = serialize(str(int(key in self.data)))\nlocal_bulk = self.engine.create_bulk(local_array, bulk.read_only)\nsize = len(local_array)\nself.engine.transfer(\nbulk.push,\nhandle.get_addr(),\nbulk_str,\n0,\nlocal_bulk,\n0,\nsize,\n)\nhandle.respond(serialize(s))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore.connectors.dim.margo.when_finalize","title":"when_finalize()","text":"<pre><code>when_finalize() -&gt; None\n</code></pre> <p>Print a statement advising that engine finalization was triggered.</p> Source code in <code>proxystore/connectors/dim/margo.py</code> <pre><code>def when_finalize() -&gt; None:\n\"\"\"Print a statement advising that engine finalization was triggered.\"\"\"\nlogger.info('Finalize was called. Cleaning up.')\n</code></pre>"},{"location":"api/connectors/dim/ucx/","title":"proxystore.connectors.dim.ucx","text":"<code>proxystore/connectors/dim/ucx.py</code> <p>UCX-based distributed in-memory connector implementation.</p>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXKey","title":"UCXKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects stored across <code>UCXConnector</code>s.</p>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXKey.ucx_key","title":"ucx_key  <code>class-attribute</code>","text":"<pre><code>ucx_key: str\n</code></pre> <p>Unique object key.</p>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXKey.obj_size","title":"obj_size  <code>class-attribute</code>","text":"<pre><code>obj_size: int\n</code></pre> <p>Object size in bytes.</p>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXKey.peer","title":"peer  <code>class-attribute</code>","text":"<pre><code>peer: str\n</code></pre> <p>Peer where object is located.</p>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector","title":"UCXConnector","text":"<pre><code>UCXConnector(interface: str, port: int) -&gt; None\n</code></pre> <p>UCX-based distributed in-memory connector.</p> Note <p>The first instance of this connector created on a process will spawn a <code>UCXServer</code> that will store data. Hence, this connector just acts as an interface to that server.</p> <p>Parameters:</p> <ul> <li> interface             (<code>str</code>)         \u2013 <p>The network interface to use.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The desired port for the spawned server.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def __init__(self, interface: str, port: int) -&gt; None:\nglobal server_process\nif ucx_import_error is not None:  # pragma: no cover\nraise ucx_import_error\nlogger.debug('Instantiating client and server')\nself.interface = interface\nself.host = get_ip_address(interface)\nself.port = port\nself.addr = f'{self.host}:{self.port}'\ntry:\nself._loop = asyncio.get_running_loop()\nexcept RuntimeError:\nself._loop = asyncio.new_event_loop()\nif server_process is None:\nserver_process = Process(\ntarget=launch_server,\nargs=(self.host, self.port),\n)\nserver_process.start()\nself._loop.run_until_complete(\nwait_for_server(self.host, self.port),\n)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.handler","title":"handler()  <code>async</code>","text":"<pre><code>handler(event: bytes, addr: str) -&gt; bytes\n</code></pre> <p>Handler that issues requests to the server.</p> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>async def handler(self, event: bytes, addr: str) -&gt; bytes:\n\"\"\"Handler that issues requests to the server.\"\"\"\nhost = addr.split(':')[0]  # quick fix\nport = int(addr.split(':')[1])\nep = await ucp.create_endpoint(host, port)\nawait ep.send_obj(event)\nres = await ep.recv_obj()\nawait ep.close()\nreturn bytes(res)  # returns bytearray by default\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nglobal server_process\nlogger.info('Clean up requested')\nif server_process is not None:\nserver_process.terminate()\nserver_process.join()\nserver_process = None\nlogger.debug('Clean up completed')\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {'interface': self.interface, 'port': self.port}\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; UCXConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; UCXConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.evict","title":"evict()","text":"<pre><code>evict(key: UCXKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>UCXKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def evict(self, key: UCXKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nlogger.debug(f'Client issuing an evict request on key {key}.')\nevent = serialize({'key': key.ucx_key, 'data': None, 'op': 'evict'})\nself._loop.run_until_complete(self.handler(event, key.peer))\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.exists","title":"exists()","text":"<pre><code>exists(key: UCXKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>UCXKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def exists(self, key: UCXKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nlogger.debug(f'Client issuing an exists request on key {key}.')\nevent = serialize(\n{'key': key.ucx_key, 'data': None, 'op': 'exists'},\n)\nreturn deserialize(\nself._loop.run_until_complete(self.handler(event, key.peer)),\n)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.get","title":"get()","text":"<pre><code>get(key: UCXKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>UCXKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def get(self, key: UCXKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nres: bytes | None\nlogger.debug(f'Client issuing get request on key {key}.')\nevent = serialize({'key': key.ucx_key, 'data': '', 'op': 'get'})\nres = self._loop.run_until_complete(self.handler(event, key.peer))\ntry:\ns = deserialize(res)\nassert isinstance(s, Status)\nassert not s.success\nreturn None\nexcept SerializationError:\nreturn res\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[UCXKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[UCXKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def get_batch(self, keys: Sequence[UCXKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; UCXKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UCXKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def put(self, obj: bytes) -&gt; UCXKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = UCXKey(\nucx_key=str(uuid.uuid4()),\nobj_size=len(obj),\npeer=self.addr,\n)\nlogger.debug(\nf'Client issuing set request on key {key} with addr {self.addr}',\n)\nevent = serialize({'key': key.ucx_key, 'data': obj, 'op': 'set'})\nself._loop.run_until_complete(self.handler(event, self.addr))\nreturn key\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[UCXKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[UCXKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[UCXKey]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[UCXKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    \"\"\"\nreturn [self.put(obj) for obj in objs]\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer","title":"UCXServer","text":"<pre><code>UCXServer(host: str, port: int) -&gt; None\n</code></pre> <p>UCXServer implementation.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>The server host.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The server port.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\nself.host = host\nself.port = port\nself.data = {}\nself.ucp_listener = None\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.set","title":"set()","text":"<pre><code>set(key: str, data: bytes) -&gt; Status\n</code></pre> <p>Obtain data from the client and store it in local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object key to use.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>The data to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def set(self, key: str, data: bytes) -&gt; Status:\n\"\"\"Obtain data from the client and store it in local dictionary.\n    Args:\n        key: The object key to use.\n        data: The data to store.\n    Returns:\n        Operation status.\n    \"\"\"\nself.data[key] = data\nreturn Status(success=True, error=None)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.get","title":"get()","text":"<pre><code>get(key: str) -&gt; bytes | Status\n</code></pre> <p>Return data at a given key back to the client.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def get(self, key: str) -&gt; bytes | Status:\n\"\"\"Return data at a given key back to the client.\n    Args:\n        key: The object key.\n    Returns:\n        Operation status.\n    \"\"\"\ntry:\nreturn self.data[key]\nexcept KeyError as e:\nreturn Status(success=False, error=e)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.evict","title":"evict()","text":"<pre><code>evict(key: str) -&gt; Status\n</code></pre> <p>Remove key from local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object to evict's key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def evict(self, key: str) -&gt; Status:\n\"\"\"Remove key from local dictionary.\n    Args:\n        key: The object to evict's key.\n    Returns:\n        Operation status.\n    \"\"\"\nself.data.pop(key, None)\nreturn Status(success=True, error=None)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.exists","title":"exists()","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if a key exists within local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object's key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the object exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n\"\"\"Check if a key exists within local dictionary.\n    Args:\n        key: The object's key.\n    Returns:\n        If the object exists.\n    \"\"\"\nreturn key in self.data\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.handler","title":"handler()  <code>async</code>","text":"<pre><code>handler(ep: ucp.Endpoint) -&gt; None\n</code></pre> <p>Handle endpoint requests.</p> <p>Parameters:</p> <ul> <li> ep             (<code>ucp.Endpoint</code>)         \u2013 <p>The endpoint to communicate with.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>async def handler(self, ep: ucp.Endpoint) -&gt; None:\n\"\"\"Handle endpoint requests.\n    Args:\n        ep: The endpoint to communicate with.\n    \"\"\"\njson_kv = await ep.recv_obj()\nif json_kv == bytes(1):\nawait ep.send_obj(bytes(1))\nreturn\nkv = deserialize(bytes(json_kv))\nkey = kv['key']\ndata = kv['data']\nfunc = kv['op']\nif func == 'set':\nres = self.set(key, data)\nelse:\nif func == 'get':\nfunc = self.get\nelif func == 'exists':\nfunc = self.exists\nelif func == 'evict':\nfunc = self.evict\nelse:\nraise AssertionError('Unreachable.')\nres = func(key)\nif isinstance(res, Status) or isinstance(res, bool):\nserialized_res = serialize(res)\nelse:\nserialized_res = res\nawait ep.send_obj(serialized_res)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.run","title":"run()  <code>async</code>","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run this UCXServer forever.</p> <p>Creates a listener for the handler method and waits on SIGINT/TERM events to exit. Also handles cleaning up UCP objects.</p> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>async def run(self) -&gt; None:\n\"\"\"Run this UCXServer forever.\n    Creates a listener for the handler method and waits on SIGINT/TERM\n    events to exit. Also handles cleaning up UCP objects.\n    \"\"\"\nself.ucp_listener = ucp.create_listener(self.handler, self.port)\n# Set the stop condition when receiving SIGINT (ctrl-C) and SIGTERM.\nloop = asyncio.get_running_loop()\nstop = loop.create_future()\nloop.add_signal_handler(signal.SIGINT, stop.set_result, None)\nloop.add_signal_handler(signal.SIGTERM, stop.set_result, None)\nawait stop\nself.close()\nawait reset_ucp_async()\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.UCXServer.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the server.</p> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the server.\"\"\"\nif self.ucp_listener is not None:\nself.ucp_listener.close()\nwhile not self.ucp_listener.closed():\nsleep(0.001)\n# Need to lose reference to Listener because UCP does reference\n# counting\ndel self.ucp_listener\nself.ucp_listener = None\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.launch_server","title":"launch_server()","text":"<pre><code>launch_server(host: str, port: int) -&gt; None\n</code></pre> <p>Launch the UCXServer in asyncio.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>The host for server to listen on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The port for server to listen on.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def launch_server(host: str, port: int) -&gt; None:\n\"\"\"Launch the UCXServer in asyncio.\n    Args:\n        host: The host for server to listen on.\n        port: The port for server to listen on.\n    \"\"\"\nlogger.info(f'starting server on host {host} with port {port}')\nps = UCXServer(host, port)\n# CI occasionally timeouts when starting this server in the\n# store_implementation session fixture. It seems to not happen when\n# debug=True, but this is just a temporary fix.\nasyncio.run(ps.run(), debug=True)\nlogger.info(f'server running at address {host}:{port}')\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.reset_ucp","title":"reset_ucp()","text":"<pre><code>reset_ucp() -&gt; None\n</code></pre> <p>Hard reset all of UCP.</p> <p>UCP provides <code>ucp.reset()</code>; however, this function does not correctly shutdown all asyncio tasks and readers. This function wraps <code>ucp.reset()</code> and additionally removes all readers on the event loop and cancels/awaits all asyncio tasks.</p> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>def reset_ucp() -&gt; None:  # pragma: no cover\n\"\"\"Hard reset all of UCP.\n    UCP provides `ucp.reset()`; however, this function does not correctly\n    shutdown all asyncio tasks and readers. This function wraps\n    `ucp.reset()` and additionally removes all readers on the event loop\n    and cancels/awaits all asyncio tasks.\n    \"\"\"\ndef inner_context() -&gt; None:\nctx = ucp.core._get_ctx()\nfor task in ctx.progress_tasks:\nif task is None:\ncontinue\ntask.event_loop.remove_reader(ctx.epoll_fd)\nif task.asyncio_task is not None:\ntry:\ntask.asyncio_task.cancel()\ntask.event_loop.run_until_complete(task.asyncio_task)\nexcept asyncio.CancelledError:\npass\n# We access ucp.core._get_ctx() inside this nested function so our local\n# reference to the UCP context goes out of scope before calling\n# ucp.reset(). ucp.reset() will fail if there are any weak references to\n# to the UCP context because it assumes those may be Listeners or\n# Endpoints that were not properly closed.\ninner_context()\ntry:\nucp.reset()\nexcept ucp.UCXError:\npass\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.reset_ucp_async","title":"reset_ucp_async()  <code>async</code>","text":"<pre><code>reset_ucp_async() -&gt; None\n</code></pre> <p>Hard reset all of UCP.</p> <p>UCP provides <code>ucp.reset()</code>; however, this function does not correctly shutdown all asyncio tasks and readers. This function wraps <code>ucp.reset()</code> and additionally removes all readers on the event loop and cancels/awaits all asyncio tasks.</p> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>async def reset_ucp_async() -&gt; None:  # pragma: no cover\n\"\"\"Hard reset all of UCP.\n    UCP provides `ucp.reset()`; however, this function does not correctly\n    shutdown all asyncio tasks and readers. This function wraps\n    `ucp.reset()` and additionally removes all readers on the event loop\n    and cancels/awaits all asyncio tasks.\n    \"\"\"\nasync def inner_context() -&gt; None:\nctx = ucp.core._get_ctx()\nfor task in ctx.progress_tasks:\nif task is None:\ncontinue\ntask.event_loop.remove_reader(ctx.epoll_fd)\nif task.asyncio_task is not None:\ntry:\ntask.asyncio_task.cancel()\nawait task.asyncio_task\nexcept asyncio.CancelledError:\npass\n# We access ucp.core._get_ctx() inside this nested function so our local\n# reference to the UCP context goes out of scope before calling\n# ucp.reset(). ucp.reset() will fail if there are any weak references to\n# to the UCP context because it assumes those may be Listeners or\n# Endpoints that were not properly closed.\nawait inner_context()\ntry:\nucp.reset()\nexcept ucp.UCXError:\npass\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore.connectors.dim.ucx.wait_for_server","title":"wait_for_server()  <code>async</code>","text":"<pre><code>wait_for_server(\nhost: str, port: int, timeout: float = 5.0\n) -&gt; None\n</code></pre> <p>Wait until the UCXServer responds.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>The host of UCXServer to ping.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Theport of UCXServer to ping.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>The max time in seconds to wait for server response.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/ucx.py</code> <pre><code>async def wait_for_server(host: str, port: int, timeout: float = 5.0) -&gt; None:\n\"\"\"Wait until the UCXServer responds.\n    Args:\n        host: The host of UCXServer to ping.\n        port: Theport of UCXServer to ping.\n        timeout: The max time in seconds to wait for server response.\n    \"\"\"\nsleep_time = 0.01\ntime_waited = 0.0\nwhile True:\ntry:\nep = await ucp.create_endpoint(host, port)\nexcept ucp._libs.exceptions.UCXNotConnected as e:  # pragma: no cover\nif time_waited &gt;= timeout:\nraise RuntimeError(\n'Failed to connect to server within timeout '\nf'({timeout} seconds).',\n) from e\nawait asyncio.sleep(sleep_time)\ntime_waited += sleep_time\nelse:\nbreak  # pragma: no cover\nawait ep.send_obj(bytes(1))\n_ = await ep.recv_obj()\nawait ep.close()\nassert ep.closed()\n</code></pre>"},{"location":"api/connectors/dim/utils/","title":"proxystore.connectors.dim.utils","text":"<code>proxystore/connectors/dim/utils.py</code> <p>Shared functions used by DIM stores.</p>"},{"location":"api/connectors/dim/utils/#proxystore.connectors.dim.utils.Status","title":"Status","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Task status response.</p>"},{"location":"api/connectors/dim/utils/#proxystore.connectors.dim.utils.get_ip_address","title":"get_ip_address()","text":"<pre><code>get_ip_address(ifname: str) -&gt; str\n</code></pre> <p>Get ip address provided an interface name.</p> <p>Parameters:</p> <ul> <li> ifname             (<code>str</code>)         \u2013 <p>The interface name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The IP address.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/utils.py</code> <pre><code>def get_ip_address(ifname: str) -&gt; str:\n\"\"\"Get ip address provided an interface name.\n    Args:\n        ifname: The interface name.\n    Returns:\n        The IP address.\n    \"\"\"\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\ntry:\nreturn socket.inet_ntoa(\nfcntl.ioctl(\ns.fileno(),\n0x8915,\nstruct.pack(\n'256s',\nbytes(ifname[:15], 'utf-8'),\n),  # SIOCGIFADDR\n)[20:24],\n)\nexcept OSError:\n# Not a solution, but the above doesn't work with Macs\n# need to provide IP rather than the interface name for the time being\nif ifname == 'localhost':\nifname = '127.0.0.1'\nreturn ifname\n</code></pre>"},{"location":"api/connectors/dim/zmq/","title":"proxystore.connectors.dim.zmq","text":"<code>proxystore/connectors/dim/zmq.py</code> <p>ZeroMQ-based distributed in-memory connector implementation.</p>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQKey","title":"ZeroMQKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects stored across <code>ZeroMQConnector</code>s.</p>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQKey.zmq_key","title":"zmq_key  <code>class-attribute</code>","text":"<pre><code>zmq_key: str\n</code></pre> <p>Unique object key.</p>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQKey.obj_size","title":"obj_size  <code>class-attribute</code>","text":"<pre><code>obj_size: int\n</code></pre> <p>Object size in bytes.</p>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQKey.peer","title":"peer  <code>class-attribute</code>","text":"<pre><code>peer: str\n</code></pre> <p>Peer where object is located.</p>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector","title":"ZeroMQConnector","text":"<pre><code>ZeroMQConnector(interface: str, port: int) -&gt; None\n</code></pre> <p>ZeroMQ-based distributed in-memory connector.</p> Note <p>The first instance of this connector created on a process will spawn a <code>ZeroMQServer</code> that will store data. Hence, this connector just acts as an interface to that server.</p> <p>Parameters:</p> <ul> <li> interface             (<code>str</code>)         \u2013 <p>The network interface to use.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The desired port for the spawned server.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def __init__(self, interface: str, port: int) -&gt; None:\nglobal server_process\n# ZMQ is not a default dependency so we don't want to raise\n# an error unless the user actually tries to use this code\nif zmq_import_error is not None:  # pragma: no cover\nraise zmq_import_error\nlogger.debug('Instantiating client and server')\nself.chunk_size = MAX_CHUNK_LENGTH\nself.interface = interface\nself.host = get_ip_address(interface)\nself.port = port\nself.addr = f'tcp://{self.host}:{self.port}'\nif server_process is None:\nserver_process = Process(target=self._start_server)\nserver_process.start()\nself.context = zmq.asyncio.Context()\nself.socket = self.context.socket(zmq.REQ)\ntry:\nself._loop = asyncio.get_running_loop()\nexcept RuntimeError:\nself._loop = asyncio.new_event_loop()\nself._loop.run_until_complete(wait_for_server(self.host, self.port))\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.handler","title":"handler()  <code>async</code>","text":"<pre><code>handler(event: bytes, addr: str) -&gt; bytes\n</code></pre> <p>ZeroMQ handler function implementation.</p> <p>Parameters:</p> <ul> <li> event             (<code>bytes</code>)         \u2013 <p>A pickled dictionary consisting of the data, its key, and the operation to perform on the data.</p> </li> <li> addr             (<code>str</code>)         \u2013 <p>The address of the server to connect to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>         \u2013 <p>The serialized result of the operation on the data.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>async def handler(self, event: bytes, addr: str) -&gt; bytes:\n\"\"\"ZeroMQ handler function implementation.\n    Args:\n        event: A pickled dictionary consisting of the data,\n            its key, and the operation to perform on the data.\n        addr: The address of the server to connect to.\n    Returns:\n        The serialized result of the operation on the data.\n    \"\"\"\nwith self.socket.connect(addr):\nawait self.socket.send_multipart(\nlist(utils.chunk_bytes(event, self.chunk_size)),\n)\nres = b''.join(await self.socket.recv_multipart())\nassert isinstance(res, bytes)\nreturn res\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nglobal server_process\nlogger.info('Clean up requested')\nif server_process is not None:  # pragma: no cover\nserver_process.terminate()\nserver_process.join()\nserver_process = None\nlogger.debug('Clean up completed')\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the connector configuration.\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\nreturn {'interface': self.interface, 'port': self.port}\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; ZeroMQConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; ZeroMQConnector:\n\"\"\"Create a new connector instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\nreturn cls(**config)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.evict","title":"evict()","text":"<pre><code>evict(key: ZeroMQKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>ZeroMQKey</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def evict(self, key: ZeroMQKey) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nlogger.debug(f'Client issuing an evict request on key {key}.')\nevent = serialize(\n{'key': key.zmq_key, 'data': None, 'op': 'evict'},\n)\nself._loop.run_until_complete(self.handler(event, key.peer))\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.exists","title":"exists()","text":"<pre><code>exists(key: ZeroMQKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>ZeroMQKey</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def exists(self, key: ZeroMQKey) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nlogger.debug(f'Client issuing an exists request on key {key}.')\nevent = serialize(\n{'key': key.zmq_key, 'data': None, 'op': 'exists'},\n)\nreturn deserialize(\nself._loop.run_until_complete(self.handler(event, key.peer)),\n)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.get","title":"get()","text":"<pre><code>get(key: ZeroMQKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>ZeroMQKey</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def get(self, key: ZeroMQKey) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\nlogger.debug(f'Client issuing get request on key {key}')\nevent = serialize(\n{'key': key.zmq_key, 'data': None, 'op': 'get'},\n)\nres = self._loop.run_until_complete(self.handler(event, key.peer))\ntry:\ns = deserialize(res)\nassert isinstance(s, Status)\nassert not s.success\nreturn None\nexcept SerializationError:\nreturn res\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[ZeroMQKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> keys             (<code>Sequence[ZeroMQKey]</code>)         \u2013 <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013 <p>List with same order as <code>keys</code> with the serialized objects or</p> </li> <li> <code>list[bytes | None]</code>         \u2013 <p><code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def get_batch(self, keys: Sequence[ZeroMQKey]) -&gt; list[bytes | None]:\n\"\"\"Get a batch of serialized objects associated with the keys.\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n    Returns:\n        List with same order as `keys` with the serialized objects or\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\nreturn [self.get(key) for key in keys]\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; ZeroMQKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>bytes</code>)         \u2013 <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ZeroMQKey</code>         \u2013 <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def put(self, obj: bytes) -&gt; ZeroMQKey:\n\"\"\"Put a serialized object in the store.\n    Args:\n        obj: Serialized object to put in the store.\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\nkey = ZeroMQKey(\nzmq_key=str(uuid.uuid4()),\nobj_size=len(obj),\npeer=self.addr,\n)\nlogger.debug(\nf'Client issuing set request on key {key} with addr {self.addr}',\n)\nevent = serialize(\n{'key': key.zmq_key, 'data': obj, 'op': 'set'},\n)\nself._loop.run_until_complete(self.handler(event, self.addr))\nreturn key\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[ZeroMQKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[bytes]</code>)         \u2013 <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ZeroMQKey]</code>         \u2013 <p>List of keys with the same order as <code>objs</code> which can be used to</p> </li> <li> <code>list[ZeroMQKey]</code>         \u2013 <p>retrieve the objects.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[ZeroMQKey]:\n\"\"\"Put a batch of serialized objects in the store.\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n    Returns:\n        List of keys with the same order as `objs` which can be used to\n        retrieve the objects.\n    \"\"\"\nreturn [self.put(obj) for obj in objs]\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer","title":"ZeroMQServer","text":"<pre><code>ZeroMQServer(host: str, port: int) -&gt; None\n</code></pre> <p>ZeroMQServer implementation.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>IP address of the location to start the server.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The port to initiate communication on.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\nself.host = host\nself.port = port\nself.chunk_size = MAX_CHUNK_LENGTH\nself.data = {}\nself.context = zmq.asyncio.Context()\nself.socket = self.context.socket(zmq.REP)\nself.socket.bind(f'tcp://{self.host}:{self.port}')\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.set","title":"set()","text":"<pre><code>set(key: str, data: bytes) -&gt; Status\n</code></pre> <p>Obtain and store locally data from client.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Object key to use.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Data to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def set(self, key: str, data: bytes) -&gt; Status:\n\"\"\"Obtain and store locally data from client.\n    Args:\n        key: Object key to use.\n        data: Data to store.\n    Returns:\n        Operation status.\n    \"\"\"\nself.data[key] = data\nreturn Status(success=True, error=None)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.get","title":"get()","text":"<pre><code>get(key: str) -&gt; bytes | Status\n</code></pre> <p>Return data at a given key back to the client.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def get(self, key: str) -&gt; bytes | Status:\n\"\"\"Return data at a given key back to the client.\n    Args:\n        key: The object key.\n    Returns:\n        Operation status.\n    \"\"\"\ntry:\nreturn self.data[key]\nexcept KeyError as e:\nreturn Status(False, e)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.evict","title":"evict()","text":"<pre><code>evict(key: str) -&gt; Status\n</code></pre> <p>Remove key from local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object to evict's key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def evict(self, key: str) -&gt; Status:\n\"\"\"Remove key from local dictionary.\n    Args:\n        key: The object to evict's key.\n    Returns:\n        Operation status.\n    \"\"\"\nself.data.pop(key, None)\nreturn Status(success=True, error=None)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.exists","title":"exists()","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if a key exists within local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object's key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the key exists.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n\"\"\"Check if a key exists within local dictionary.\n    Args:\n        key: The object's key.\n    Returns:\n        If the key exists.\n    \"\"\"\nreturn key in self.data\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.handler","title":"handler()  <code>async</code>","text":"<pre><code>handler() -&gt; None\n</code></pre> <p>Handle zmq connection requests.</p> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>async def handler(self) -&gt; None:\n\"\"\"Handle zmq connection requests.\"\"\"\nwhile not self.socket.closed:  # pragma: no branch\ntry:\npkv = await self.socket.recv_multipart()\nkvb = b''.join(pkv)\nif kvb == b'ping':\nself.socket.send(b'pong')\ncontinue\nkv = deserialize(kvb)\nkey = kv['key']\ndata = kv['data']\nfunc = kv['op']\nif func == 'set':\nres = self.set(key, data)\nelse:\nif func == 'get':\nfunc = self.get\nelif func == 'exists':\nfunc = self.exists\nelif func == 'evict':\nfunc = self.evict\nelse:\nraise AssertionError('Unreachable.')\nres = func(key)\nif isinstance(res, Status) or isinstance(res, bool):\nserialized_res = serialize(res)\nelse:\nserialized_res = res\nawait self.socket.send_multipart(\nlist(\nutils.chunk_bytes(serialized_res, self.chunk_size),\n),\n)\nexcept zmq.ZMQError as e:  # pragma: no cover\nlogger.exception(e)\nawait asyncio.sleep(0.01)\nexcept asyncio.exceptions.CancelledError:  # pragma: no cover\nlogger.debug('loop terminated')\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.ZeroMQServer.launch","title":"launch()  <code>async</code>","text":"<pre><code>launch() -&gt; None\n</code></pre> <p>Launch the server.</p> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>async def launch(self) -&gt; None:\n\"\"\"Launch the server.\"\"\"\nloop = asyncio.get_running_loop()\nloop.create_future()\nloop.add_signal_handler(signal.SIGINT, self.socket.close, None)\nloop.add_signal_handler(signal.SIGTERM, self.socket.close, None)\nawait self.handler()\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore.connectors.dim.zmq.wait_for_server","title":"wait_for_server()  <code>async</code>","text":"<pre><code>wait_for_server(\nhost: str, port: int, timeout: float = 5.0\n) -&gt; None\n</code></pre> <p>Wait until the ZeroMQServer responds.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>The host of the server to ping.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The port of the server to ping.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>The max time in seconds to wait for server response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013         <p>if the server does not respond within the timeout.</p> </li> </ul> Source code in <code>proxystore/connectors/dim/zmq.py</code> <pre><code>async def wait_for_server(host: str, port: int, timeout: float = 5.0) -&gt; None:\n\"\"\"Wait until the ZeroMQServer responds.\n    Args:\n        host: The host of the server to ping.\n        port: The port of the server to ping.\n        timeout: The max time in seconds to wait for server response.\n    Raises:\n        RuntimeError: if the server does not respond within the timeout.\n    \"\"\"\nstart = time.time()\ncontext = zmq.asyncio.Context()\nsocket = context.socket(zmq.REQ)\nsocket.setsockopt(zmq.LINGER, 0)\nwith socket.connect(f'tcp://{host}:{port}'):\nawait socket.send(b'ping')\npoller = zmq.asyncio.Poller()\npoller.register(socket, zmq.POLLIN)\nwhile time.time() - start &lt; timeout:\nevent = await poller.poll(timeout)\nif len(event) != 0:\nresponse = await socket.recv()\nassert response == b'pong'\nsocket.close()\nreturn\nsocket.close()\nraise RuntimeError(\n'Failed to connect to server within timeout ({timeout} seconds).',\n)\n</code></pre>"},{"location":"api/endpoint/","title":"proxystore.endpoint","text":"<code>proxystore/endpoint/__init__.py</code> <p>Endpoints for direct, cross-site communication.</p> Note <p>Please refer to the Endpoints Guide for an introduction to endpoints in ProxyStore.</p> <p><code>Endpoints</code> are in-memory object stores with peering capabilities. Endpoints enable peer-to-peer data transfer between clients behind different NATs. See the <code>proxystore-endpoint</code> CLI reference to start your own endpoints.</p>"},{"location":"api/endpoint/cli/","title":"proxystore.endpoint.cli","text":"<code>proxystore/endpoint/cli.py</code> <p><code>proxystore-endpoint</code> command-line interface.</p> <p>See the CLI Reference for the <code>proxystore-endpoint</code> usage instructions.</p>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.cli","title":"cli()","text":"<pre><code>cli(ctx: click.Context, log_level: str) -&gt; None\n</code></pre> <p>Manage and start ProxyStore Endpoints.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@click.group()\n@click.option(\n'--log-level',\ndefault='INFO',\ntype=click.Choice(\n['ERROR', 'WARNING', 'INFO', 'DEBUG'],\ncase_sensitive=False,\n),\nhelp='Minimum logging level.',\n)\n@click.pass_context\ndef cli(ctx: click.Context, log_level: str) -&gt; None:\n\"\"\"Manage and start ProxyStore Endpoints.\"\"\"\nhandler = logging.StreamHandler(sys.stdout)\nhandler.setFormatter(_CLIFormatter())\nlogging.basicConfig(level=log_level, handlers=[handler])\nctx.ensure_object(dict)\nctx.obj['LOG_LEVEL'] = log_level\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.show_help","title":"show_help()","text":"<pre><code>show_help() -&gt; None\n</code></pre> <p>Show available commands and options.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command(name='help')\ndef show_help() -&gt; None:\n\"\"\"Show available commands and options.\"\"\"\nwith click.Context(cli) as ctx:\nclick.echo(cli.get_help(ctx))\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.version","title":"version()","text":"<pre><code>version() -&gt; None\n</code></pre> <p>Show the ProxyStore version.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command()\ndef version() -&gt; None:\n\"\"\"Show the ProxyStore version.\"\"\"\nclick.echo(f'ProxyStore v{proxystore.__version__}')\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.configure","title":"configure()","text":"<pre><code>configure(\nname: str,\nport: int,\nrelay_server: str,\nmax_memory: int | None,\ndump_dir: str | None,\npeer_channels: int,\n) -&gt; None\n</code></pre> <p>Configure a new endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command()\n@click.argument('name', metavar='NAME', required=True)\n@click.option(\n'--port',\ndefault=8765,\ntype=int,\nmetavar='PORT',\nhelp='Port to listen on.',\n)\n@click.option(\n'--relay-server',\ndefault=None,\nmetavar='ADDR',\nhelp='Optional relay server address.',\n)\n@click.option(\n'--max-memory',\ndefault=None,\ntype=int,\nmetavar='BYTES',\nhelp='Optional maximum memory to use.',\n)\n@click.option(\n'--dump-dir',\ndefault=None,\nmetavar='PATH',\nhelp='Directory to dump object to if max-memory exceeded.',\n)\n@click.option(\n'--peer-channels',\ndefault=1,\ntype=int,\nmetavar='COUNT',\nhelp='Datachannels to use per peer connection.',\n)\ndef configure(\nname: str,\nport: int,\nrelay_server: str,\nmax_memory: int | None,\ndump_dir: str | None,\npeer_channels: int,\n) -&gt; None:\n\"\"\"Configure a new endpoint.\"\"\"\nraise SystemExit(\nconfigure_endpoint(\nname,\nport=port,\nrelay_server=relay_server,\nmax_memory=max_memory,\ndump_dir=dump_dir,\npeer_channels=peer_channels,\n),\n)\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.list_all","title":"list_all()","text":"<pre><code>list_all() -&gt; None\n</code></pre> <p>List all user endpoints.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command(name='list')\ndef list_all() -&gt; None:\n\"\"\"List all user endpoints.\"\"\"\nraise SystemExit(list_endpoints())\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.remove","title":"remove()","text":"<pre><code>remove(name: str) -&gt; None\n</code></pre> <p>Remove an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command()\n@click.argument('name', metavar='NAME', required=True)\ndef remove(name: str) -&gt; None:\n\"\"\"Remove an endpoint.\"\"\"\nraise SystemExit(remove_endpoint(name))\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.start","title":"start()","text":"<pre><code>start(ctx: click.Context, name: str, detach: bool) -&gt; None\n</code></pre> <p>Start an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command()\n@click.argument('name', metavar='NAME', required=True)\n@click.option('--detach/--no-detach', default=True, help='Run as daemon.')\n@click.pass_context\ndef start(ctx: click.Context, name: str, detach: bool) -&gt; None:\n\"\"\"Start an endpoint.\"\"\"\nraise SystemExit(\nstart_endpoint(name, detach=detach, log_level=ctx.obj['LOG_LEVEL']),\n)\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.stop","title":"stop()","text":"<pre><code>stop(name: str) -&gt; None\n</code></pre> <p>Stop a detached endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.command()\n@click.argument('name', metavar='NAME', required=True)\ndef stop(name: str) -&gt; None:\n\"\"\"Stop a detached endpoint.\"\"\"\nraise SystemExit(stop_endpoint(name))\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.test","title":"test()","text":"<pre><code>test(\nctx: click.Context, name: str, remote: str | None\n) -&gt; None\n</code></pre> <p>Execute test commands on an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@cli.group()\n@click.argument('name', metavar='NAME', required=True)\n@click.option(\n'--remote',\nmetavar='UUID',\nhelp='Optional UUID of remote endpoint to use.',\n)\n@click.pass_context\ndef test(\nctx: click.Context,\nname: str,\nremote: str | None,\n) -&gt; None:\n\"\"\"Execute test commands on an endpoint.\"\"\"\nctx.ensure_object(dict)\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\nif os.path.isdir(endpoint_dir):\ncfg = read_config(endpoint_dir)\nelse:\nlogger.error(f'An endpoint named {name} does not exist.')\nraise SystemExit(1)\nctx.obj['ENDPOINT_ADDRESS'] = f'http://{cfg.host}:{cfg.port}'\nctx.obj['REMOTE_ENDPOINT_UUID'] = remote\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.evict","title":"evict()","text":"<pre><code>evict(ctx: click.Context, key: str) -&gt; None\n</code></pre> <p>Evict object from an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@test.command()\n@click.argument('key', metavar='KEY', required=True)\n@click.pass_context\ndef evict(ctx: click.Context, key: str) -&gt; None:\n\"\"\"Evict object from an endpoint.\"\"\"\naddress = ctx.obj['ENDPOINT_ADDRESS']\nremote = ctx.obj['REMOTE_ENDPOINT_UUID']\ntry:\nclient.evict(address, key, remote)\nexcept requests.exceptions.ConnectionError as e:\nlogger.error(f'Unable to connect to endpoint at {address}.')\nlogger.debug(e)\nsys.exit(1)\nexcept requests.exceptions.RequestException as e:\nlogger.exception(e)\nsys.exit(1)\nelse:\nlogger.info('Evicted object from endpoint.')\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.exists","title":"exists()","text":"<pre><code>exists(ctx: click.Context, key: str) -&gt; None\n</code></pre> <p>Check if object exists in an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@test.command()\n@click.argument('key', metavar='KEY', required=True)\n@click.pass_context\ndef exists(ctx: click.Context, key: str) -&gt; None:\n\"\"\"Check if object exists in an endpoint.\"\"\"\naddress = ctx.obj['ENDPOINT_ADDRESS']\nremote = ctx.obj['REMOTE_ENDPOINT_UUID']\ntry:\nres = client.exists(address, key, remote)\nexcept requests.exceptions.ConnectionError as e:\nlogger.error(f'Unable to connect to endpoint at {address}.')\nlogger.debug(e)\nsys.exit(1)\nexcept requests.exceptions.RequestException as e:\nlogger.exception(e)\nsys.exit(1)\nelse:\nlogger.info(f'Object exists: {res}')\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.get","title":"get()","text":"<pre><code>get(ctx: click.Context, key: str) -&gt; None\n</code></pre> <p>Get an object from an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@test.command()\n@click.argument('key', metavar='KEY', required=True)\n@click.pass_context\ndef get(ctx: click.Context, key: str) -&gt; None:\n\"\"\"Get an object from an endpoint.\"\"\"\naddress = ctx.obj['ENDPOINT_ADDRESS']\nremote = ctx.obj['REMOTE_ENDPOINT_UUID']\ntry:\nres = client.get(address, key, remote)\nexcept requests.exceptions.ConnectionError as e:\nlogger.error(f'Unable to connect to endpoint at {address}.')\nlogger.debug(e)\nsys.exit(1)\nexcept requests.exceptions.RequestException as e:\nlogger.exception(e)\nsys.exit(1)\nif res is None:\nlogger.info('Object does not exist.')\nelse:\nobj = deserialize(res)\nlogger.info(f'Result: {obj}')\n</code></pre>"},{"location":"api/endpoint/cli/#proxystore.endpoint.cli.put","title":"put()","text":"<pre><code>put(ctx: click.Context, data: str) -&gt; None\n</code></pre> <p>Put an object in an endpoint.</p> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>@test.command()\n@click.argument('data', required=True)\n@click.pass_context\ndef put(ctx: click.Context, data: str) -&gt; None:\n\"\"\"Put an object in an endpoint.\"\"\"\naddress = ctx.obj['ENDPOINT_ADDRESS']\nremote = ctx.obj['REMOTE_ENDPOINT_UUID']\nkey = str(uuid.uuid4())\ndata_ = serialize(data)\ntry:\nclient.put(address, key, data_, remote)\nexcept requests.exceptions.ConnectionError as e:\nlogger.error(f'Unable to connect to endpoint at {address}.')\nlogger.debug(e)\nsys.exit(1)\nexcept requests.exceptions.RequestException as e:\nlogger.exception(e)\nsys.exit(1)\nelse:\nlogger.info(f'Put object in endpoint with key {key}')\n</code></pre>"},{"location":"api/endpoint/client/","title":"proxystore.endpoint.client","text":"<code>proxystore/endpoint/client.py</code> <p>Utilities for client interactions with endpoints.</p>"},{"location":"api/endpoint/client/#proxystore.endpoint.client.evict","title":"evict()","text":"<pre><code>evict(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\n) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of endpoint.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key associated with object to evict.</p> </li> <li> endpoint             (<code>uuid.UUID | str | None</code>)         \u2013 <p>Optional UUID of remote endpoint to forward operation to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestException</code>           \u2013         <p>If the endpoint request results in an unexpected error code.</p> </li> </ul> Source code in <code>proxystore/endpoint/client.py</code> <pre><code>def evict(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\n) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        address: Address of endpoint.\n        key: Key associated with object to evict.\n        endpoint: Optional UUID of remote endpoint to forward operation to.\n    Raises:\n        RequestException: If the endpoint request results in an unexpected\n            error code.\n    \"\"\"\nendpoint_str = (\nstr(endpoint) if isinstance(endpoint, uuid.UUID) else endpoint\n)\nresponse = requests.post(\nf'{address}/evict',\nparams={'key': key, 'endpoint': endpoint_str},\n)\nresponse.raise_for_status()\n</code></pre>"},{"location":"api/endpoint/client/#proxystore.endpoint.client.exists","title":"exists()","text":"<pre><code>exists(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\n) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of endpoint.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> <li> endpoint             (<code>uuid.UUID | str | None</code>)         \u2013 <p>Optional UUID of remote endpoint to forward operation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestException</code>           \u2013         <p>If the endpoint request results in an unexpected error code.</p> </li> </ul> Source code in <code>proxystore/endpoint/client.py</code> <pre><code>def exists(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\n) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        address: Address of endpoint.\n        key: Key potentially associated with stored object.\n        endpoint: Optional UUID of remote endpoint to forward operation to.\n    Returns:\n        If an object associated with the key exists.\n    Raises:\n        RequestException: If the endpoint request results in an unexpected\n            error code.\n    \"\"\"\nendpoint_str = (\nstr(endpoint) if isinstance(endpoint, uuid.UUID) else endpoint\n)\nresponse = requests.get(\nf'{address}/exists',\nparams={'key': key, 'endpoint': endpoint_str},\n)\nresponse.raise_for_status()\nreturn response.json()['exists']\n</code></pre>"},{"location":"api/endpoint/client/#proxystore.endpoint.client.get","title":"get()","text":"<pre><code>get(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\n) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of endpoint.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key associated with object to retrieve.</p> </li> <li> endpoint             (<code>uuid.UUID | str | None</code>)         \u2013 <p>Optional UUID of remote endpoint to forward operation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestException</code>           \u2013         <p>If the endpoint request results in an unexpected error code.</p> </li> </ul> Source code in <code>proxystore/endpoint/client.py</code> <pre><code>def get(\naddress: str,\nkey: str,\nendpoint: uuid.UUID | str | None = None,\n) -&gt; bytes | None:\n\"\"\"Get the serialized object associated with the key.\n    Args:\n        address: Address of endpoint.\n        key: Key associated with object to retrieve.\n        endpoint: Optional UUID of remote endpoint to forward operation to.\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    Raises:\n        RequestException: If the endpoint request results in an unexpected\n            error code.\n    \"\"\"\nendpoint_str = (\nstr(endpoint) if isinstance(endpoint, uuid.UUID) else endpoint\n)\nresponse = requests.get(\nf'{address}/get',\nparams={'key': key, 'endpoint': endpoint_str},\nstream=True,\n)\nif response.status_code == 400:\nreturn None\nresponse.raise_for_status()\ndata = bytearray()\nfor chunk in response.iter_content(chunk_size=None):\ndata += chunk\nreturn bytes(data)\n</code></pre>"},{"location":"api/endpoint/client/#proxystore.endpoint.client.put","title":"put()","text":"<pre><code>put(\naddress: str,\nkey: str,\ndata: bytes,\nendpoint: uuid.UUID | str | None = None,\n) -&gt; None\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of endpoint.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key associated with object to retrieve.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Serialized data to put in the store.</p> </li> <li> endpoint             (<code>uuid.UUID | str | None</code>)         \u2013 <p>Optional UUID of remote endpoint to forward operation to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestException</code>           \u2013         <p>If the endpoint request results in an unexpected error code.</p> </li> </ul> Source code in <code>proxystore/endpoint/client.py</code> <pre><code>def put(\naddress: str,\nkey: str,\ndata: bytes,\nendpoint: uuid.UUID | str | None = None,\n) -&gt; None:\n\"\"\"Put a serialized object in the store.\n    Args:\n        address: Address of endpoint.\n        key: Key associated with object to retrieve.\n        data: Serialized data to put in the store.\n        endpoint: Optional UUID of remote endpoint to forward operation to.\n    Raises:\n        RequestException: If the endpoint request results in an unexpected\n            error code.\n    \"\"\"\nendpoint_str = (\nstr(endpoint) if isinstance(endpoint, uuid.UUID) else endpoint\n)\nresponse = requests.post(\nf'{address}/set',\nheaders={'Content-Type': 'application/octet-stream'},\nparams={'key': key, 'endpoint': endpoint_str},\ndata=chunk_bytes(data, MAX_CHUNK_LENGTH),\nstream=True,\n)\nresponse.raise_for_status()\n</code></pre>"},{"location":"api/endpoint/commands/","title":"proxystore.endpoint.commands","text":"<code>proxystore/endpoint/commands.py</code> <p>Endpoint management commands.</p> <p>These are the implementations of the commands available via the <code>proxystore-endpoint</code> command. Subsequently, all commands log errors and results and return status codes (rather than raising errors and returning results).</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus","title":"EndpointStatus","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Endpoint status.</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.RUNNING","title":"RUNNING  <code>class-attribute</code>","text":"<pre><code>RUNNING = enum.auto()\n</code></pre> <p>Endpoint is running on this host.</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.STOPPED","title":"STOPPED  <code>class-attribute</code>","text":"<pre><code>STOPPED = enum.auto()\n</code></pre> <p>Endpoint is stopped.</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code>","text":"<pre><code>UNKNOWN = enum.auto()\n</code></pre> <p>Endpoint cannot be found (missing/corrupted directory).</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.HANGING","title":"HANGING  <code>class-attribute</code>","text":"<pre><code>HANGING = enum.auto()\n</code></pre> <p>Endpoint PID file exists but process is not active.</p> <p>This is either because the process died unexpectedly or the endpoint is running on another host.</p>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.get_status","title":"get_status()","text":"<pre><code>get_status(\nname: str, proxystore_dir: str | None = None\n) -&gt; EndpointStatus\n</code></pre> <p>Check status of endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to check.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EndpointStatus</code>         \u2013 <p><code>EndpointStatus.RUNNING</code> if the endpoint has a valid directory and         the PID file points to a running process.         <code>EndpointStatus.STOPPED</code> if the endpoint has a valid directory and no         PID file.         <code>EndpointStatus.UNKNOWN</code> if the endpoint directory is missing or the         config file is missing/unreadable.         <code>EndpointStatus.HANGING</code> if the endpoint has a valid directory but         the PID file does not point to a running process. This can be due to         the endpoint process dying unexpectedly or the endpoint process is on         a different host.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def get_status(name: str, proxystore_dir: str | None = None) -&gt; EndpointStatus:\n\"\"\"Check status of endpoint.\n    Args:\n        name: Name of endpoint to check.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        `EndpointStatus.RUNNING` if the endpoint has a valid directory and \\\n        the PID file points to a running process. \\\n        `EndpointStatus.STOPPED` if the endpoint has a valid directory and no \\\n        PID file. \\\n        `EndpointStatus.UNKNOWN` if the endpoint directory is missing or the \\\n        config file is missing/unreadable. \\\n        `EndpointStatus.HANGING` if the endpoint has a valid directory but \\\n        the PID file does not point to a running process. This can be due to \\\n        the endpoint process dying unexpectedly or the endpoint process is on \\\n        a different host.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\nif not os.path.isdir(endpoint_dir):\nreturn EndpointStatus.UNKNOWN\ntry:\nread_config(endpoint_dir)\nexcept (FileNotFoundError, ValueError) as e:\nlogger.error(e)\nreturn EndpointStatus.UNKNOWN\npid_file = get_pid_filepath(endpoint_dir)\nif not os.path.isfile(pid_file):\nreturn EndpointStatus.STOPPED\npid = int(open(pid_file).read().strip())\nif psutil.pid_exists(pid):\nreturn EndpointStatus.RUNNING\nelse:\nreturn EndpointStatus.HANGING\n</code></pre>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.configure_endpoint","title":"configure_endpoint()","text":"<pre><code>configure_endpoint(\nname: str,\n*,\nport: int,\nrelay_server: str | None,\nproxystore_dir: str | None = None,\nmax_memory: int | None = None,\ndump_dir: str | None = None,\npeer_channels: int = 1\n) -&gt; int\n</code></pre> <p>Configure a new endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port for endpoint to listen on.</p> </li> <li> relay_server             (<code>str | None</code>)         \u2013 <p>Optional relay server address for P2P endpoint connections.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> <li> max_memory             (<code>int | None</code>)         \u2013 <p>Optional max memory in bytes to use for storing objects. If exceeded, LRU objects will be dumped to <code>dump_dir</code>.</p> </li> <li> dump_dir             (<code>str | None</code>)         \u2013 <p>Optional directory to dump objects to if the memory limit is exceeded.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>Number of datachannels per peer connection to another endpoint to communicate over.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def configure_endpoint(\nname: str,\n*,\nport: int,\nrelay_server: str | None,\nproxystore_dir: str | None = None,\nmax_memory: int | None = None,\ndump_dir: str | None = None,\npeer_channels: int = 1,\n) -&gt; int:\n\"\"\"Configure a new endpoint.\n    Args:\n        name: Name of endpoint.\n        port: Port for endpoint to listen on.\n        relay_server: Optional relay server address for P2P endpoint connections.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n        max_memory: Optional max memory in bytes to use for storing\n            objects. If exceeded, LRU objects will be dumped to `dump_dir`.\n        dump_dir: Optional directory to dump objects to if the\n            memory limit is exceeded.\n        peer_channels: Number of datachannels per peer connection\n            to another endpoint to communicate over.\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\ntry:\ncfg = EndpointConfig(\nname=name,\nuuid=uuid.uuid4(),\nhost=None,\nport=port,\nrelay_server=relay_server,\nmax_memory=max_memory,\ndump_dir=dump_dir,\npeer_channels=peer_channels,\n)\nexcept ValueError as e:\nlogger.error(str(e))\nreturn 1\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\nif os.path.exists(endpoint_dir):\nlogger.error(f'An endpoint named {name} already exists.')\nlogger.info('To reconfigure the endpoint, remove and try again.')\nreturn 1\nwrite_config(cfg, endpoint_dir)\nlogger.info(f'Configured endpoint {cfg.name} &lt;{cfg.uuid}&gt;. Start with:')\nlogger.info(f'  $ proxystore-endpoint start {cfg.name}')\nreturn 0\n</code></pre>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.list_endpoints","title":"list_endpoints()","text":"<pre><code>list_endpoints(*, proxystore_dir: str | None = None) -&gt; int\n</code></pre> <p>List available endpoints.</p> <p>Parameters:</p> <ul> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def list_endpoints(\n*,\nproxystore_dir: str | None = None,\n) -&gt; int:\n\"\"\"List available endpoints.\n    Args:\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoints = get_configs(proxystore_dir)\nif len(endpoints) == 0:\nlogger.info(f'No valid endpoint configurations in {proxystore_dir}.')\nelse:\neps = [(e.name, str(e.uuid)) for e in endpoints]\neps = sorted(eps, key=lambda x: x[0])\nlogger.info(f'{\"NAME\":&lt;18} {\"STATUS\":&lt;8} UUID', extra={'simple': True})\nlogger.info('=' * (19 + 9 + len(eps[0][1])), extra={'simple': True})\nfor name, uuid_ in eps:\nstatus = get_status(name, proxystore_dir)\nlogger.info(\nf'{name:18.18} {status.name:&lt;8.8} {uuid_}',\nextra={'simple': True},\n)\nreturn 0\n</code></pre>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.remove_endpoint","title":"remove_endpoint()","text":"<pre><code>remove_endpoint(\nname: str, *, proxystore_dir: str | None = None\n) -&gt; int\n</code></pre> <p>Remove endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to remove.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def remove_endpoint(\nname: str,\n*,\nproxystore_dir: str | None = None,\n) -&gt; int:\n\"\"\"Remove endpoint.\n    Args:\n        name: Name of endpoint to remove.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\nif not os.path.exists(endpoint_dir):\nlogger.error(f'An endpoint named {name} does not exist.')\nreturn 1\nstatus = get_status(name, proxystore_dir)\nif status in (EndpointStatus.RUNNING, EndpointStatus.HANGING):\nlogger.error('Endpoint must be stopped before removing.')\nlogger.error(f'  $ proxystore-endpoint stop {name}')\nreturn 1\nshutil.rmtree(endpoint_dir)\nlogger.info(f'Removed endpoint named {name}.')\nreturn 0\n</code></pre>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.start_endpoint","title":"start_endpoint()","text":"<pre><code>start_endpoint(\nname: str,\n*,\ndetach: bool = False,\nlog_level: str = \"INFO\",\nproxystore_dir: str | None = None\n) -&gt; int\n</code></pre> <p>Start endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to start.</p> </li> <li> detach             (<code>bool</code>)         \u2013 <p>Start the endpoint as a daemon process.</p> </li> <li> log_level             (<code>str</code>)         \u2013 <p>Logging level of the endpoint.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def start_endpoint(\nname: str,\n*,\ndetach: bool = False,\nlog_level: str = 'INFO',\nproxystore_dir: str | None = None,\n) -&gt; int:\n\"\"\"Start endpoint.\n    Args:\n        name: Name of endpoint to start.\n        detach: Start the endpoint as a daemon process.\n        log_level: Logging level of the endpoint.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nstatus = get_status(name, proxystore_dir)\nif status == EndpointStatus.RUNNING:\nlogger.error(f'Endpoint {name} is already running.')\nreturn 1\nelif status == EndpointStatus.UNKNOWN:\nlogger.error(f'A valid endpoint named {name} does not exist.')\nlogger.error('Use `list` to see available endpoints.')\nreturn 1\nendpoint_dir = os.path.join(proxystore_dir, name)\ncfg = read_config(endpoint_dir)\n# Use IP address here which is generally more reliable\nhostname = socket.gethostbyname(utils.hostname())\npid_file = get_pid_filepath(endpoint_dir)\nif (\nstatus == EndpointStatus.HANGING\nand cfg.host is not None\nand hostname != cfg.host\n):\nlogger.error(\n'A PID file exists for the endpoint, but the config indicates the '\nf'endpoint is running on a host named {cfg.host}. Try stopping '\nf'the endpoint on {cfg.host}. Otherwise, delete the PID file at '\nf'{pid_file} and try again.',\n)\nreturn 1\nelif status == EndpointStatus.HANGING:\nlogger.debug(f'Removing invalid PID file ({pid_file}).')\nos.remove(pid_file)\n# Write out new config with host so clients can see the current host\ncfg.host = hostname\nwrite_config(cfg, endpoint_dir)\nlog_file = get_log_filepath(endpoint_dir)\nif detach:\nlogger.info('Starting endpoint process as daemon.')\nlogger.info(f'Logs will be written to {log_file}')\ncontext = daemon.DaemonContext(\nworking_directory=endpoint_dir,\numask=0o002,\npidfile=daemon.pidfile.PIDLockFile(pid_file),\ndetach_process=True,\n# Note: stdin, stdout, stderr left as None which binds to /dev/null\n)\nelse:\ncontext = _attached_pid_manager(pid_file)\n# TODO: handle sigterm/sigkill exit codes/graceful shutdown.\nwith context:\nserve(cfg, log_level=log_level, log_file=log_file)\nreturn 0\n</code></pre>"},{"location":"api/endpoint/commands/#proxystore.endpoint.commands.stop_endpoint","title":"stop_endpoint()","text":"<pre><code>stop_endpoint(\nname: str, *, proxystore_dir: str | None = None\n) -&gt; int\n</code></pre> <p>Stop endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to start.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def stop_endpoint(name: str, *, proxystore_dir: str | None = None) -&gt; int:\n\"\"\"Stop endpoint.\n    Args:\n        name: Name of endpoint to start.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nstatus = get_status(name, proxystore_dir)\nif status == EndpointStatus.UNKNOWN:\nlogger.error(f'A valid endpoint named {name} does not exist.')\nlogger.error('Use `list` to see available endpoints.')\nreturn 1\nelif status == EndpointStatus.STOPPED:\nlogger.info(f'Endpoint {name} is not running.')\nreturn 0\nendpoint_dir = os.path.join(proxystore_dir, name)\ncfg = read_config(endpoint_dir)\nhostname = utils.hostname()\npid_file = get_pid_filepath(endpoint_dir)\nif (\nstatus == EndpointStatus.HANGING\nand cfg.host is not None\nand hostname != cfg.host\n):\nlogger.error(\n'A PID file exists for the endpoint, but the config indicates the '\nf'endpoint is running on a host named {cfg.host}. Try stopping '\nf'the endpoint on {cfg.host}. Otherwise, delete the PID file at '\nf'{pid_file} and try again.',\n)\nreturn 1\nelif status == EndpointStatus.HANGING:\nlogger.debug(f'Removing invalid PID file ({pid_file}).')\nos.remove(pid_file)\nlogger.info(f'Endpoint {name} is not running.')\nreturn 0\nassert status == EndpointStatus.RUNNING\nwith open(pid_file) as f:\npid = int(f.read().strip())\nlogger.debug(f'Terminating endpoint process (PID: {pid}).')\n# Source: https://github.com/funcx-faas/funcX/blob/facf37348f9a9eb4e1a0572793d7b6819be5754d/funcx_endpoint/funcx_endpoint/endpoint/endpoint.py#L360  # noqa: E501\nparent = psutil.Process(pid)\nprocesses = parent.children(recursive=True)\nprocesses.append(parent)\nfor p in processes:\np.send_signal(signal.SIGTERM)\nterminated, alive = psutil.wait_procs(processes, timeout=1)\nfor p in alive:  # pragma: no cover\ntry:\np.send_signal(signal.SIGKILL)\nexcept psutil.NoSuchProcess:\npass\nif os.path.isfile(pid_file):  # pragma: no branch\nlogger.debug(f'Cleaning up PID file ({pid_file}).')\nos.remove(pid_file)\nlogger.info(f'Endpoint {name} has been stopped.')\nreturn 0\n</code></pre>"},{"location":"api/endpoint/config/","title":"proxystore.endpoint.config","text":"<code>proxystore/endpoint/config.py</code> <p>Endpoint configuration.</p>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.EndpointConfig","title":"EndpointConfig  <code>dataclass</code>","text":"<p>Endpoint configuration.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Endpoint name.</p> </li> <li> uuid             (<code>uuid.UUID</code>)         \u2013 <p>Endpoint UUID.</p> </li> <li> host             (<code>str | None</code>)         \u2013 <p>Host endpoint is running on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port endpoint is running on.</p> </li> <li> relay_server             (<code>str | None</code>)         \u2013 <p>Optional relay server the endpoint should register with.</p> </li> <li> max_memory             (<code>int | None</code>)         \u2013 <p>Optional memory limit before demoting objects to disk.</p> </li> <li> max_object_size             (<code>int | None</code>)         \u2013 <p>Optional maximum object size.</p> </li> <li> dump_dir             (<code>str | None</code>)         \u2013 <p>Optional directory to put objects in when <code>max_memory</code> is exceeded.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>Number of peer channels to multiplex communications over.</p> </li> <li> verify_certificates             (<code>int</code>)         \u2013 <p>Validate the SSL certificates of the <code>relay</code> server.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the name does not contain only alphanumeric, dash, or underscore characters, if the UUID cannot be parsed, or if the port is not in the range [1, 65535].</p> </li> </ul>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.get_configs","title":"get_configs()","text":"<pre><code>get_configs(proxystore_dir: str) -&gt; list[EndpointConfig]\n</code></pre> <p>Get all valid endpoint configurations in parent directory.</p> <p>Parameters:</p> <ul> <li> proxystore_dir             (<code>str</code>)         \u2013 <p>Parent directory containing possible endpoint configurations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[EndpointConfig]</code>         \u2013 <p>List of found configs.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def get_configs(proxystore_dir: str) -&gt; list[EndpointConfig]:\n\"\"\"Get all valid endpoint configurations in parent directory.\n    Args:\n        proxystore_dir: Parent directory containing possible endpoint\n            configurations.\n    Returns:\n        List of found configs.\n    \"\"\"\nendpoints: list[EndpointConfig] = []\nif not os.path.isdir(proxystore_dir):\nreturn endpoints\nfor dirpath, _, _ in os.walk(proxystore_dir):\nif os.path.samefile(proxystore_dir, dirpath):\ncontinue\ntry:\ncfg = read_config(dirpath)\nexcept FileNotFoundError:\ncontinue\nexcept ValueError:\ncontinue\nelse:\nendpoints.append(cfg)\nreturn endpoints\n</code></pre>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.get_log_filepath","title":"get_log_filepath()","text":"<pre><code>get_log_filepath(endpoint_dir: str) -&gt; str\n</code></pre> <p>Return path to log file for endpoint.</p> <p>Parameters:</p> <ul> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory for the endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Path to log file.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def get_log_filepath(endpoint_dir: str) -&gt; str:\n\"\"\"Return path to log file for endpoint.\n    Args:\n        endpoint_dir: Directory for the endpoint.\n    Returns:\n        Path to log file.\n    \"\"\"\nreturn os.path.join(endpoint_dir, _ENDPOINT_LOG_FILE)\n</code></pre>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.get_pid_filepath","title":"get_pid_filepath()","text":"<pre><code>get_pid_filepath(endpoint_dir: str) -&gt; str\n</code></pre> <p>Return path to PID file for endpoint.</p> <p>Parameters:</p> <ul> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory for the endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Path to PID file.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def get_pid_filepath(endpoint_dir: str) -&gt; str:\n\"\"\"Return path to PID file for endpoint.\n    Args:\n        endpoint_dir: Directory for the endpoint.\n    Returns:\n        Path to PID file.\n    \"\"\"\nreturn os.path.join(endpoint_dir, _ENDPOINT_PID_FILE)\n</code></pre>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.read_config","title":"read_config()","text":"<pre><code>read_config(endpoint_dir: str) -&gt; EndpointConfig\n</code></pre> <p>Read endpoint config file.</p> <p>Parameters:</p> <ul> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory containing endpoint configuration file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EndpointConfig</code>         \u2013 <p>Config found in <code>endpoint_dir</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>           \u2013         <p>If a config files does not exist in the directory.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If config contains an invalid value or cannot be parsed.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def read_config(endpoint_dir: str) -&gt; EndpointConfig:\n\"\"\"Read endpoint config file.\n    Args:\n        endpoint_dir: Directory containing endpoint configuration file.\n    Returns:\n        Config found in `endpoint_dir`.\n    Raises:\n        FileNotFoundError: If a config files does not exist in the directory.\n        ValueError: If config contains an invalid value or cannot be parsed.\n    \"\"\"\npath = os.path.join(endpoint_dir, _ENDPOINT_CONFIG_FILE)\nif os.path.exists(path):\nwith open(path) as f:\ntry:\ncfg_json = json.load(f)\nexcept json.decoder.JSONDecodeError as e:\nraise ValueError(\nf'Unable to parse ({path}): {str(e)}.',\n) from None\ntry:\ncfg = EndpointConfig(**cfg_json)\nexcept TypeError as e:\nraise ValueError(\nf'Keys in config ({path}) do not match expected: {str(e)}.',\n) from None\nreturn cfg\nelse:\nraise FileNotFoundError(\nf'Endpoint directory {endpoint_dir} does not contain a valid '\n'configuration.',\n)\n</code></pre>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.validate_name","title":"validate_name()","text":"<pre><code>validate_name(name: str) -&gt; bool\n</code></pre> <p>Validate name only contains alphanumeric or dash/underscore chars.</p> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def validate_name(name: str) -&gt; bool:\n\"\"\"Validate name only contains alphanumeric or dash/underscore chars.\"\"\"\nreturn len(re.findall(r'[^A-Za-z0-9_\\-]', name)) == 0 and len(name) &gt; 0\n</code></pre>"},{"location":"api/endpoint/config/#proxystore.endpoint.config.write_config","title":"write_config()","text":"<pre><code>write_config(\ncfg: EndpointConfig, endpoint_dir: str\n) -&gt; None\n</code></pre> <p>Write config to endpoint directory.</p> <p>Parameters:</p> <ul> <li> cfg             (<code>EndpointConfig</code>)         \u2013 <p>Configuration to write.</p> </li> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory to write config to.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def write_config(cfg: EndpointConfig, endpoint_dir: str) -&gt; None:\n\"\"\"Write config to endpoint directory.\n    Args:\n        cfg: Configuration to write.\n        endpoint_dir: Directory to write config to.\n    \"\"\"\nos.makedirs(endpoint_dir, exist_ok=True)\npath = os.path.join(endpoint_dir, _ENDPOINT_CONFIG_FILE)\nwith open(path, 'w') as f:\ndata = dataclasses.asdict(cfg)\ndata['uuid'] = str(data['uuid'])\njson.dump(data, f, indent=4)\n# Add newline so cat on the file looks better\nf.write('\\n')\n</code></pre>"},{"location":"api/endpoint/constants/","title":"proxystore.endpoint.constants","text":"<code>proxystore/endpoint/constants.py</code> <p>Endpoint constants.</p>"},{"location":"api/endpoint/constants/#proxystore.endpoint.constants.MAX_CHUNK_LENGTH","title":"MAX_CHUNK_LENGTH  <code>module-attribute</code>","text":"<pre><code>MAX_CHUNK_LENGTH = 16 * 1000 * 1000\n</code></pre> <p>Maximum chunk length (bytes) for GET/SET requests to/from the endpoint.</p>"},{"location":"api/endpoint/constants/#proxystore.endpoint.constants.MAX_OBJECT_SIZE_DEFAULT","title":"MAX_OBJECT_SIZE_DEFAULT  <code>module-attribute</code>","text":"<pre><code>MAX_OBJECT_SIZE_DEFAULT = int(1000000000.0)\n</code></pre> <p>Default maximum endpoint object size in bytes.</p>"},{"location":"api/endpoint/endpoint/","title":"proxystore.endpoint.endpoint","text":"<code>proxystore/endpoint/endpoint.py</code> <p>Endpoint implementation.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.EndpointMode","title":"EndpointMode","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Endpoint mode.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.EndpointMode.PEERING","title":"PEERING  <code>class-attribute</code>","text":"<pre><code>PEERING = 1\n</code></pre> <p>Endpoint will establish peer connections with other endpoints.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.EndpointMode.SOLO","title":"SOLO  <code>class-attribute</code>","text":"<pre><code>SOLO = 2\n</code></pre> <p>Endpoint is operating in isolation and will ignore peer requests.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint","title":"Endpoint","text":"<pre><code>Endpoint(\nname: str,\nuuid: UUID,\nrelay_server: str | None = None,\npeer_timeout: int = 30,\nmax_memory: int | None = None,\nmax_object_size: int | None = MAX_OBJECT_SIZE_DEFAULT,\ndump_dir: str | None = None,\npeer_channels: int = 1,\nverify_certificate: bool = True,\n) -&gt; None\n</code></pre> <p>ProxyStore Endpoint.</p> <p>An endpoint is an object store with <code>get</code>/<code>set</code> functionality.</p> <p>By default, an endpoint operates in <code>EndpointMode.SOLO</code> mode where the endpoint acts just as an isolated object store. Endpoints can also be configured in <code>EndpointMode.PEERING</code> mode by initializing the endpoint with a relay server address. The relay server is used to establish peer-to-peer connections with other endpoints after which endpoints can forward operations between each other. Peering is available even when endpoints are being separate NATs. See the proxystore.p2p module to learn more about peering.</p> Warning <p>Requests made to remote endpoints will only invoke the request on the remote and return the result. I.e., invoking GET on a remote will return the value but will not store it on the local endpoint.</p> Example <p>Solo Mode Usage</p> <pre><code>async with Endpoint('ep1', uuid.uuid4()) as endpoint:\nserialized_data = b'data string'\nendpoint.set('key', serialized_data)\nassert endpoint.get('key') == serialized_data\nendpoint.evict('key')\nassert not endpoint.exists('key')\n</code></pre> Example <p>Peering Mode Usage</p> <pre><code>ep1 = await Endpoint('ep1', uuid.uuid4(), relay_server)\nep2 = await Endpoint('ep1', uuid.uuid4(), relay_server)\nserialized_data = b'data string'\nep1.set('key', serialized_data)\nassert ep2.get('key', endpoint=ep1.uuid) == serialized_data\nassert ep1.exists('key')\nassert not ep1.exists('key', endpoint=ep2.uuid)\nep1.close()\nep2.close()\n</code></pre> Note <p>Endpoints can be configured and started via the <code>proxystore-endpoint</code> command-line interface.</p> Note <p>If the endpoint is being used in peering mode, the endpoint should be used as a context manager or initialized with await. This will ensure <code>Endpoint.async_init()</code> is executed which connects to the relay server and established a listener for incoming messages.</p> <pre><code>endpoint = await Endpoint(...)\nendpoint.close()\n</code></pre> <pre><code>async with Endpoint(...) as endpoint:\n...\n</code></pre> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Readable name of endpoint.</p> </li> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of the endpoint.</p> </li> <li> relay_server             (<code>str | None</code>)         \u2013 <p>Address of relay server used for peer-to-peer connections between endpoints. If None, endpoint will not be able to communicate with other endpoints.</p> </li> <li> peer_timeout             (<code>int</code>)         \u2013 <p>Timeout for establishing p2p connection with another endpoint.</p> </li> <li> max_memory             (<code>int | None</code>)         \u2013 <p>Optional max memory in bytes to use for storing objects. If exceeded, LRU objects will be dumped to <code>dump_dir</code>.</p> </li> <li> max_object_size             (<code>int | None</code>)         \u2013 <p>Optional max size in bytes for any single object stored by the endpoint. If exceeded, an error is raised.</p> </li> <li> dump_dir             (<code>str | None</code>)         \u2013 <p>Optional directory to dump objects to if the memory limit is exceeded.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>Number of datachannels per peer connection to another endpoint to communicate over.</p> </li> <li> verify_certificate             (<code>bool</code>)         \u2013 <p>Verify the relay server's SSL certificate. This should almost never be disabled except for testing with self-signed certificates.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>def __init__(\nself,\nname: str,\nuuid: UUID,\nrelay_server: str | None = None,\npeer_timeout: int = 30,\nmax_memory: int | None = None,\nmax_object_size: int | None = MAX_OBJECT_SIZE_DEFAULT,\ndump_dir: str | None = None,\npeer_channels: int = 1,\nverify_certificate: bool = True,\n) -&gt; None:\n# TODO(gpauloski): need to consider semantics of operations\n#   - can all ops be triggered on remote?\n#   - or just get? do we move data permanently on get? etc...\nself._name = name\nself._uuid = uuid\nself._relay_server = relay_server\nself._peer_timeout = peer_timeout\nself._peer_channels = peer_channels\nself._verify_certificate = verify_certificate\nself._mode = (\nEndpointMode.SOLO if relay_server is None else EndpointMode.PEERING\n)\nself._peer_manager: PeerManager | None = None\nself._data = EndpointStorage(\nmax_size=max_memory,\nmax_object_size=max_object_size,\ndump_dir=dump_dir,\n)\nself._pending_requests: dict[\nstr,\nasyncio.Future[EndpointRequest],\n] = {}\nself._async_init_done = False\nself._peer_handler_task: asyncio.Task[None] | None = None\nlogger.info(\nf'{self._log_prefix}: initialized endpoint operating '\nf'in {self._mode.name} mode',\n)\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: UUID\n</code></pre> <p>UUID of this endpoint.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of this endpoint.</p>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.async_init","title":"async_init()  <code>async</code>","text":"<pre><code>async_init() -&gt; None\n</code></pre> <p>Initialize connections and tasks necessary for peering.</p> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def async_init(self) -&gt; None:\n\"\"\"Initialize connections and tasks necessary for peering.\"\"\"\nif self._relay_server is not None and not self._async_init_done:\nself._peer_manager = await PeerManager(\nuuid=self.uuid,\nrelay_server=self._relay_server,\nname=self.name,\ntimeout=self._peer_timeout,\npeer_channels=self._peer_channels,\nverify_certificate=self._verify_certificate,\n)\nself._peer_handler_task = spawn_guarded_background_task(\nself._handle_peer_requests,\n)\nlogger.info(f'{self._log_prefix}: initialized peer manager')\nself._async_init_done = True\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.evict","title":"evict()  <code>async</code>","text":"<pre><code>evict(key: str, endpoint: UUID | None = None) -&gt; None\n</code></pre> <p>Evict key from endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to evict.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def evict(self, key: str, endpoint: UUID | None = None) -&gt; None:\n\"\"\"Evict key from endpoint.\n    Args:\n        key: Key to evict.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Raises:\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: EVICT key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='evict',\nuuid=str(uuid4()),\nkey=key,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nawait request_future\nelse:\nif key in self._data:\ndel self._data[key]\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.exists","title":"exists()  <code>async</code>","text":"<pre><code>exists(key: str, endpoint: UUID | None = None) -&gt; bool\n</code></pre> <p>Check if key exists on endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to check.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the key exists.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def exists(self, key: str, endpoint: UUID | None = None) -&gt; bool:\n\"\"\"Check if key exists on endpoint.\n    Args:\n        key: Key to check.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Returns:\n        If the key exists.\n    Raises:\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: EXISTS key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='exists',\nuuid=str(uuid4()),\nkey=key,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nresponse = await request_future\nassert isinstance(response.exists, bool)\nreturn response.exists\nelse:\nreturn key in self._data\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.get","title":"get()  <code>async</code>","text":"<pre><code>get(key: str, endpoint: UUID | None = None) -&gt; bytes | None\n</code></pre> <p>Get value associated with key on endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to get value for.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Value associated with key.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def get(\nself,\nkey: str,\nendpoint: UUID | None = None,\n) -&gt; bytes | None:\n\"\"\"Get value associated with key on endpoint.\n    Args:\n        key: Key to get value for.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Returns:\n        Value associated with key.\n    Raises:\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: GET key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='get',\nuuid=str(uuid4()),\nkey=key,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nresponse = await request_future\nreturn response.data\nelse:\nif key in self._data:\nreturn self._data[key]\nelse:\nreturn None\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.set","title":"set()  <code>async</code>","text":"<pre><code>set(\nkey: str, data: bytes, endpoint: UUID | None = None\n) -&gt; None\n</code></pre> <p>Set key with data on endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to associate with value.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Value to associate with key.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ObjectSizeExceededError</code>           \u2013         <p>If the max object size is configured and the data exceeds that size.</p> </li> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def set(\nself,\nkey: str,\ndata: bytes,\nendpoint: UUID | None = None,\n) -&gt; None:\n\"\"\"Set key with data on endpoint.\n    Args:\n        key: Key to associate with value.\n        data: Value to associate with key.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Raises:\n        ObjectSizeExceededError: If the max object size is configured and\n            the data exceeds that size.\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: SET key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='set',\nuuid=str(uuid4()),\nkey=key,\ndata=data,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nawait request_future\nelse:\nself._data[key] = data\n</code></pre>"},{"location":"api/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.close","title":"close()  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the endpoint and any open connections safely.</p> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the endpoint and any open connections safely.\"\"\"\nif self._peer_handler_task is not None:\nself._peer_handler_task.cancel()\ntry:\nawait self._peer_handler_task\nexcept asyncio.CancelledError:\npass\nif self._peer_manager is not None:\nawait self._peer_manager.close()\nself._data.cleanup()\nlogger.info(f'{self._log_prefix}: endpoint closed')\n</code></pre>"},{"location":"api/endpoint/exceptions/","title":"proxystore.endpoint.exceptions","text":"<code>proxystore/endpoint/exceptions.py</code> <p>Endpoint exceptions.</p>"},{"location":"api/endpoint/exceptions/#proxystore.endpoint.exceptions.FileDumpNotAvailableError","title":"FileDumpNotAvailableError","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when dumping objects to file is not available.</p>"},{"location":"api/endpoint/exceptions/#proxystore.endpoint.exceptions.ObjectSizeExceededError","title":"ObjectSizeExceededError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when an object exceeds the max allowable size.</p>"},{"location":"api/endpoint/exceptions/#proxystore.endpoint.exceptions.PeeringNotAvailableError","title":"PeeringNotAvailableError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception when a peer request is made but peering is not available.</p>"},{"location":"api/endpoint/exceptions/#proxystore.endpoint.exceptions.PeerRequestError","title":"PeerRequestError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when a request to a peer fails.</p>"},{"location":"api/endpoint/messages/","title":"proxystore.endpoint.messages","text":"<code>proxystore/endpoint/messages.py</code> <p>Endpoint to endpoint messages.</p>"},{"location":"api/endpoint/messages/#proxystore.endpoint.messages.EndpointRequest","title":"EndpointRequest  <code>dataclass</code>","text":"<p>Message type for requests between endpoints.</p> <p>Attributes:</p> <ul> <li> kind             (<code>Literal[request, response]</code>)         \u2013 <p>One of <code>'request'</code> or <code>'response'</code>.</p> </li> <li> op             (<code>Literal[evict, exists, get, set]</code>)         \u2013 <p>One of <code>'evict'</code>, <code>'exists'</code>, <code>'get'</code>, or <code>'set'</code>.</p> </li> <li> uuid             (<code>str</code>)         \u2013 <p>UUID of sender.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key to operate on.</p> </li> <li> data             (<code>bytes | None</code>)         \u2013 <p>Optional data to operate on.</p> </li> <li> exists             (<code>bool | None</code>)         \u2013 <p>Result of <code>exists</code> operation.</p> </li> <li> error             (<code>Exception | None</code>)         \u2013 <p>Error raised by operation.</p> </li> </ul>"},{"location":"api/endpoint/serve/","title":"proxystore.endpoint.serve","text":"<code>proxystore/endpoint/serve.py</code> <p>Endpoint serving.</p>"},{"location":"api/endpoint/serve/#proxystore.endpoint.serve.create_app","title":"create_app()","text":"<pre><code>create_app(\nendpoint: Endpoint,\nmax_content_length: int | None = None,\nbody_timeout: int = 300,\n) -&gt; quart.Quart\n</code></pre> <p>Create quart app for endpoint and registers routes.</p> <p>Parameters:</p> <ul> <li> endpoint             (<code>Endpoint</code>)         \u2013 <p>Initialized endpoint to forward quart routes to.</p> </li> <li> max_content_length             (<code>int | None</code>)         \u2013 <p>Max request body size in bytes.</p> </li> <li> body_timeout             (<code>int</code>)         \u2013 <p>Number of seconds to wait for the body to be completely received.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>quart.Quart</code>         \u2013 <p>Quart app.</p> </li> </ul> Source code in <code>proxystore/endpoint/serve.py</code> <pre><code>def create_app(\nendpoint: Endpoint,\nmax_content_length: int | None = None,\nbody_timeout: int = 300,\n) -&gt; quart.Quart:\n\"\"\"Create quart app for endpoint and registers routes.\n    Args:\n        endpoint: Initialized endpoint to forward quart routes to.\n        max_content_length: Max request body size in bytes.\n        body_timeout: Number of seconds to wait for the body to be\n            completely received.\n    Returns:\n        Quart app.\n    \"\"\"\napp = quart.Quart(__name__)\napp.config['endpoint'] = endpoint\napp.register_blueprint(routes_blueprint, url_prefix='')\nlogger.info(\n'Quart routes registered to endpoint '\nf'{endpoint.uuid} ({endpoint.name})',\n)\napp.config['MAX_CONTENT_LENGTH'] = max_content_length\napp.config['BODY_TIMEOUT'] = body_timeout\nreturn app\n</code></pre>"},{"location":"api/endpoint/serve/#proxystore.endpoint.serve.serve","title":"serve()","text":"<pre><code>serve(\nconfig: EndpointConfig,\n*,\nlog_level: int | str = logging.INFO,\nlog_file: str | None = None,\nuse_uvloop: bool = True\n) -&gt; None\n</code></pre> <p>Initialize endpoint and serve Quart app.</p> Warning <p>This function does not return until the Quart app is terminated.</p> <p>Parameters:</p> <ul> <li> config             (<code>EndpointConfig</code>)         \u2013 <p>Configuration object.</p> </li> <li> log_level             (<code>int | str</code>)         \u2013 <p>Logging level of endpoint.</p> </li> <li> log_file             (<code>str | None</code>)         \u2013 <p>Optional file path to append log to.</p> </li> <li> use_uvloop             (<code>bool</code>)         \u2013 <p>Install uvloop as the default event loop implementation.</p> </li> </ul> Source code in <code>proxystore/endpoint/serve.py</code> <pre><code>def serve(\nconfig: EndpointConfig,\n*,\nlog_level: int | str = logging.INFO,\nlog_file: str | None = None,\nuse_uvloop: bool = True,\n) -&gt; None:\n\"\"\"Initialize endpoint and serve Quart app.\n    Warning:\n        This function does not return until the Quart app is terminated.\n    Args:\n        config: Configuration object.\n        log_level: Logging level of endpoint.\n        log_file: Optional file path to append log to.\n        use_uvloop: Install uvloop as the default event loop implementation.\n    \"\"\"\nif config.host is None:\nraise ValueError('EndpointConfig has NoneType as host.')\nif log_file is not None:\nparent_dir = os.path.dirname(log_file)\nif not os.path.isdir(parent_dir):\nos.makedirs(parent_dir, exist_ok=True)\nlogging.getLogger().handlers.append(logging.FileHandler(log_file))\nfor handler in logging.getLogger().handlers:\nhandler.setFormatter(\nlogging.Formatter(\n'[%(asctime)s.%(msecs)03d] %(levelname)-5s (%(name)s) :: '\n'%(message)s',\ndatefmt='%Y-%m-%d %H:%M:%S',\n),\n)\nlogging.getLogger().setLevel(log_level)\nkwargs = dataclasses.asdict(config)\n# These are the only two EndpointConfig attributes not passed to the\n# Endpoint constructor\nkwargs.pop('host', None)\nkwargs.pop('port', None)\nendpoint = Endpoint(**kwargs)\napp = create_app(endpoint)\nserve_config = hypercorn.config.Config()\nserve_config.bind = [f'{config.host}:{config.port}']\nserve_config.accesslog = logging.getLogger('hypercorn.access')\nserve_config.errorlog = logging.getLogger('hypercorn.error')\nif use_uvloop:  # pragma: no cover\nlogger.info('Installing uvloop as default event loop')\nuvloop.install()\nlogger.info(\nf'Serving endpoint {endpoint.uuid} ({endpoint.name}) on '\nf'{config.host}:{config.port}',\n)\nlogger.info(f'Config: {config}')\nasyncio.run(hypercorn.asyncio.serve(app, serve_config))\n</code></pre>"},{"location":"api/endpoint/storage/","title":"proxystore.endpoint.storage","text":"<code>proxystore/endpoint/storage.py</code> <p>Storage interface for blobs.</p>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.BlobLocation","title":"BlobLocation","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Location of Blob.</p>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.BlobLocation.MEMORY","title":"MEMORY  <code>class-attribute</code>","text":"<pre><code>MEMORY = 1\n</code></pre> <p>Blob is loaded in memory.</p>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.BlobLocation.FILE","title":"FILE  <code>class-attribute</code>","text":"<pre><code>FILE = 2\n</code></pre> <p>Blob is stored on disk.</p>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Blob","title":"Blob","text":"<pre><code>Blob(\nkey: str, value: bytes, filepath: str | None = None\n) -&gt; None\n</code></pre> <p>Representation of entry in <code>EndpointStorage</code>.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with the blob.</p> </li> <li> value             (<code>bytes</code>)         \u2013 <p>The blob being stored.</p> </li> <li> filepath             (<code>str | None</code>)         \u2013 <p>Optional filepath for dumping the blob.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __init__(\nself,\nkey: str,\nvalue: bytes,\nfilepath: str | None = None,\n) -&gt; None:\nself.key = key\nself.size = len(value)\nself._value: bytes | None = value\nself.filepath = filepath\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Blob.location","title":"location  <code>property</code>","text":"<pre><code>location: BlobLocation\n</code></pre> <p>Location of the blob.</p>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Blob.value","title":"value  <code>property</code>","text":"<pre><code>value: bytes\n</code></pre> <p>Blob bytes.</p>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Blob.delete_file","title":"delete_file()","text":"<pre><code>delete_file() -&gt; None\n</code></pre> <p>Delete the file dump of the blob if it exists.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def delete_file(self) -&gt; None:\n\"\"\"Delete the file dump of the blob if it exists.\"\"\"\nif self.filepath is not None and os.path.isfile(self.filepath):\nos.remove(self.filepath)\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Blob.dump","title":"dump()","text":"<pre><code>dump() -&gt; None\n</code></pre> <p>Dump the blob to disk.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def dump(self) -&gt; None:\n\"\"\"Dump the blob to disk.\"\"\"\nif self.filepath is None:\nraise FileDumpNotAvailableError(\n'The blob was not initialized with a filepath '\n'to dump data to.',\n)\nassert self._value is not None\nwith open(self.filepath, 'wb') as f:\nf.write(self._value)\nself._value = None\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.Blob.load","title":"load()","text":"<pre><code>load() -&gt; None\n</code></pre> <p>Load the blob from disk.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def load(self) -&gt; None:\n\"\"\"Load the blob from disk.\"\"\"\nif self._value is not None:\nreturn\nassert self.filepath is not None\nwith open(self.filepath, 'rb') as f:\nself._value = f.read()\nself.delete_file()\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage","title":"EndpointStorage","text":"<pre><code>EndpointStorage(\nmax_size: int | None = None,\nmax_object_size: int | None = None,\ndump_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>         Bases: <code>MutableMapping[str, bytes]</code></p> <p>Endpoint in-memory blob storage with filesystem fallback.</p> <p>Provides a dict-like storage of key-bytes pairs. Optionally, a maximum in-memory size for the data structure can be specified and least-recently used key-bytes pairs will be dumped to a file in a specified directory.</p> <p>Parameters:</p> <ul> <li> max_size             (<code>int | None</code>)         \u2013 <p>Optional maximum size in bytes for in-memory storage of blobs. If the memory limit is exceeded, least recently used blobs will be dumped to disk (if configured).</p> </li> <li> max_object_size             (<code>int | None</code>)         \u2013 <p>Optional maximum size in bytes for any single blob.</p> </li> <li> dump_dir             (<code>str | None</code>)         \u2013 <p>Optional directory to dump blobs to when <code>max_object_size</code> is reached.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If only one of <code>max_size</code> or <code>dump_dir</code> is set.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __init__(\nself,\nmax_size: int | None = None,\nmax_object_size: int | None = None,\ndump_dir: str | None = None,\n) -&gt; None:\nif (max_size is not None or dump_dir is not None) and (\nmax_size is None or dump_dir is None\n):\nraise ValueError(\n'Either both of max_size and dump_dir should be specified '\n'or neither.',\n)\nself.max_size = max_size\nself.max_object_size = max_object_size\nself.dump_dir = dump_dir\nif self.dump_dir is not None:\nos.makedirs(self.dump_dir, exist_ok=True)\nself._in_memory_size = 0\nself._blobs: dict[str, Blob] = {}\n# Only in-memory objects should be in this.\n# Recently used keys are appended to right side, LRU keys are\n# popped from left side.\nself._lru_queue: Deque[str] = collections.deque()\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__getitem__","title":"__getitem__()","text":"<pre><code>__getitem__(key: str) -&gt; bytes\n</code></pre> <p>Get bytes associated with key.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __getitem__(self, key: str) -&gt; bytes:\n\"\"\"Get bytes associated with key.\"\"\"\nif key not in self._blobs:\nraise KeyError(key)\nblob = self._blobs[key]\nif blob.location == BlobLocation.MEMORY:\n# Move to right side because recently used\nself._lru_queue.remove(key)\nself._lru_queue.append(key)\nreturn blob.value\nself._make_space(blob.size)\nself._in_memory_size += blob.size\nblob.load()\n# Add to queue because it is back in memory\nself._lru_queue.append(key)\nreturn blob.value\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__setitem__","title":"__setitem__()","text":"<pre><code>__setitem__(key: str, value: bytes) -&gt; None\n</code></pre> <p>Set key to value.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>value</code> is larger than <code>max_size</code>.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __setitem__(self, key: str, value: bytes) -&gt; None:\n\"\"\"Set key to value.\n    Raises:\n        ValueError: If `value` is larger than `max_size`.\n    \"\"\"\nif (\nself.max_object_size is not None\nand len(value) &gt; self.max_object_size\n):\nraise ObjectSizeExceededError(\nf'Bytes value has size {bytes_to_readable(len(value))} which '\nf'exceeds the {bytes_to_readable(self.max_object_size)} '\n'object limit.',\n)\nif self.max_size is not None and len(value) &gt; self.max_size:\nraise ObjectSizeExceededError(\nf'Bytes value has size {bytes_to_readable(len(value))} which '\nf'exceeds the {bytes_to_readable(self.max_size)} '\n'memory limit.',\n)\nfilepath = (\nNone if self.dump_dir is None else os.path.join(self.dump_dir, key)\n)\nblob = Blob(key, value, filepath)\nself._make_space(blob.size)\nself._blobs[key] = blob\nself._in_memory_size += blob.size\nself._lru_queue.append(key)\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__delitem__","title":"__delitem__()","text":"<pre><code>__delitem__(key: str) -&gt; None\n</code></pre> <p>Remove a key from the storage.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __delitem__(self, key: str) -&gt; None:\n\"\"\"Remove a key from the storage.\"\"\"\nif key not in self._blobs:\nraise KeyError(key)\nblob = self._blobs.pop(key)\nassert blob is not None\nif blob.location == BlobLocation.MEMORY:\nself._in_memory_size -= blob.size\nself._lru_queue.remove(key)\nblob.delete_file()\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__iter__","title":"__iter__()","text":"<pre><code>__iter__() -&gt; Iterator[str]\n</code></pre> <p>Iterate over keys in the storage.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str]:\n\"\"\"Iterate over keys in the storage.\"\"\"\nyield from self._blobs\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__len__","title":"__len__()","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return number of keys in the storage.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Return number of keys in the storage.\"\"\"\nreturn len(self._blobs)\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__contains__","title":"__contains__()","text":"<pre><code>__contains__(key: object) -&gt; bool\n</code></pre> <p>Check if storage contains a key.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __contains__(self, key: object) -&gt; bool:\n\"\"\"Check if storage contains a key.\"\"\"\nreturn key in self._blobs\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.clear","title":"clear()","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear all keys in the storage.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def clear(self) -&gt; None:\n\"\"\"Clear all keys in the storage.\"\"\"\nkeys = list(self._blobs.keys())\nfor key in keys:\ndel self._blobs[key]\nself._lru_queue.clear()\n</code></pre>"},{"location":"api/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.cleanup","title":"cleanup()","text":"<pre><code>cleanup() -&gt; None\n</code></pre> <p>Clear all keys in the storage and remove the data dump.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def cleanup(self) -&gt; None:\n\"\"\"Clear all keys in the storage and remove the data dump.\"\"\"\nif self.dump_dir is not None:\nshutil.rmtree(self.dump_dir)\nself._blobs.clear()\n</code></pre>"},{"location":"api/p2p/","title":"proxystore.p2p","text":"<code>proxystore/p2p/__init__.py</code> <p>Peer-to-peer communication and relaying.</p> <p>This module provides two main functionalities: the <code>PeerManager</code> and <code>RelayServer</code>.</p> <ul> <li>The <code>PeerManager</code> enables   easy communication between arbitrary peers even if peers are behind separate   NATs. Peer connections are established using   aiortc, an asyncio WebRTC   implementation.</li> <li>The <code>RelayServer</code> is a   commonly accessible server by peers that is used to facilitate WebRTC peer   connections.</li> </ul>"},{"location":"api/p2p/chunks/","title":"proxystore.p2p.chunks","text":"<code>proxystore/p2p/chunks.py</code> <p>Message chunking utilities.</p>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.ChunkDType","title":"ChunkDType","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Data type contained in a Chunk.</p>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.ChunkDType.BYTES","title":"BYTES  <code>class-attribute</code>","text":"<pre><code>BYTES = 1\n</code></pre> <p>Data is bytes.</p>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.ChunkDType.STRING","title":"STRING  <code>class-attribute</code>","text":"<pre><code>STRING = 2\n</code></pre> <p>Data is a string.</p>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.Chunk","title":"Chunk","text":"<pre><code>Chunk(\nstream_id: int,\nseq_id: int,\nseq_len: int,\ndata: bytes | str,\ndtype: ChunkDType | None = None,\n) -&gt; None\n</code></pre> <p>Representation of a chunk of a message.</p> <p>Parameters:</p> <ul> <li> stream_id             (<code>int</code>)         \u2013 <p>Unique ID for the stream of chunks.</p> </li> <li> seq_id             (<code>int</code>)         \u2013 <p>Sequence number for this chunk in the stream.</p> </li> <li> seq_len             (<code>int</code>)         \u2013 <p>Length of the stream.</p> </li> <li> data             (<code>bytes | str</code>)         \u2013 <p>Data for this chunk.</p> </li> <li> dtype             (<code>ChunkDType | None</code>)         \u2013 <p>Optionally specify data type otherwise inferred from data.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>if the sequence ID is not less than the sequence length.</p> </li> </ul> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def __init__(\nself,\nstream_id: int,\nseq_id: int,\nseq_len: int,\ndata: bytes | str,\ndtype: ChunkDType | None = None,\n) -&gt; None:\nif seq_len &lt;= seq_id:\nraise ValueError(\nf'seq_id ({seq_id}) must be less than seq_len ({seq_len}).',\n)\nself.stream_id = stream_id\nself.seq_id = seq_id\nself.seq_len = seq_len\nself.data = data\nif dtype is None:\nself.dtype = (\nChunkDType.BYTES\nif isinstance(data, bytes)\nelse ChunkDType.STRING\n)\nelse:\nself.dtype = dtype\n</code></pre>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.Chunk.__bytes__","title":"__bytes__()","text":"<pre><code>__bytes__() -&gt; bytes\n</code></pre> <p>Pack the chunk into bytes.</p> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def __bytes__(self) -&gt; bytes:\n\"\"\"Pack the chunk into bytes.\"\"\"\nlength = CHUNK_HEADER_LENGTH + len(self.data)\nheader = pack(\nCHUNK_HEADER_FORMAT,\nself.dtype.value,\nlength,\nself.stream_id,\nself.seq_id,\nself.seq_len,\n)\ndata = (\nself.data.encode('utf8')\nif isinstance(self.data, str)\nelse self.data\n)\nchunk = header + data\ndata += b'\\x00' * (len(chunk) % 4)\nreturn chunk\n</code></pre>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.Chunk.from_bytes","title":"from_bytes()  <code>classmethod</code>","text":"<pre><code>from_bytes(chunk: bytes) -&gt; Chunk\n</code></pre> <p>Decode bytes into a Chunk.</p> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>@classmethod\ndef from_bytes(cls, chunk: bytes) -&gt; Chunk:\n\"\"\"Decode bytes into a Chunk.\"\"\"\n(dtype_value, length, stream_id, seq_id, seq_len) = unpack_from(\nCHUNK_HEADER_FORMAT,\nchunk,\n)\ndtype = ChunkDType(dtype_value)\nchunk_data = chunk[CHUNK_HEADER_LENGTH:length]\ndata: bytes | str\nif dtype is ChunkDType.STRING:\ndata = chunk_data.decode('utf8')\nelse:\ndata = chunk_data\nreturn cls(\nstream_id=stream_id,\nseq_id=seq_id,\nseq_len=seq_len,\ndata=data,\ndtype=dtype,\n)\n</code></pre>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.chunkify","title":"chunkify()","text":"<pre><code>chunkify(\ndata: bytes | str, size: int, stream_id: int\n) -&gt; Generator[Chunk, None, None]\n</code></pre> <p>Generate chunks from data.</p> <p>Parameters:</p> <ul> <li> data             (<code>bytes | str</code>)         \u2013 <p>Data to chunk.</p> </li> <li> size             (<code>int</code>)         \u2013 <p>Size of each chunk.</p> </li> <li> stream_id             (<code>int</code>)         \u2013 <p>Unique ID for the stream of chunks.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Generator[Chunk, None, None]</code>         \u2013 <p>Chunks of data.</p> </li> </ul> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def chunkify(\ndata: bytes | str,\nsize: int,\nstream_id: int,\n) -&gt; Generator[Chunk, None, None]:\n\"\"\"Generate chunks from data.\n    Args:\n        data: Data to chunk.\n        size: Size of each chunk.\n        stream_id: Unique ID for the stream of chunks.\n    Yields:\n        Chunks of data.\n    \"\"\"\nseq_len = math.ceil(len(data) / size)\nfor i, x in enumerate(range(0, len(data), size)):\nchunk_data = data[x : min(x + size, len(data))]\nyield Chunk(\nstream_id=stream_id,\nseq_id=i,\nseq_len=seq_len,\ndata=chunk_data,\n)\n</code></pre>"},{"location":"api/p2p/chunks/#proxystore.p2p.chunks.reconstruct","title":"reconstruct()","text":"<pre><code>reconstruct(chunks: list[Chunk]) -&gt; bytes | str\n</code></pre> <p>Reconstructs data from list of chunks.</p> <p>Parameters:</p> <ul> <li> chunks             (<code>list[Chunk]</code>)         \u2013 <p>List of chunks to order and join.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | str</code>         \u2013 <p>Reconstructed bytes or string.</p> </li> </ul> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def reconstruct(chunks: list[Chunk]) -&gt; bytes | str:\n\"\"\"Reconstructs data from list of chunks.\n    Args:\n        chunks: List of chunks to order and join.\n    Returns:\n        Reconstructed bytes or string.\n    \"\"\"\nif len(chunks) == 0:\nraise ValueError('Chunks list cannot be empty.')\nseq_len = chunks[0].seq_len\nif len(chunks) != seq_len:\nraise ValueError(f'Got {len(chunks)} but expected {seq_len}.')\nchunks = sorted(chunks, key=lambda c: c.seq_id)\nif isinstance(chunks[0].data, bytes):\nreturn b''.join(c.data for c in chunks)  # type: ignore\nelif isinstance(chunks[0].data, str):\nreturn ''.join(c.data for c in chunks)  # type: ignore\nelse:\nraise AssertionError('Unreachable.')\n</code></pre>"},{"location":"api/p2p/client/","title":"proxystore.p2p.client","text":"<code>proxystore/p2p/client.py</code> <p>Functions for connecting to a relay server.</p>"},{"location":"api/p2p/client/#proxystore.p2p.client.connect","title":"connect()  <code>async</code>","text":"<pre><code>connect(\naddress: str,\nuuid: UUID | None = None,\nname: str | None = None,\ntimeout: float = 10,\nssl: ssl.SSLContext | None = None,\n) -&gt; tuple[UUID, str, WebSocketClientProtocol]\n</code></pre> <p>Establish client connection to a relay server.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of the relay server. Should start with ws:// or wss://.</p> </li> <li> uuid             (<code>UUID | None</code>)         \u2013 <p>Optional uuid of client to use when registering with relay server.</p> </li> <li> name             (<code>str | None</code>)         \u2013 <p>Readable name of the client to use when registering with the relay server. By default the hostname will be used.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Time to wait in seconds on server connections.</p> </li> <li> ssl             (<code>ssl.SSLContext | None</code>)         \u2013 <p>When None, the correct value to pass to <code>websockets.connect()</code> is inferred from <code>address</code>. If <code>address</code> starts with \"wss://\" the value is True, otherwise is False. Optionally provide a custom SSLContext (useful if the server uses self-signed certificates).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[UUID, str, WebSocketClientProtocol]</code>         \u2013 <p>Tuple of the UUID of this client returned by the relay server,         the name used to register the client, and the websocket connection to         the relay server.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRegistrationError</code>           \u2013         <p>If the connection to the relay server is closed, does not reply to the registration request within the timeout, or replies with an error.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If address does not start with \"ws://\" or \"wss://\".</p> </li> </ul> Source code in <code>proxystore/p2p/client.py</code> <pre><code>async def connect(\naddress: str,\nuuid: UUID | None = None,\nname: str | None = None,\ntimeout: float = 10,\nssl: ssl.SSLContext | None = None,\n) -&gt; tuple[UUID, str, WebSocketClientProtocol]:\n\"\"\"Establish client connection to a relay server.\n    Args:\n        address: Address of the relay server. Should start with ws:// or\n            wss://.\n        uuid: Optional uuid of client to use when registering with relay\n            server.\n        name: Readable name of the client to use when registering with the\n            relay server. By default the hostname will be used.\n        timeout: Time to wait in seconds on server connections.\n        ssl: When None, the correct value to pass to\n            [`websockets.connect()`][websockets.client.connect]\n            is inferred from `address`. If `address` starts with \"wss://\" the\n            value is True, otherwise is False. Optionally provide a custom\n            SSLContext (useful if the server uses self-signed certificates).\n    Returns:\n        Tuple of the UUID of this client returned by the relay server, \\\n        the name used to register the client, and the websocket connection to \\\n        the relay server.\n    Raises:\n        PeerRegistrationError: If the connection to the relay server\n            is closed, does not reply to the registration request within the\n            timeout, or replies with an error.\n        ValueError: If address does not start with \"ws://\" or \"wss://\".\n    \"\"\"\nif name is None:\nname = gethostname()\nif uuid is None:\nuuid = uuid4()\nif not (address.startswith('ws://') or address.startswith('wss://')):\nraise ValueError(\n'Relay server address must start with ws:// or wss://.'\nf'Got {address}.',\n)\nssl_default = True if address.startswith('wss://') else None\nlogger.info(\n'Attempting client connection to relay server at '\nf'{address} with uuid={uuid} and name={name} (ssl: {ssl_default})',\n)\nwebsocket = await websockets.client.connect(\naddress,\nopen_timeout=timeout,\nssl=ssl_default if ssl is None else ssl,\n)\nawait websocket.send(\nmessages.encode(messages.ServerRegistration(uuid=uuid, name=name)),\n)\ntry:\nmessage_str = await asyncio.wait_for(websocket.recv(), timeout)\nif isinstance(message_str, str):\nmessage = messages.decode(message_str)\nelse:\nraise AssertionError('Received non-bytes type on websocket.')\nexcept websockets.exceptions.ConnectionClosed as e:\nraise PeerRegistrationError(\n'Connection to relay server closed before peer '\n'registration completed.',\n) from e\nexcept messages.MessageDecodeError as e:\nraise PeerRegistrationError(\n'Unable to decode response message from relay server.',\n) from e\nexcept asyncio.TimeoutError as e:\nraise PeerRegistrationError(\n'Relay server did not reply to registration within timeout.',\n) from e\nif isinstance(message, messages.ServerResponse):\nif message.success:\nlogger.info(\n'Established client connection to relay server at '\nf'{address} with uuid={uuid} and name={name}',\n)\nreturn uuid, name, websocket\nelse:\nraise PeerRegistrationError(\n'Failed to register as peer with relay server. '\nf'Got exception: {message.message}',\n)\nelse:\nraise PeerRegistrationError(\n'Relay server replied with unknown message type: '\nf'{type(message).__name__}.',\n)\n</code></pre>"},{"location":"api/p2p/connection/","title":"proxystore.p2p.connection","text":"<code>proxystore/p2p/connection.py</code> <p>Representation of peer-to-peer connection.</p>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection","title":"PeerConnection","text":"<pre><code>PeerConnection(\nuuid: UUID,\nname: str,\nwebsocket: WebSocketClientProtocol,\n*,\nchannels: int = 1\n) -&gt; None\n</code></pre> <p>Peer-to-peer connection.</p> <p>Interface for establishing a peer-to-peer connection via WebRTC aiortc and sending/receiving messages between the two peers. The peer-to-peer connection is established using a central and publicly accessible relay server.</p> Warning <p>Applications should prefer using the <code>PeerManager</code> rather than using the <code>PeerConnection</code> class.</p> Example <pre><code>from proxystore.p2p.connection import PeerConnection\nfrom proxystore.p2p.messages import decode\nfrom proxystore.p2p.client import connect\nuuid1, name1, websocket1 = await connect(relay_server_address)\nconnection1 = PeerConnection(uuid1, name1, websocket1)\nuuid2, name2, websocket2 = await connect(relay_server_address)\nconnection2 = PeerConnection(uuid2, name2, websocket2)\nawait connection1.send_offer(uuid2)\noffer = decode(await websocket2.recv())\nawait connection2.handle_server_message(offer)\nanswer = decode(await websocket1.recv())\nawait connection1.handle_server_message(answer)\nawait connection1.ready()\nawait connection2.ready()\nawait connection1.send('hello')\nassert await connection2.recv() == 'hello'\nawait connection2.send('hello hello')\nassert await connection1.recv() == 'hello hello'\nawait websocket1.close()\nawait websocket2.close()\nawait connection1.close()\nawait connection2.close()\n</code></pre> <p>Parameters:</p> <ul> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of this client.</p> </li> <li> name             (<code>str</code>)         \u2013 <p>Readable name of this client for logging.</p> </li> <li> websocket             (<code>WebSocketClientProtocol</code>)         \u2013 <p>Websocket connection to the relay server.</p> </li> <li> channels             (<code>int</code>)         \u2013 <p>Number of datachannels to open with peer.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>def __init__(\nself,\nuuid: UUID,\nname: str,\nwebsocket: WebSocketClientProtocol,\n*,\nchannels: int = 1,\n) -&gt; None:\nself._uuid = uuid\nself._name = name\nself._websocket = websocket\nself._max_channels = channels\nself._handshake_success: asyncio.Future[\nbool\n] = asyncio.get_running_loop().create_future()\nself._pc = RTCPeerConnection()\nself._incoming_queue: asyncio.Queue[bytes | str] = asyncio.Queue()\nself._incoming_chunks: dict[int, list[Chunk]] = defaultdict(list)\n# Max size of unsigned long (4 bytes) is 2^32 - 1\nself._message_counter = AtomicCounter(size=2**32 - 1)\n# Used by offerer to count how many of the channels it opened are ready\nself._ready = 0\nself._channels: dict[str, RTCDataChannel] = {}\nself._channel_buffer_low: dict[str, asyncio.Event] = {}\nself._peer_uuid: UUID | None = None\nself._peer_name: str | None = None\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.state","title":"state  <code>property</code>","text":"<pre><code>state: str\n</code></pre> <p>Get the current connection state.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>One of 'connected', 'connecting', 'closed', 'failed', or 'new'.</p> </li> </ul>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.close","title":"close()  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Terminate the peer connection.</p> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Terminate the peer connection.\"\"\"\nlogger.info(f'{self._log_prefix}: closing connection')\n# Flush send buffers before close\n# https://github.com/aiortc/aiortc/issues/547\nfor channel in self._channels.values():\ntransport = channel._RTCDataChannel__transport\nawait transport._data_channel_flush()\nawait transport._transmit()\nchannel.close()\nawait self._pc.close()\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.on_close_callback","title":"on_close_callback()","text":"<pre><code>on_close_callback(\ncallback: Callable[..., Awaitable[None]],\n*args: Any,\n**kwargs: Any\n) -&gt; None\n</code></pre> <p>Configure a callback for when the connection fails or closes.</p> <p>Parameters:</p> <ul> <li> callback             (<code>Callable[..., Awaitable[None]]</code>)         \u2013 <p>Callable to invoke when the peer connection state changes to closed or failed.</p> </li> <li> args             (<code>Any</code>)         \u2013 <p>Positional arguments to pass to the callback.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Keyword arguments to pass to the callback.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>def on_close_callback(\nself,\ncallback: Callable[..., Awaitable[None]],\n*args: Any,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Configure a callback for when the connection fails or closes.\n    Args:\n        callback: Callable to invoke when the peer connection state\n            changes to closed or failed.\n        args: Positional arguments to pass to the callback.\n        kwargs: Keyword arguments to pass to the callback.\n    \"\"\"\nasync def _on_close() -&gt; None:\nif self.state in ('closed', 'failed'):\nlogger.info(\nf'{self._log_prefix}: connection entered {self.state} '\n'state, invoking callback',\n)\nawait callback(*args, **kwargs)\nself._pc.on('connectionstatechange', _on_close)\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.send","title":"send()  <code>async</code>","text":"<pre><code>send(message: bytes | str, timeout: float = 30) -&gt; None\n</code></pre> <p>Send message to peer.</p> <p>Parameters:</p> <ul> <li> message             (<code>bytes | str</code>)         \u2013 <p>Message to send to peer.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Timeout to wait on peer connection to be ready.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerConnectionTimeoutError</code>           \u2013         <p>If the peer connection is not established within the timeout.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def send(self, message: bytes | str, timeout: float = 30) -&gt; None:\n\"\"\"Send message to peer.\n    Args:\n        message: Message to send to peer.\n        timeout: Timeout to wait on peer connection to be ready.\n    Raises:\n        PeerConnectionTimeoutError: If the peer connection is not\n            established within the timeout.\n    \"\"\"\nawait self.ready(timeout)\nchunk_size = (\nMAX_CHUNK_SIZE_STRING\nif isinstance(message, str)\nelse MAX_CHUNK_SIZE_BYTES\n)\nmessage_id = self._message_counter.increment()\nchannel_names = list(self._channels.keys())\nfor i, chunk in enumerate(chunkify(message, chunk_size, message_id)):\nchannel_name = channel_names[i % len(channel_names)]\nchannel = self._channels[channel_name]\nbuffer_low = self._channel_buffer_low[channel_name]\nif channel.bufferedAmount &gt; channel.bufferedAmountLowThreshold:\nawait buffer_low.wait()\nbuffer_low.clear()\nchannel.send(bytes(chunk))\nlogger.debug(f'{self._log_prefix}: sending message to peer')\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.recv","title":"recv()  <code>async</code>","text":"<pre><code>recv() -&gt; bytes | str\n</code></pre> <p>Receive next message from peer.</p> <p>Returns:</p> <ul> <li> <code>bytes | str</code>         \u2013 <p>Message received from peer.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def recv(self) -&gt; bytes | str:\n\"\"\"Receive next message from peer.\n    Returns:\n        Message received from peer.\n    \"\"\"\nreturn await self._incoming_queue.get()\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.send_offer","title":"send_offer()  <code>async</code>","text":"<pre><code>send_offer(peer_uuid: UUID) -&gt; None\n</code></pre> <p>Send offer for peering via relay server.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer client to establish connection with.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def send_offer(self, peer_uuid: UUID) -&gt; None:\n\"\"\"Send offer for peering via relay server.\n    Args:\n        peer_uuid: UUID of peer client to establish connection with.\n    \"\"\"\ndef _on_close(label: str) -&gt; Any:\n# We use this factory method to avoid Flake8-BugBear B023\nasync def on_close() -&gt; None:\nif self._channels[label].readyState in ('closed', 'failed'):\nawait self.close()\nreturn on_close\nfor i in range(self._max_channels):\nlabel = f'p2p-{i}-{self._max_channels}'\nchannel = self._pc.createDataChannel(label, ordered=False)\nbuffer_low = asyncio.Event()\nchannel.on('open', self._on_datachannel_open)\nchannel.on('bufferedamountlow', buffer_low.set)\nchannel.on('message', self._on_message)\nself._channels[label] = channel\nself._channel_buffer_low[label] = buffer_low\n# We use the underlying RTCDtlsTransport as the channel status.\nchannel.transport.transport.on('statechange', _on_close(label))\nawait self._pc.setLocalDescription(await self._pc.createOffer())\nmessage = messages.PeerConnection(\nsource_uuid=self._uuid,\nsource_name=self._name,\npeer_uuid=peer_uuid,\ndescription_type='offer',\ndescription=object_to_string(self._pc.localDescription),\n)\nmessage_str = messages.encode(message)\nlogger.info(f'{self._log_prefix}: sending offer to {peer_uuid}')\nawait self._websocket.send(message_str)\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.send_answer","title":"send_answer()  <code>async</code>","text":"<pre><code>send_answer(peer_uuid: UUID) -&gt; None\n</code></pre> <p>Send answer to peering request via relay server.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer client that sent the initial offer.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def send_answer(self, peer_uuid: UUID) -&gt; None:\n\"\"\"Send answer to peering request via relay server.\n    Args:\n        peer_uuid: UUID of peer client that sent the initial offer.\n    \"\"\"\n@self._pc.on('datachannel')\ndef on_datachannel(channel: RTCDataChannel) -&gt; None:\nlogger.info(f'{self._log_prefix}: peer channel established')\n# TODO: note this is first channel opened\nmatch = re.search(r'(\\d+)-(\\d+)$', channel.label)\nif match is None:\nraise AssertionError(\nf'Got mislabled datachannel {channel.label}',\n)\ntotal = int(match.group(2))\nbuffer_low = asyncio.Event()\nself._channels[channel.label] = channel\nself._channel_buffer_low[channel.label] = buffer_low\nchannel.on('bufferedamountlow', buffer_low.set)\nchannel.on('message', self._on_message)\nasync def _on_close() -&gt; None:\nif channel.readyState in ('closed', 'failed'):\nawait self.close()\nelse:\npass  # pragma: no cover\n# We use the underlying RTCDtlsTransport as the channel status\nchannel.transport.transport.on('statechange', _on_close)\nif len(self._channels) &gt;= total:\nself._handshake_success.set_result(True)\nawait self._pc.setLocalDescription(await self._pc.createAnswer())\nmessage = messages.PeerConnection(\nsource_uuid=self._uuid,\nsource_name=self._name,\npeer_uuid=peer_uuid,\ndescription_type='answer',\ndescription=object_to_string(self._pc.localDescription),\n)\nmessage_str = messages.encode(message)\nlogger.info(f'{self._log_prefix}: sending answer to {peer_uuid}')\nawait self._websocket.send(message_str)\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.handle_server_message","title":"handle_server_message()  <code>async</code>","text":"<pre><code>handle_server_message(\nmessage: messages.PeerConnection,\n) -&gt; None\n</code></pre> <p>Handle message from the relay server.</p> <p>Parameters:</p> <ul> <li> message             (<code>messages.PeerConnection</code>)         \u2013 <p>Message received from the relay server.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def handle_server_message(\nself,\nmessage: messages.PeerConnection,\n) -&gt; None:\n\"\"\"Handle message from the relay server.\n    Args:\n        message: Message received from the relay server.\n    \"\"\"\nif message.error is not None:\nself._handshake_success.set_exception(\nPeerConnectionError(\n'Received error message from relay server: '\nf'{str(message.error)}',\n),\n)\nreturn\nif message.description_type == 'offer':\nlogger.info(\nf'{self._log_prefix}: received offer from '\nf'{message.source_uuid} ({message.source_name})',\n)\nobj = object_from_string(message.description)\nelif message.description_type == 'answer':\nlogger.info(\nf'{self._log_prefix}: received answer from '\nf'{message.source_uuid} ({message.source_name})',\n)\nobj = object_from_string(message.description)\nelse:\nraise AssertionError(\n'P2P connection message does not contain either an offer or '\n'an answer',\n)\nif isinstance(obj, RTCSessionDescription):\nawait self._pc.setRemoteDescription(obj)\nself._peer_uuid = message.source_uuid\nself._peer_name = message.source_name\nif obj.type == 'offer':\nawait self.send_answer(message.source_uuid)\nelif isinstance(obj, RTCIceCandidate):  # pragma: no cover\n# We should not receive an RTCIceCandidate message via the\n# relay server but this is here following the aiortc example.\n# https://github.com/aiortc/aiortc/blob/713fb644b95328f8ec1ac2cbb54def0424cc6645/examples/datachannel-cli/cli.py#L30  # noqa: E501\nawait self._pc.addIceCandidate(obj)\nelif obj is BYE:  # pragma: no cover\nraise AssertionError('received BYE message')\nelse:\nraise AssertionError('received unknown message')\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.PeerConnection.ready","title":"ready()  <code>async</code>","text":"<pre><code>ready(timeout: float | None = None) -&gt; None\n</code></pre> <p>Wait for connection to be ready.</p> <p>Parameters:</p> <ul> <li> timeout             (<code>float | None</code>)         \u2013 <p>The maximum time in seconds to wait for the peer connection to establish. If None, block until the connection is established.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerConnectionTimeoutError</code>           \u2013         <p>If the connection is not ready within the timeout.</p> </li> <li> <code>PeerConnectionError</code>           \u2013         <p>If there is an error establishing the peer connection.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def ready(self, timeout: float | None = None) -&gt; None:\n\"\"\"Wait for connection to be ready.\n    Args:\n        timeout: The maximum time in seconds to wait for\n            the peer connection to establish. If None, block until\n            the connection is established.\n    Raises:\n        PeerConnectionTimeoutError: If the connection is not ready within\n            the timeout.\n        PeerConnectionError: If there is an error establishing the peer\n            connection.\n    \"\"\"\ntry:\nawait asyncio.wait_for(self._handshake_success, timeout)\nexcept asyncio.TimeoutError as e:\nraise PeerConnectionTimeoutError(\n'Timeout waiting for peer to peer connection to establish '\nf'in {self._log_prefix}.',\n) from e\n</code></pre>"},{"location":"api/p2p/connection/#proxystore.p2p.connection.log_name","title":"log_name()","text":"<pre><code>log_name(uuid: UUID, name: str) -&gt; str\n</code></pre> <p>Return string formatted as <code>'name(uuid-prefix)'</code>.</p> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>def log_name(uuid: UUID, name: str) -&gt; str:\n\"\"\"Return string formatted as `#!python 'name(uuid-prefix)'`.\"\"\"\nuuid_ = str(uuid)\nreturn f'{name}({uuid_[:min(8,len(uuid_))]})'\n</code></pre>"},{"location":"api/p2p/counter/","title":"proxystore.p2p.counter","text":"<code>proxystore/p2p/counter.py</code> <p>Atomic counting utilities.</p>"},{"location":"api/p2p/counter/#proxystore.p2p.counter.AtomicCounter","title":"AtomicCounter","text":"<pre><code>AtomicCounter(size: int | None = None) -&gt; None\n</code></pre> <p>Thread-safe counter.</p> <p>Parameters:</p> <ul> <li> size             (<code>int | None</code>)         \u2013 <p>Optional max count upon which an exception will be raised.</p> </li> </ul> Source code in <code>proxystore/p2p/counter.py</code> <pre><code>def __init__(self, size: int | None = None) -&gt; None:\nself._size = size\nself._value = 0\nself._lock = threading.Lock()\n</code></pre>"},{"location":"api/p2p/counter/#proxystore.p2p.counter.AtomicCounter.increment","title":"increment()","text":"<pre><code>increment() -&gt; int\n</code></pre> <p>Get current count and increment value.</p> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Current count.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If current count is equal to or greater than size.</p> </li> </ul> Source code in <code>proxystore/p2p/counter.py</code> <pre><code>def increment(self) -&gt; int:\n\"\"\"Get current count and increment value.\n    Returns:\n        Current count.\n    Raises:\n        ValueError: If current count is equal to or greater than size.\n    \"\"\"\nwith self._lock:\nvalue = self._value\nif self._size is not None and value &gt;= self._size:\nraise ValueError(f'Max counter size exceeded ({self._size}).')\nself._value += 1\nreturn value\n</code></pre>"},{"location":"api/p2p/exceptions/","title":"proxystore.p2p.exceptions","text":"<code>proxystore/p2p/exceptions.py</code> <p>Exception types for the relay server.</p>"},{"location":"api/p2p/exceptions/#proxystore.p2p.exceptions.PeerConnectionError","title":"PeerConnectionError","text":"<p>         Bases: <code>Exception</code></p> <p>Error connecting to peer.</p>"},{"location":"api/p2p/exceptions/#proxystore.p2p.exceptions.PeerConnectionTimeoutError","title":"PeerConnectionTimeoutError","text":"<p>         Bases: <code>PeerConnectionError</code></p> <p>Timeout waiting on peer to peer connection to establish.</p>"},{"location":"api/p2p/exceptions/#proxystore.p2p.exceptions.PeerRegistrationError","title":"PeerRegistrationError","text":"<p>         Bases: <code>Exception</code></p> <p>Error when establishing peer connection.</p>"},{"location":"api/p2p/manager/","title":"proxystore.p2p.manager","text":"<code>proxystore/p2p/manager.py</code> <p>Manager of many peer-to-peer connections.</p>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager","title":"PeerManager","text":"<pre><code>PeerManager(\nuuid: UUID,\nrelay_server: str,\nname: str | None = None,\n*,\ntimeout: int = 30,\npeer_channels: int = 1,\nverify_certificate: bool = True\n) -&gt; None\n</code></pre> <p>Peer Connections Manager.</p> <p>Handles establishing peer connections via aiortc, responding to requests for new peer connections from the relay server, and sending and receiving data to/from existing peer connections.</p> Example <pre><code>from proxystore.p2p.manager import PeerManager\npm1 = await PeerManager(uuid.uuid4(), relay_server_address)\npm2 = await PeerManager(uuid.uuid4(), relay_server_address)\nawait pm1.send(pm2.uuid, 'hello hello')\nsource_uuid, message = await pm2.recv()\nassert source_uuid == pm1.uuid\nassert message == 'hello hello'\npm1.close()\npm2.close()\n</code></pre> Note <p>The class can also be used as a context manager.</p> <pre><code>async with PeerManager(..) as manager:\n...\n</code></pre> Warning <p>The class must be initialized with await or inside an async with statement to correctly configure all async tasks and connections.</p> <pre><code>manager = await PeerManager(...)\nmanager.close()\n</code></pre> <pre><code>async with PeerManager(...) as manager:\n...\n</code></pre> <p>Parameters:</p> <ul> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of the client.</p> </li> <li> relay_server             (<code>str</code>)         \u2013 <p>Address of relay server to use for establishing peer-to-peer connections.</p> </li> <li> name             (<code>str | None</code>)         \u2013 <p>Readable name of the client to use in logging. If unspecified, the hostname will be used.</p> </li> <li> timeout             (<code>int</code>)         \u2013 <p>Timeout in seconds when waiting for a peer or relay server connection to be established.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>number of datachannels to split message sending over between each peer.</p> </li> <li> verify_certificate             (<code>bool</code>)         \u2013 <p>Verify the relay server's SSL certificate,</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the relay server address does not start with \"ws://\" or \"wss://\".</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>def __init__(\nself,\nuuid: UUID,\nrelay_server: str,\nname: str | None = None,\n*,\ntimeout: int = 30,\npeer_channels: int = 1,\nverify_certificate: bool = True,\n) -&gt; None:\nif not (\nrelay_server.startswith('ws://')\nor relay_server.startswith('wss://')\n):\nraise ValueError(\n'Relay server address must start with ws:// or wss://'\nf'Got {relay_server}.',\n)\nself._uuid = uuid\nself._relay_server = relay_server\nself._name = name if name is not None else utils.hostname()\nself._timeout = timeout\nself._peer_channels = peer_channels\nself._verify_certificate = verify_certificate\nself._peers_lock = asyncio.Lock()\nself._peers: dict[frozenset[UUID], PeerConnection] = {}\nself._message_queue: asyncio.Queue[\ntuple[UUID, bytes | str]\n] = asyncio.Queue()\nself._server_task: asyncio.Task[None] | None = None\nself._tasks: dict[frozenset[UUID], asyncio.Task[None]] = {}\nself._websocket_or_none: WebSocketClientProtocol | None = None\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: UUID\n</code></pre> <p>UUID of the peer manager.</p>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the peer manager.</p>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.async_init","title":"async_init()  <code>async</code>","text":"<pre><code>async_init() -&gt; None\n</code></pre> <p>Connect to relay server.</p> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def async_init(self) -&gt; None:\n\"\"\"Connect to relay server.\"\"\"\nif self._websocket_or_none is None:\nssl_context = ssl.create_default_context()\nif not self._verify_certificate:\nssl_context.check_hostname = False\nssl_context.verify_mode = ssl.CERT_NONE\nuuid, _, socket = await connect(\naddress=self._relay_server,\nuuid=self._uuid,\nname=self._name,\ntimeout=self._timeout,\nssl=ssl_context\nif self._relay_server.startswith('wss://')\nelse None,\n)\nif uuid != self._uuid:\nraise PeerRegistrationError(\n'Relay server responded to registration request '\nf'with non-matching UUID. Received {uuid} but expected '\nf'{self._uuid}.',\n)\nself._websocket_or_none = socket\nlogger.info(\nf'{self._log_prefix}: registered as peer with relay '\nf'server at {self._relay_server}',\n)\nif self._server_task is None:\nself._server_task = spawn_guarded_background_task(\nself._handle_server_messages,\n)\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.close","title":"close()  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connection manager.</p> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the connection manager.\"\"\"\nif self._server_task is not None:\nself._server_task.cancel()\ntry:\nawait self._server_task\nexcept (asyncio.CancelledError, SafeTaskExitError):\npass\nfor task in self._tasks.values():\ntask.cancel()\ntry:\nawait task\nexcept (asyncio.CancelledError, SafeTaskExitError):\npass\nasync with self._peers_lock:\nfor connection in self._peers.values():\nawait connection.close()\nif self._websocket_or_none is not None:\nawait self._websocket_or_none.close()\nlogger.info(f'{self._log_prefix}: peer manager closed')\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.close_connection","title":"close_connection()  <code>async</code>","text":"<pre><code>close_connection(peers: Iterable[UUID]) -&gt; None\n</code></pre> <p>Close a peer connection if it exists.</p> <p>This will close the associated <code>PeerConnection</code> and cancel the asyncio task handling peer messages. If the <code>PeerManager</code> is used to send a message from the peer again, a new connection will be established.</p> <p>Parameters:</p> <ul> <li> peers             (<code>Iterable[UUID]</code>)         \u2013 <p>Iterable containing the two peer UUIDs taking part in the connection that should be closed.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def close_connection(self, peers: Iterable[UUID]) -&gt; None:\n\"\"\"Close a peer connection if it exists.\n    This will close the associated\n    [`PeerConnection`][proxystore.p2p.connection.PeerConnection] and\n    cancel the asyncio task handling peer messages. If the\n    [`PeerManager`][proxystore.p2p.manager.PeerManager] is used to\n    send a message from the peer again, a new connection will be\n    established.\n    Args:\n        peers: Iterable containing the two peer UUIDs taking part in the\n            connection that should be closed.\n    \"\"\"\npeers = frozenset(peers)\nasync with self._peers_lock:\nconnection = self._peers.pop(peers, None)\nif connection is not None:\nlogger.info(\nf'{self._log_prefix} Closing connection between peers: '\nf'{\", \".join(str(peer) for peer in peers)}',\n)\nawait connection.close()\ntask = self._tasks.pop(peers, None)\nif task is not None:\ntask.cancel()\ntry:\nawait task\nexcept (asyncio.CancelledError, SafeTaskExitError):\npass\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.recv","title":"recv()  <code>async</code>","text":"<pre><code>recv() -&gt; tuple[UUID, bytes | str]\n</code></pre> <p>Receive next message from a peer.</p> <p>Returns:</p> <ul> <li> <code>UUID</code>         \u2013 <p>Tuple containing the UUID of the peer that sent the message</p> </li> <li> <code>bytes | str</code>         \u2013 <p>and the message itself.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def recv(self) -&gt; tuple[UUID, bytes | str]:\n\"\"\"Receive next message from a peer.\n    Returns:\n        Tuple containing the UUID of the peer that sent the message\n        and the message itself.\n    \"\"\"\nreturn await self._message_queue.get()\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.send","title":"send()  <code>async</code>","text":"<pre><code>send(\npeer_uuid: UUID,\nmessage: bytes | str,\ntimeout: float = 30,\n) -&gt; None\n</code></pre> <p>Send message to peer.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer to send message to.</p> </li> <li> message             (<code>bytes | str</code>)         \u2013 <p>Message to send to peer.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Timeout to wait on peer connection to be ready.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerConnectionTimeoutError</code>           \u2013         <p>If the peer connection is not established within the timeout.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def send(\nself,\npeer_uuid: UUID,\nmessage: bytes | str,\ntimeout: float = 30,\n) -&gt; None:\n\"\"\"Send message to peer.\n    Args:\n        peer_uuid: UUID of peer to send message to.\n        message: Message to send to peer.\n        timeout: Timeout to wait on peer connection to be ready.\n    Raises:\n        PeerConnectionTimeoutError: If the peer connection is not\n            established within the timeout.\n    \"\"\"\nconnection = await self.get_connection(peer_uuid)\nawait connection.send(message, timeout)\n</code></pre>"},{"location":"api/p2p/manager/#proxystore.p2p.manager.PeerManager.get_connection","title":"get_connection()  <code>async</code>","text":"<pre><code>get_connection(peer_uuid: UUID) -&gt; PeerConnection\n</code></pre> <p>Get connection to the peer.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer to make connection with.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PeerConnection</code>         \u2013 <p>The peer connection object.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def get_connection(self, peer_uuid: UUID) -&gt; PeerConnection:\n\"\"\"Get connection to the peer.\n    Args:\n        peer_uuid: UUID of peer to make connection with.\n    Returns:\n        The peer connection object.\n    \"\"\"\npeers = frozenset({self._uuid, peer_uuid})\nasync with self._peers_lock:\nif peers in self._peers:\nreturn self._peers[peers]\nconnection = PeerConnection(\nself._uuid,\nself._name,\nself._websocket,\nchannels=self._peer_channels,\n)\nself._peers[peers] = connection\nlogger.info(\nf'{self._log_prefix}: opening peer connection with '\nf'{peer_uuid}',\n)\nawait connection.send_offer(peer_uuid)\nself._tasks[peers] = spawn_guarded_background_task(\nself._handle_peer_messages,\npeer_uuid,\nconnection,\n)\nconnection.on_close_callback(self.close_connection, peers)\nreturn connection\n</code></pre>"},{"location":"api/p2p/messages/","title":"proxystore.p2p.messages","text":"<code>proxystore/p2p/messages.py</code> <p>Message types for peer-to-peer communication.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageType","title":"MessageType","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Types of messages supported.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageType.server_response","title":"server_response  <code>class-attribute</code>","text":"<pre><code>server_response = 'ServerResponse'\n</code></pre> <p>Server response message.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageType.server_registration","title":"server_registration  <code>class-attribute</code>","text":"<pre><code>server_registration = 'ServerRegistration'\n</code></pre> <p>Server registration message.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageType.peer_connection","title":"peer_connection  <code>class-attribute</code>","text":"<pre><code>peer_connection = 'PeerConnection'\n</code></pre> <p>Peer connection message.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.Message","title":"Message  <code>dataclass</code>","text":"<p>Base message.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.ServerRegistration","title":"ServerRegistration  <code>dataclass</code>","text":"<p>         Bases: <code>Message</code></p> <p>Register with relay server as peer.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of peer requesting to register.</p> </li> <li> uuid             (<code>uuid.UUID</code>)         \u2013 <p>UUID of peer requesting to register.</p> </li> </ul>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.ServerResponse","title":"ServerResponse  <code>dataclass</code>","text":"<p>         Bases: <code>Message</code></p> <p>Message returned by relay server on success or error.</p> <p>Attributes:</p> <ul> <li> success             (<code>bool</code>)         \u2013 <p>If the registration was successful.</p> </li> <li> message             (<code>str | None</code>)         \u2013 <p>Message from server.</p> </li> <li> error             (<code>bool</code>)         \u2013 <p>If <code>message</code> is an error message.</p> </li> </ul>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.PeerConnection","title":"PeerConnection  <code>dataclass</code>","text":"<p>         Bases: <code>Message</code></p> <p>Message used in establishing a peer-to-peer connection.</p> <p>Attributes:</p> <ul> <li> source_uuid             (<code>uuid.UUID</code>)         \u2013 <p>UUID of sending peer.</p> </li> <li> source_name             (<code>str</code>)         \u2013 <p>Name of sending peer.</p> </li> <li> peer_uuid             (<code>uuid.UUID</code>)         \u2013 <p>UUID of destination peer.</p> </li> <li> description_type             (<code>Literal[answer, offer]</code>)         \u2013 <p>One of <code>'answer'</code> or <code>'offer'</code> indicating the type of message being sent.</p> </li> <li> description             (<code>str</code>)         \u2013 <p>Session description protocol message.</p> </li> <li> error             (<code>str | None</code>)         \u2013 <p>Error string if a problem occurs.</p> </li> </ul>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageDecodeError","title":"MessageDecodeError","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when a message cannot be decoded.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.MessageEncodeError","title":"MessageEncodeError","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when an message cannot be encoded.</p>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.uuid_to_str","title":"uuid_to_str()","text":"<pre><code>uuid_to_str(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Cast any UUIDs to strings.</p> <p>Scans the input dictionary for any values where the associated key contains 'uuid' and value is a UUID instance and converts it to a string for jsonification.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>Shallow copy of the input dictionary with values cast from UUID         to str if their key also contains UUID.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def uuid_to_str(data: dict[str, Any]) -&gt; dict[str, Any]:\n\"\"\"Cast any UUIDs to strings.\n    Scans the input dictionary for any values where the associated key\n    contains 'uuid' and value is a UUID instance and converts it to a\n    string for jsonification.\n    Returns:\n        Shallow copy of the input dictionary with values cast from UUID \\\n        to str if their key also contains UUID.\n    \"\"\"\ndata = data.copy()\nfor key in data:\nif 'uuid' in key.lower() and isinstance(data[key], uuid.UUID):\ndata[key] = str(data[key])\nreturn data\n</code></pre>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.str_to_uuid","title":"str_to_uuid()","text":"<pre><code>str_to_uuid(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Cast any possible UUID strings to UUID objects.</p> <p>The inverse operation of uuid_to_str().</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>Shallow copy of the input dictionary with values cast from         str to UUID if the key also contains UUID.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MessageDecodeError</code>           \u2013         <p>If a key contains 'uuid' but the value cannot be cast to a UUID.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def str_to_uuid(data: dict[str, Any]) -&gt; dict[str, Any]:\n\"\"\"Cast any possible UUID strings to UUID objects.\n    The inverse operation of\n    [uuid_to_str()][proxystore.p2p.messages.uuid_to_str].\n    Returns:\n        Shallow copy of the input dictionary with values cast from \\\n        str to UUID if the key also contains UUID.\n    Raises:\n        MessageDecodeError: If a key contains 'uuid' but the value cannot be\n            cast to a UUID.\n    \"\"\"\ndata = data.copy()\nfor key in data:\nif 'uuid' in key.lower():\ntry:\ndata[key] = uuid.UUID(data[key])\nexcept (AttributeError, TypeError, ValueError) as e:\nraise MessageDecodeError(\nf'Failed to convert key {key} to UUID.',\n) from e\nreturn data\n</code></pre>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.decode","title":"decode()","text":"<pre><code>decode(message: str) -&gt; Message\n</code></pre> <p>Decode JSON string into correct Message type.</p> <p>Parameters:</p> <ul> <li> message             (<code>str</code>)         \u2013 <p>JSON string to decode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>         \u2013 <p>Parsed message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MessageDecodeError</code>           \u2013         <p>If the message cannot be decoded.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def decode(message: str) -&gt; Message:\n\"\"\"Decode JSON string into correct Message type.\n    Args:\n        message: JSON string to decode.\n    Returns:\n        Parsed message.\n    Raises:\n        MessageDecodeError: If the message cannot be decoded.\n    \"\"\"\ntry:\ndata = json.loads(message)\nexcept json.JSONDecodeError as e:\nraise MessageDecodeError('Failed to load string as JSON.') from e\ntry:\nmessage_type_name = data.pop('message_type')\nexcept KeyError as e:\nraise MessageDecodeError(\n'Message does not contain a message_type key.',\n) from e\ntry:\nmessage_type = getattr(\nsys.modules[__name__],\nMessageType[message_type_name].value,\n)\nexcept (AttributeError, KeyError) as e:\nraise MessageDecodeError(\n'The message is of an unknown message type: '\nf'{message_type_name}.',\n) from e\ndata = str_to_uuid(data)\ntry:\nreturn message_type(**data)\nexcept TypeError as e:\nraise MessageDecodeError(\nf'Failed to convert message to {message_type.__name__}: {e}',\n) from e\n</code></pre>"},{"location":"api/p2p/messages/#proxystore.p2p.messages.encode","title":"encode()","text":"<pre><code>encode(message: Message) -&gt; str\n</code></pre> <p>Encode message as JSON string.</p> <p>Parameters:</p> <ul> <li> message             (<code>Message</code>)         \u2013 <p>Message to JSON encode.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MessageEncodeError</code>           \u2013         <p>If the message cannot be JSON encoded.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def encode(message: Message) -&gt; str:\n\"\"\"Encode message as JSON string.\n    Args:\n        message: Message to JSON encode.\n    Raises:\n        MessageEncodeError: If the message cannot be JSON encoded.\n    \"\"\"\nif not isinstance(message, Message):\nraise MessageEncodeError(\nf'Message is not an instance of {Message.__name__}. '\nf'Got {type(message).__name__}.',\n)\ndata = dataclasses.asdict(message)\ndata = uuid_to_str(data)\ntry:\nreturn json.dumps(data)\nexcept TypeError as e:\nraise MessageEncodeError('Error encoding message.') from e\n</code></pre>"},{"location":"api/p2p/relay/","title":"proxystore.p2p.relay","text":"<code>proxystore/p2p/relay.py</code> <p>Relay server implementation for WebRTC peer connections.</p> <p>The relay server (or signaling server) is a lightweight server accessible by all peers (e.g., has a public IP address) that facilitates the establishment of peer WebRTC connections.</p>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.Client","title":"Client  <code>dataclass</code>","text":"<p>Representation of client connection.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of client.</p> </li> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of client.</p> </li> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>WebSocket connection to the client.</p> </li> </ul>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer","title":"RelayServer","text":"<pre><code>RelayServer() -&gt; None\n</code></pre> <p>WebRTC relay server.</p> <p>The relay server acts as a public third-party that helps two peers (endpoints) establish a peer-to-peer connection during the WebRTC peer connection initiation process. The relay server's responsibility is just to forward session descriptions between two peers, so the server can be relatively lightweight and typically only needs to transfer two messages to establish a peer connection, after which the peers no longer need the relay server.</p> <p>To learn more about the WebRTC peer connection process, check out https://webrtc.org/getting-started/peer-connections.</p> <p>The relay server is built on websockets and designed to be served using <code>websockets.serve()</code>.</p> Example <pre><code>import websockets\nfrom proxystore.p2p.relay import RelayServer\nrelay_server = RelayServer()\nasync with websockets.serve(\nrelay_server.handler, host='localhost', port=1234\n) as websocket_server:\n...\n</code></pre> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>def __init__(self) -&gt; None:\nself._websocket_to_client: dict[WebSocketServerProtocol, Client] = {}\nself._uuid_to_client: dict[UUID, Client] = {}\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer.send","title":"send()  <code>async</code>","text":"<pre><code>send(\nwebsocket: WebSocketServerProtocol,\nmessage: messages.Message,\n) -&gt; None\n</code></pre> <p>Send message on the socket.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket to send message on.</p> </li> <li> message             (<code>messages.Message</code>)         \u2013 <p>Message to json encode and send.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def send(\nself,\nwebsocket: WebSocketServerProtocol,\nmessage: messages.Message,\n) -&gt; None:\n\"\"\"Send message on the socket.\n    Args:\n        websocket: Websocket to send message on.\n        message: Message to json encode and send.\n    \"\"\"\ntry:\nmessage_str = messages.encode(message)\nexcept messages.MessageEncodeError as e:\nlogger.error(f'Failed to encode message: {e}')\nreturn\ntry:\nawait websocket.send(message_str)\nexcept websockets.exceptions.ConnectionClosed:\nlogger.error('Connection closed while attempting to send message')\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer.register","title":"register()  <code>async</code>","text":"<pre><code>register(\nwebsocket: WebSocketServerProtocol,\nrequest: messages.ServerRegistration,\n) -&gt; None\n</code></pre> <p>Register peer with relay server.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket connection with client wanting to register.</p> </li> <li> request             (<code>messages.ServerRegistration</code>)         \u2013 <p>Registration request message.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def register(\nself,\nwebsocket: WebSocketServerProtocol,\nrequest: messages.ServerRegistration,\n) -&gt; None:\n\"\"\"Register peer with relay server.\n    Args:\n        websocket: Websocket connection with client wanting to register.\n        request: Registration request message.\n    \"\"\"\nif websocket not in self._websocket_to_client:\n# Check if previous client reconnected on new socket so unregister\n# old socket. Warning: could be a client impersontating another\nif request.uuid in self._uuid_to_client:\nlogger.info(\nf'Previously registered client {request.uuid} attempting '\n'to reregister so old registration will be removed',\n)\nawait self.unregister(\nself._uuid_to_client[request.uuid].websocket,\nFalse,\n)\nclient = Client(\nname=request.name,\nuuid=request.uuid,\nwebsocket=websocket,\n)\nself._websocket_to_client[websocket] = client\nself._uuid_to_client[client.uuid] = client\nlogger.info(\nf'Registered {client.uuid} ({client.name} at '\nf'{websocket.remote_address})',\n)\nelse:\nclient = self._websocket_to_client[websocket]\nlogger.info(\nf'Previously registered client {client.uuid} attempting to '\n'reregister so previous registration will be returned',\n)\nawait self.send(websocket, messages.ServerResponse(success=True))\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer.unregister","title":"unregister()  <code>async</code>","text":"<pre><code>unregister(\nwebsocket: WebSocketServerProtocol, expected: bool\n) -&gt; None\n</code></pre> <p>Unregister the endpoint.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket connection that was closed.</p> </li> <li> expected             (<code>bool</code>)         \u2013 <p>If the connection was closed intentionally or due to an error.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def unregister(\nself,\nwebsocket: WebSocketServerProtocol,\nexpected: bool,\n) -&gt; None:\n\"\"\"Unregister the endpoint.\n    Args:\n        websocket: Websocket connection that was closed.\n        expected: If the connection was closed intentionally or due to an\n            error.\n    \"\"\"\nclient = self._websocket_to_client.pop(websocket, None)\nif client is None:\n# Most likely websocket closed before registration was performed\nreturn\nreason = 'ok' if expected else 'unexpected'\nlogger.info(\nf'Unregistering client {client.uuid} ({client.name}) '\nf'for {reason} reason',\n)\nself._uuid_to_client.pop(client.uuid, None)\nawait client.websocket.close(code=1000 if expected else 1001)\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer.connect","title":"connect()  <code>async</code>","text":"<pre><code>connect(\nwebsocket: WebSocketServerProtocol,\nmessage: messages.PeerConnection,\n) -&gt; None\n</code></pre> <p>Pass peer connection messages between clients.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket connection with client that sent the peer connection message.</p> </li> <li> message             (<code>messages.PeerConnection</code>)         \u2013 <p>Message to forward to peer client.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def connect(\nself,\nwebsocket: WebSocketServerProtocol,\nmessage: messages.PeerConnection,\n) -&gt; None:\n\"\"\"Pass peer connection messages between clients.\n    Args:\n        websocket: Websocket connection with client that sent the peer\n            connection message.\n        message: Message to forward to peer client.\n    \"\"\"\nclient = self._websocket_to_client[websocket]\nif message.peer_uuid not in self._uuid_to_client:\nlogger.warning(\nf'Client {client.uuid} ({client.name}) attempting to send '\nf'message to unknown peer {message.peer_uuid}',\n)\nmessage.error = (\n'Cannot forward peer connection message to peer '\nf'{message.peer_uuid} because this peer is unknown.'\n)\nawait self.send(websocket, message)\nelse:\npeer_client = self._uuid_to_client[message.peer_uuid]\nlogger.info(\nf'Transmitting message from {client.uuid} ({client.name}) '\nf'to {message.peer_uuid}',\n)\nawait self.send(peer_client.websocket, message)\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.RelayServer.handler","title":"handler()  <code>async</code>","text":"<pre><code>handler(\nwebsocket: WebSocketServerProtocol, uri: str\n) -&gt; None\n</code></pre> <p>Websocket server message handler.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket message was received on.</p> </li> <li> uri             (<code>str</code>)         \u2013 <p>URI message was sent to.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def handler(\nself,\nwebsocket: WebSocketServerProtocol,\nuri: str,\n) -&gt; None:\n\"\"\"Websocket server message handler.\n    Args:\n        websocket: Websocket message was received on.\n        uri: URI message was sent to.\n    \"\"\"\nlogger.info('Relay server listening for incoming connections')\nwhile True:\ntry:\nmessage_str = await websocket.recv()\nif isinstance(message_str, str):\nmessage = messages.decode(message_str)\nelse:\nraise AssertionError(\n'Received non-str type on websocket.',\n)\nexcept websockets.exceptions.ConnectionClosedOK:\nawait self.unregister(websocket, expected=True)\nbreak\nexcept websockets.exceptions.ConnectionClosedError:\nawait self.unregister(websocket, expected=False)\nbreak\nexcept messages.MessageDecodeError as e:\nlogger.error(\n'Caught deserialization error on message received from '\nf'{websocket.remote_address}: {e} ...skipping message',\n)\ncontinue\nif isinstance(message, messages.ServerRegistration):\nawait self.register(websocket, message)\nelif isinstance(message, messages.PeerConnection):\nif websocket in self._websocket_to_client:\nawait self.connect(websocket, message)\nelse:\n# If message is not a registration request but this client\n# has not yet registered, let them know\nlogger.info(\n'Returning server error to message received from '\nf'unregistered client {message.source_uuid} '\nf'({message.source_name})',\n)\nresponse = messages.ServerResponse(\nsuccess=False,\nmessage='client has not registered yet',\nerror=True,\n)\nawait self.send(websocket, response)\nelse:\nraise AssertionError('Unreachable.')\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.serve","title":"serve()  <code>async</code>","text":"<pre><code>serve(\nhost: str,\nport: int,\ncertfile: str | None = None,\nkeyfile: str | None = None,\n) -&gt; None\n</code></pre> <p>Run the relay server.</p> <p>Initializes a <code>RelayServer</code> and starts a websocket server listening on <code>host:port</code> for new connections and incoming messages.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>Host to listen on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port to listen on.</p> </li> <li> certfile             (<code>str | None</code>)         \u2013 <p>Optional certificate file (PEM format) to enable TLS while serving.</p> </li> <li> keyfile             (<code>str | None</code>)         \u2013 <p>Optional private key file. If not specified, the key will be taken from the certfile.</p> </li> </ul> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>async def serve(\nhost: str,\nport: int,\ncertfile: str | None = None,\nkeyfile: str | None = None,\n) -&gt; None:\n\"\"\"Run the relay server.\n    Initializes a [`RelayServer`][proxystore.p2p.relay.RelayServer]\n    and starts a websocket server listening on `host:port` for new connections\n    and incoming messages.\n    Args:\n        host: Host to listen on.\n        port: Port to listen on.\n        certfile: Optional certificate file (PEM format) to enable TLS while\n            serving.\n        keyfile: Optional private key file. If not specified, the key will be\n            taken from the certfile.\n    \"\"\"\nserver = RelayServer()\n# Set the stop condition when receiving SIGINT (ctrl-C) and SIGTERM.\nloop = asyncio.get_running_loop()\nstop = loop.create_future()\nloop.add_signal_handler(signal.SIGINT, stop.set_result, None)\nloop.add_signal_handler(signal.SIGTERM, stop.set_result, None)\nssl_context: ssl.SSLContext | None = None\nif certfile is not None:  # pragma: no cover\nssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\nssl_context.load_cert_chain(certfile, keyfile=keyfile)\nasync with websockets.server.serve(\nserver.handler,\nhost,\nport,\nlogger=logger,\nssl=ssl_context,\n):\nlogger.info(f'Serving relay server on {host}:{port}')\nlogger.info('Use ctrl-C to stop')\nawait stop\nlogger.info('Server closed')\n</code></pre>"},{"location":"api/p2p/relay/#proxystore.p2p.relay.cli","title":"cli()","text":"<pre><code>cli(\nhost: str,\nport: int,\ncertfile: str | None,\nkeyfile: str | None,\nlog_dir: str | None,\nlog_level: str,\n) -&gt; None\n</code></pre> <p>Run a relay server instance.</p> <p>The relay server is used by clients to establish peer-to-peer WebRTC connections.</p> Source code in <code>proxystore/p2p/relay.py</code> <pre><code>@click.command()\n@click.option(\n'--host',\ndefault='0.0.0.0',\nmetavar='ADDR',\nhelp='Address to listen on.',\n)\n@click.option(\n'--port',\ndefault=8765,\ntype=int,\nmetavar='PORT',\nhelp='Port to listen on.',\n)\n@click.option(\n'--certfile',\ndefault=None,\nmetavar='PATH',\nhelp='Certificate file for serving with TLS.',\n)\n@click.option(\n'--keyfile',\ndefault=None,\nmetavar='PATH',\nhelp='Private key file associated with the certfile.',\n)\n@click.option(\n'--log-dir',\ndefault=None,\nmetavar='PATH',\nhelp='Write server logs to this directory.',\n)\n@click.option(\n'--log-level',\ndefault='INFO',\ntype=click.Choice(\n['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'],\ncase_sensitive=False,\n),\nhelp='Minimum logging level.',\n)\ndef cli(\nhost: str,\nport: int,\ncertfile: str | None,\nkeyfile: str | None,\nlog_dir: str | None,\nlog_level: str,\n) -&gt; None:\n\"\"\"Run a relay server instance.\n    The relay server is used by clients to establish peer-to-peer\n    WebRTC connections.\n    \"\"\"\nhandlers: list[logging.Handler] = [logging.StreamHandler(sys.stdout)]\nif log_dir is not None:\nos.makedirs(log_dir, exist_ok=True)\nhandlers.append(\nlogging.handlers.TimedRotatingFileHandler(\nos.path.join(log_dir, 'server.log'),\n# Rotate logs Sunday at midnight\nwhen='W6',\natTime=datetime.time(hour=0, minute=0, second=0),\n),\n)\nlogging.basicConfig(\nformat=(\n'[%(asctime)s.%(msecs)03d] %(levelname)-5s (%(name)s) :: '\n'%(message)s'\n),\ndatefmt='%Y-%m-%d %H:%M:%S',\nlevel=log_level,\nhandlers=handlers,\n)\nasyncio.run(serve(host, port, certfile=certfile, keyfile=keyfile))\n</code></pre>"},{"location":"api/p2p/task/","title":"proxystore.p2p.task","text":"<code>proxystore/p2p/task.py</code> <p>Utilities for launching async tasks.</p>"},{"location":"api/p2p/task/#proxystore.p2p.task.SafeTaskExitError","title":"SafeTaskExitError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception that can be raised inside a task to safely exit it.</p>"},{"location":"api/p2p/task/#proxystore.p2p.task.exit_on_error","title":"exit_on_error()","text":"<pre><code>exit_on_error(task: asyncio.Task[Any]) -&gt; None\n</code></pre> <p>Task callback that raises SystemExit on task exception.</p> Source code in <code>proxystore/p2p/task.py</code> <pre><code>def exit_on_error(task: asyncio.Task[Any]) -&gt; None:\n\"\"\"Task callback that raises SystemExit on task exception.\"\"\"\nif (\nnot task.cancelled()\nand task.exception() is not None\nand not isinstance(task.exception(), SafeTaskExitError)\n):\nlogger.error(f'Exception in background coroutine: {task.exception()}')\nraise SystemExit(1)\n</code></pre>"},{"location":"api/p2p/task/#proxystore.p2p.task.spawn_guarded_background_task","title":"spawn_guarded_background_task()","text":"<pre><code>spawn_guarded_background_task(\ncoro: Callable[..., Coroutine[Any, Any, None]],\n*args: Any,\n**kwargs: Any\n) -&gt; asyncio.Task[Any]\n</code></pre> <p>Run a coroutine safely in the background.</p> <p>Launches the coroutine as an asyncio task and sets the done callback to <code>exit_on_error()</code>. This is \"safe\" because it will ensure exceptions inside the task get logged and cause the program to exit. Otherwise, background tasks that are not awaited may not have their exceptions raised such that programs hang with no notice of the exception that caused the hang.</p> <p>Tasks can raise <code>SafeTaskExit</code> to signal the task is finished but should not cause a system exit.</p> <p>Source: https://stackoverflow.com/questions/62588076</p> <p>Parameters:</p> <ul> <li> coro             (<code>Callable[..., Coroutine[Any, Any, None]]</code>)         \u2013 <p>Coroutine to run as task.</p> </li> <li> args             (<code>Any</code>)         \u2013 <p>Positional arguments for the coroutine.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Keyword arguments for the coroutine.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>asyncio.Task[Any]</code>         \u2013 <p>Asyncio task handle.</p> </li> </ul> Source code in <code>proxystore/p2p/task.py</code> <pre><code>def spawn_guarded_background_task(\ncoro: Callable[..., Coroutine[Any, Any, None]],\n*args: Any,\n**kwargs: Any,\n) -&gt; asyncio.Task[Any]:\n\"\"\"Run a coroutine safely in the background.\n    Launches the coroutine as an asyncio task and sets the done\n    callback to [`exit_on_error()`][proxystore.p2p.task.exit_on_error].\n    This is \"safe\" because it will ensure exceptions inside the task get logged\n    and cause the program to exit. Otherwise, background tasks that are not\n    awaited may not have their exceptions raised such that programs hang with\n    no notice of the exception that caused the hang.\n    Tasks can raise [`SafeTaskExit`][proxystore.p2p.task.SafeTaskExitError] to\n    signal the task is finished but should not cause a system exit.\n    Source: https://stackoverflow.com/questions/62588076\n    Args:\n        coro: Coroutine to run as task.\n        args: Positional arguments for the coroutine.\n        kwargs: Keyword arguments for the coroutine.\n    Returns:\n        Asyncio task handle.\n    \"\"\"\ntask = asyncio.create_task(coro(*args, **kwargs))\ntask.add_done_callback(exit_on_error)\nreturn task\n</code></pre>"},{"location":"api/store/","title":"proxystore.store","text":"<code>proxystore/store/__init__.py</code> <p>The ProxyStore <code>Store</code> interface.</p>"},{"location":"api/store/#proxystore.store.get_store","title":"get_store()","text":"<pre><code>get_store(val: str | Proxy[T]) -&gt; Store[Any] | None\n</code></pre> <p>Get the backend store with name.</p> <p>Parameters:</p> <ul> <li> val             (<code>str | Proxy[T]</code>)         \u2013 <p>name of the store to get or a <code>Proxy</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Store[Any] | None</code>         \u2013 <p><code>Store</code> if a store matching the         name or belonging to the proxy exists. If the store does not exist,         returns <code>None</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ProxyStoreFactoryError</code>           \u2013         <p>If the value is a proxy but does not contain a factory of type <code>StoreFactory</code>.</p> </li> </ul> Source code in <code>proxystore/store/__init__.py</code> <pre><code>def get_store(val: str | Proxy[T]) -&gt; Store[Any] | None:\n\"\"\"Get the backend store with name.\n    Args:\n        val: name of the store to get or a [`Proxy`][proxystore.proxy.Proxy]\n            instance.\n    Returns:\n        [`Store`][proxystore.store.base.Store] if a store matching the \\\n        name or belonging to the proxy exists. If the store does not exist, \\\n        returns `None`.\n    Raises:\n        ProxyStoreFactoryError: If the value is a proxy but does not contain a\n            factory of type\n            [`StoreFactory`][proxystore.store.base.StoreFactory].\n    \"\"\"\nif isinstance(val, Proxy):\n# If the object is a proxy, get the factory that will access the store\nfactory = val.__factory__\nif isinstance(factory, StoreFactory):\nreturn factory.get_store()\nelse:\nraise ProxyStoreFactoryError(\n'The proxy must contain a factory with type '\nf'{type(StoreFactory).__name__}. {type(factory).__name__} '\n'is not supported.',\n)\nelse:\nname = val\nif name in _stores:\nreturn _stores[name]\nreturn None\n</code></pre>"},{"location":"api/store/#proxystore.store.register_store","title":"register_store()","text":"<pre><code>register_store(\nstore: Store[Any], exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Register the store instance to the global registry.</p> Note <p>Global means globally accessible within the Python process.</p> <p>Parameters:</p> <ul> <li> store             (<code>Store[Any]</code>)         \u2013 <p>Store instance to register.</p> </li> <li> exist_ok             (<code>bool</code>)         \u2013 <p>If a store with the same name exists, overwrite it.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>StoreExistsError</code>           \u2013         <p>If a store with the same name is already registered and <code>exist_ok</code> is false.</p> </li> </ul> Source code in <code>proxystore/store/__init__.py</code> <pre><code>def register_store(store: Store[Any], exist_ok: bool = False) -&gt; None:\n\"\"\"Register the store instance to the global registry.\n    Note:\n        Global means globally accessible within the Python process.\n    Args:\n        store: Store instance to register.\n        exist_ok: If a store with the same name exists, overwrite it.\n    Raises:\n        StoreExistsError: If a store with the same name is already registered\n            and `exist_ok` is false.\n    \"\"\"\nif store.name in _stores and not exist_ok:\nraise StoreExistsError(f'A store named {store.name} already exists.')\n_stores[store.name] = store\nlogger.info(f'Registered a store named {store.name}')\n</code></pre>"},{"location":"api/store/#proxystore.store.unregister_store","title":"unregister_store()","text":"<pre><code>unregister_store(name_or_store: str | Store[Any]) -&gt; None\n</code></pre> <p>Unregisters the store instance from the global registry.</p> Note <p>This function is a no-op if no store matching the name exists (i.e., no exception will be raised).</p> <p>Parameters:</p> <ul> <li> name_or_store             (<code>str | Store[Any]</code>)         \u2013 <p>Name of the store to unregister or a store itself.</p> </li> </ul> Source code in <code>proxystore/store/__init__.py</code> <pre><code>def unregister_store(name_or_store: str | Store[Any]) -&gt; None:\n\"\"\"Unregisters the store instance from the global registry.\n    Note:\n        This function is a no-op if no store matching the name\n        exists (i.e., no exception will be raised).\n    Args:\n        name_or_store: Name of the store to unregister or a store itself.\n    \"\"\"\nname = (\nname_or_store if isinstance(name_or_store, str) else name_or_store.name\n)\nif name in _stores:\ndel _stores[name]\nlogger.debug(f'Unregistered a store named {name}')\n</code></pre>"},{"location":"api/store/base/","title":"proxystore.store.base","text":"<code>proxystore/store/base.py</code> <p>Store implementation.</p>"},{"location":"api/store/base/#proxystore.store.base.ConnectorT","title":"ConnectorT  <code>module-attribute</code>","text":"<pre><code>ConnectorT = TypeVar('ConnectorT', bound=Connector[Any])\n</code></pre> <p>Connector type variable.</p>"},{"location":"api/store/base/#proxystore.store.base.ConnectorKeyT","title":"ConnectorKeyT  <code>module-attribute</code>","text":"<pre><code>ConnectorKeyT = Tuple[Any, Ellipsis]\n</code></pre> <p>Connector key type alias.</p>"},{"location":"api/store/base/#proxystore.store.base.SerializerT","title":"SerializerT  <code>module-attribute</code>","text":"<pre><code>SerializerT = Callable[[Any], bytes]\n</code></pre> <p>Serializer type alias.</p>"},{"location":"api/store/base/#proxystore.store.base.DeserializerT","title":"DeserializerT  <code>module-attribute</code>","text":"<pre><code>DeserializerT = Callable[[bytes], Any]\n</code></pre> <p>Deserializer type alias.</p>"},{"location":"api/store/base/#proxystore.store.base.StoreFactory","title":"StoreFactory","text":"<pre><code>StoreFactory(\nkey: ConnectorKeyT,\nstore_config: dict[str, Any],\n*,\nevict: bool = False,\ndeserializer: DeserializerT | None = None,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[ConnectorT, T]</code></p> <p>Factory that resolves an object from a store.</p> <p>Adds support for asynchronously retrieving objects from a <code>Store</code> instance.</p> <p>The factory takes the <code>store_config</code> parameter that is used to reinitialize the store if the factory is sent to a remote process where the store has not already been initialized.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>Key corresponding to object in store.</p> </li> <li> store_config             (<code>dict[str, Any]</code>)         \u2013 <p>Store configuration used to reinitialize the store if needed.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If True, evict the object from the store once <code>resolve()</code> is called.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def __init__(\nself,\nkey: ConnectorKeyT,\nstore_config: dict[str, Any],\n*,\nevict: bool = False,\ndeserializer: DeserializerT | None = None,\nmetrics: bool = False,\n) -&gt; None:\nself.key = key\nself.store_config = store_config\nself.evict = evict\nself.deserializer = deserializer\nself.metrics = metrics\n# The following are not included when a factory is serialized\n# because they are specific to that instance of the factory\nself._obj_future: Future[T] | None = None\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.StoreFactory.get_store","title":"get_store()","text":"<pre><code>get_store() -&gt; Store[ConnectorT]\n</code></pre> <p>Get store and reinitialize if necessary.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the type of the returned store does not match the expected store type passed to the factory constructor.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def get_store(self) -&gt; Store[ConnectorT]:\n\"\"\"Get store and reinitialize if necessary.\n    Raises:\n        ValueError: If the type of the returned store does not match the\n            expected store type passed to the factory constructor.\n    \"\"\"\nstore = proxystore.store.get_store(self.store_config['name'])\nif store is None:\nstore = Store.from_config(self.store_config)\nproxystore.store.register_store(store)\nreturn store\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.StoreFactory.resolve","title":"resolve()","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Get object associated with key from store.</p> <p>Raises:</p> <ul> <li> <code>ProxyResolveMissingKeyError</code>           \u2013         <p>If the key associated with this factory does not exist in the store.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Get object associated with key from store.\n    Raises:\n        ProxyResolveMissingKeyError: If the key associated with this\n            factory does not exist in the store.\n    \"\"\"\nwith Timer() as timer:\nstore = self.get_store()\nobj = store.get(self.key, deserializer=self.deserializer)\nif obj is None:\nraise ProxyResolveMissingKeyError(\nself.key,\ntype(store),\nstore.name,\n)\nif self.evict:\nstore.evict(self.key)\nif store.metrics is not None:\ntotal_time = timer.elapsed_ns\nstore.metrics.add_time('factory.resolve', self.key, total_time)\nreturn cast(T, obj)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.StoreFactory.resolve_async","title":"resolve_async()","text":"<pre><code>resolve_async() -&gt; None\n</code></pre> <p>Asynchronously get object associated with key from store.</p> Source code in <code>proxystore/store/base.py</code> <pre><code>def resolve_async(self) -&gt; None:\n\"\"\"Asynchronously get object associated with key from store.\"\"\"\nlogger.debug(f'Starting asynchronous resolve of {self.key}')\nself._obj_future = _default_pool.submit(self.resolve)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store","title":"Store","text":"<pre><code>Store(\nname: str,\nconnector: ConnectorT,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[ConnectorT]</code></p> <p>Key-value store interface for proxies.</p> Tip <p>A <code>Store</code> instance can be used as a context manager which will automatically call <code>close()</code> on exit.</p> <pre><code>with Store('my-store', connector=...) as store:\nkey = store.set('value')\nstore.get(key)\n</code></pre> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> connector             (<code>ConnectorT</code>)         \u2013 <p>Connector instance to use for object storage.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>cache_size</code> is less than zero.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def __init__(\nself,\nname: str,\nconnector: ConnectorT,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nif cache_size &lt; 0:\nraise ValueError(\nf'Cache size cannot be negative. Got {cache_size}.',\n)\nself.connector = connector\nself.cache: LRUCache[ConnectorKeyT, Any] = LRUCache(cache_size)\nself._name = name\nself._metrics = StoreMetrics() if metrics else None\nself._cache_size = cache_size\nself._serializer = serializer\nself._deserializer = deserializer\nlogger.info(f'Initialized {self}')\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of this <code>Store</code> instance.</p>"},{"location":"api/store/base/#proxystore.store.base.Store.metrics","title":"metrics  <code>property</code>","text":"<pre><code>metrics: StoreMetrics | None\n</code></pre> <p>Optional metrics for this instance.</p>"},{"location":"api/store/base/#proxystore.store.base.Store.serializer","title":"serializer  <code>property</code>","text":"<pre><code>serializer: SerializerT\n</code></pre> <p>Serializer for this instance.</p>"},{"location":"api/store/base/#proxystore.store.base.Store.deserializer","title":"deserializer  <code>property</code>","text":"<pre><code>deserializer: DeserializerT\n</code></pre> <p>Deserializer for this instance.</p>"},{"location":"api/store/base/#proxystore.store.base.Store.close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connector associated with the store.</p> Warning <p>This method should only be called at the end of the program when the store will no longer be used, for example once all proxies have been resolved.</p> Source code in <code>proxystore/store/base.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connector associated with the store.\n    Warning:\n        This method should only be called at the end of the program\n        when the store will no longer be used, for example once all\n        proxies have been resolved.\n    \"\"\"\nself.connector.close()\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the store configuration.</p> Example <pre><code>&gt;&gt;&gt; store = Store(...)\n&gt;&gt;&gt; config = store.config()\n&gt;&gt;&gt; store = Store.from_config(config)\n</code></pre> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>Store configuration.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n\"\"\"Get the store configuration.\n    Example:\n        ```python\n        &gt;&gt;&gt; store = Store(...)\n        &gt;&gt;&gt; config = store.config()\n        &gt;&gt;&gt; store = Store.from_config(config)\n        ```\n    Returns:\n        Store configuration.\n    \"\"\"\nreturn {\n'name': self.name,\n'connector_type': get_class_path(type(self.connector)),\n'connector_config': self.connector.config(),\n'serializer': self._serializer,\n'deserializer': self._deserializer,\n'cache_size': self._cache_size,\n'metrics': self.metrics is not None,\n}\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; Store[Any]\n</code></pre> <p>Create a new store instance from a configuration.</p> <p>Parameters:</p> <ul> <li> config             (<code>dict[str, Any]</code>)         \u2013 <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Store[Any]</code>         \u2013 <p>Store instance.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; Store[Any]:\n\"\"\"Create a new store instance from a configuration.\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    Returns:\n        Store instance.\n    \"\"\"\nconnector_type = config.pop('connector_type')\nconnector_config = config.pop('connector_config')\nconnector = import_class(connector_type)\nconfig['connector'] = connector.from_config(connector_config)\nreturn cls(**config)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.evict","title":"evict()","text":"<pre><code>evict(key: ConnectorKeyT) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def evict(self, key: ConnectorKeyT) -&gt; None:\n\"\"\"Evict the object associated with the key.\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\nwith Timer() as timer:\nwith Timer() as connector_timer:\nself.connector.evict(key)\nif self.metrics is not None:\nctime = connector_timer.elapsed_ns\nself.metrics.add_time('store.evict.connector', key, ctime)\nself.cache.evict(key)\nif self.metrics is not None:\nself.metrics.add_time('store.evict', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): EVICT {key} in '\nf'{timer.elapsed_ms:.3f} ms',\n)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.exists","title":"exists()","text":"<pre><code>exists(key: ConnectorKeyT) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def exists(self, key: ConnectorKeyT) -&gt; bool:\n\"\"\"Check if an object associated with the key exists.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\nwith Timer() as timer:\nres = self.cache.exists(key)\nif not res:\nwith Timer() as connector_timer:\nres = self.connector.exists(key)\nif self.metrics is not None:\nctime = connector_timer.elapsed_ns\nself.metrics.add_time('store.exists.connector', key, ctime)\nif self.metrics is not None:\nself.metrics.add_time('store.exists', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): EXISTS {key} in '\nf'{timer.elapsed_ms:.3f} ms',\n)\nreturn res\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.get","title":"get()","text":"<pre><code>get(\nkey: ConnectorKeyT,\n*,\ndeserializer: DeserializerT | None = None,\ndefault: object | None = None\n) -&gt; Any | None\n</code></pre> <p>Get the object associated with the key.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>Key associated with the object to retrieve.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optionally override the default deserializer for the store instance.</p> </li> <li> default             (<code>object | None</code>)         \u2013 <p>An optional value to be returned if an object associated with the key does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any | None</code>         \u2013 <p>Object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def get(\nself,\nkey: ConnectorKeyT,\n*,\ndeserializer: DeserializerT | None = None,\ndefault: object | None = None,\n) -&gt; Any | None:\n\"\"\"Get the object associated with the key.\n    Args:\n        key: Key associated with the object to retrieve.\n        deserializer: Optionally override the default deserializer for the\n            store instance.\n        default: An optional value to be returned if an object\n            associated with the key does not exist.\n    Returns:\n        Object or `None` if the object does not exist.\n    \"\"\"\ntimer = Timer()\ntimer.start()\nif self.is_cached(key):\nvalue = self.cache.get(key)\ntimer.stop()\nif self.metrics is not None:\nself.metrics.add_counter('store.get.cache_hits', key, 1)\nself.metrics.add_time('store.get', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): GET {key} in '\nf'{timer.elapsed_ms:.3f} ms (cached=True)',\n)\nreturn value\nwith Timer() as connector_timer:\nvalue = self.connector.get(key)\nif self.metrics is not None:\nctime = connector_timer.elapsed_ns\nself.metrics.add_counter('store.get.cache_misses', key, 1)\nself.metrics.add_time('store.get.connector', key, ctime)\nif value is not None:\nwith Timer() as deserializer_timer:\nif deserializer is not None:\nresult = deserializer(value)\nelse:\nresult = self.deserializer(value)\nif self.metrics is not None:\ndtime = deserializer_timer.elapsed_ns\nobj_size = len(value)\nself.metrics.add_time('store.get.deserialize', key, dtime)\nself.metrics.add_attribute(\n'store.get.object_size',\nkey,\nobj_size,\n)\nself.cache.set(key, result)\nelse:\nresult = default\ntimer.stop()\nif self.metrics is not None:\nself.metrics.add_time('store.get', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): GET {key} in '\nf'{timer.elapsed_ms:.3f} ms (cached=False)',\n)\nreturn result\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.is_cached","title":"is_cached()","text":"<pre><code>is_cached(key: ConnectorKeyT) -&gt; bool\n</code></pre> <p>Check if an object associated with the key is cached locally.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the object is cached.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def is_cached(self, key: ConnectorKeyT) -&gt; bool:\n\"\"\"Check if an object associated with the key is cached locally.\n    Args:\n        key: Key potentially associated with stored object.\n    Returns:\n        If the object is cached.\n    \"\"\"\nreturn self.cache.exists(key)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.proxy","title":"proxy()","text":"<pre><code>proxy(\nobj: T,\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any\n) -&gt; Proxy[T]\n</code></pre> <p>Create a proxy that will resolve to an object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T</code>)         \u2013 <p>The object to place in store and return a proxy for.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If the proxy should evict the object once resolved.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optionally override the default serializer for the store instance.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optionally override the default deserializer for the store instance.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional keyword arguments to pass to <code>Connector.put()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Proxy[T]</code>         \u2013 <p>A proxy of the object.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def proxy(\nself,\nobj: T,\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any,\n) -&gt; Proxy[T]:\n\"\"\"Create a proxy that will resolve to an object in the store.\n    Args:\n        obj: The object to place in store and return a proxy for.\n        evict: If the proxy should evict the object once resolved.\n        serializer: Optionally override the default serializer for the\n            store instance.\n        deserializer: Optionally override the default deserializer for the\n            store instance.\n        kwargs: Additional keyword arguments to pass to\n            [`Connector.put()`][proxystore.connectors.connector.Connector.put].\n    Returns:\n        A proxy of the object.\n    \"\"\"\nwith Timer() as timer:\nkey = self.set(obj, serializer=serializer, **kwargs)\nfactory: StoreFactory[ConnectorT, T] = StoreFactory(\nkey,\nstore_config=self.config(),\ndeserializer=deserializer,\nevict=evict,\nmetrics=self.metrics is not None,\n)\nproxy = Proxy(factory)\nif self.metrics is not None:\nself.metrics.add_time('store.proxy', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): PROXY {key} in '\nf'{timer.elapsed_ms:.3f} ms',\n)\nreturn proxy\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.proxy_batch","title":"proxy_batch()","text":"<pre><code>proxy_batch(\nobjs: Sequence[T],\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any\n) -&gt; list[Proxy[T]]\n</code></pre> <p>Create proxies that will resolve to an object in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[T]</code>)         \u2013 <p>The objects to place in store and return a proxies for.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If a proxy should evict its object once resolved.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optionally override the default serializer for the store instance.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optionally override the default deserializer for the store instance.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional keyword arguments to pass to <code>Connector.put_batch()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Proxy[T]]</code>         \u2013 <p>A list of proxies of the objects.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def proxy_batch(\nself,\nobjs: Sequence[T],\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any,\n) -&gt; list[Proxy[T]]:\n\"\"\"Create proxies that will resolve to an object in the store.\n    Args:\n        objs: The objects to place in store and return a proxies for.\n        evict: If a proxy should evict its object once resolved.\n        serializer: Optionally override the default serializer for the\n            store instance.\n        deserializer: Optionally override the default deserializer for the\n            store instance.\n        kwargs: Additional keyword arguments to pass to\n            [`Connector.put_batch()`][proxystore.connectors.connector.Connector.put_batch].\n    Returns:\n        A list of proxies of the objects.\n    \"\"\"\nwith Timer() as timer:\nkeys = self.set_batch(objs, serializer=serializer, **kwargs)\nproxies: list[Proxy[T]] = [\nself.proxy_from_key(\nkey,\nevict=evict,\ndeserializer=deserializer,\n)\nfor key in keys\n]\nif self.metrics is not None:\nself.metrics.add_time('store.proxy_batch', keys, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): PROXY_BATCH ({len(proxies)} items) '\nf'in {timer.elapsed_ms:.3f} ms',\n)\nreturn proxies\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.proxy_from_key","title":"proxy_from_key()","text":"<pre><code>proxy_from_key(\nkey: ConnectorKeyT,\n*,\nevict: bool = False,\ndeserializer: DeserializerT | None = None\n) -&gt; Proxy[T]\n</code></pre> <p>Create a proxy that will resolve to an object already in the store.</p> <p>Parameters:</p> <ul> <li> key             (<code>ConnectorKeyT</code>)         \u2013 <p>The key associated with an object already in the store.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If the proxy should evict the object once resolved.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optionally override the default deserializer for the store instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Proxy[T]</code>         \u2013 <p>A proxy of the object.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def proxy_from_key(\nself,\nkey: ConnectorKeyT,\n*,\nevict: bool = False,\ndeserializer: DeserializerT | None = None,\n) -&gt; Proxy[T]:\n\"\"\"Create a proxy that will resolve to an object already in the store.\n    Args:\n        key: The key associated with an object already in the store.\n        evict: If the proxy should evict the object once resolved.\n        deserializer: Optionally override the default deserializer for the\n            store instance.\n    Returns:\n        A proxy of the object.\n    \"\"\"\nfactory: StoreFactory[ConnectorT, T] = StoreFactory(\nkey,\nstore_config=self.config(),\ndeserializer=deserializer,\nevict=evict,\nmetrics=self.metrics is not None,\n)\nlogger.debug(f'Store(name=\"{self.name}\"): PROXY_FROM_KEY {key}')\nreturn Proxy(factory)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.locked_proxy","title":"locked_proxy()","text":"<pre><code>locked_proxy(\nobj: T,\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any\n) -&gt; ProxyLocker[T]\n</code></pre> <p>Proxy an object and return <code>ProxyLocker</code>.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T</code>)         \u2013 <p>The object to place in store and return a proxy for.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If the proxy should evict the object once resolved.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optionally override the default serializer for the store instance.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optionally override the default deserializer for the store instance.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional keyword arguments to pass to <code>Connector.put()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ProxyLocker[T]</code>         \u2013 <p>A proxy wrapped in a <code>ProxyLocker</code>.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def locked_proxy(\nself,\nobj: T,\n*,\nevict: bool = False,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any,\n) -&gt; ProxyLocker[T]:\n\"\"\"Proxy an object and return [`ProxyLocker`][proxystore.proxy.ProxyLocker].\n    Args:\n        obj: The object to place in store and return a proxy for.\n        evict: If the proxy should evict the object once resolved.\n        serializer: Optionally override the default serializer for the\n            store instance.\n        deserializer: Optionally override the default deserializer for the\n            store instance.\n        kwargs: Additional keyword arguments to pass to\n            [`Connector.put()`][proxystore.connectors.connector.Connector.put].\n    Returns:\n        A proxy wrapped in a [`ProxyLocker`][proxystore.proxy.ProxyLocker].\n    \"\"\"\nreturn ProxyLocker(\nself.proxy(\nobj,\nevict=evict,\nserializer=serializer,\ndeserializer=deserializer,\n**kwargs,\n),\n)\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.set","title":"set()","text":"<pre><code>set(\nobj: Any,\n*,\nserializer: SerializerT | None = None,\n**kwargs: Any\n) -&gt; ConnectorKeyT\n</code></pre> <p>Put an object in the store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>Object to put in the store.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optionally override the default serializer for the store instance.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional keyword arguments to pass to <code>Connector.put()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorKeyT</code>         \u2013 <p>A key which can be used to retrieve the object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If the output of <code>serializer</code> is not bytes.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def set(\nself,\nobj: Any,\n*,\nserializer: SerializerT | None = None,\n**kwargs: Any,\n) -&gt; ConnectorKeyT:\n\"\"\"Put an object in the store.\n    Args:\n        obj: Object to put in the store.\n        serializer: Optionally override the default serializer for the\n            store instance.\n        kwargs: Additional keyword arguments to pass to\n            [`Connector.put()`][proxystore.connectors.connector.Connector.put].\n    Returns:\n        A key which can be used to retrieve the object.\n    Raises:\n        TypeError: If the output of `serializer` is not bytes.\n    \"\"\"\ntimer = Timer()\ntimer.start()\nwith Timer() as serialize_timer:\nif serializer is not None:\nobj = serializer(obj)\nelse:\nobj = self.serializer(obj)\nif not isinstance(obj, bytes):\nraise TypeError('Serializer must produce bytes.')\nwith Timer() as connector_timer:\nkey = self.connector.put(obj, **kwargs)\ntimer.stop()\nif self.metrics is not None:\nctime = connector_timer.elapsed_ns\nstime = serialize_timer.elapsed_ns\nself.metrics.add_attribute('store.set.object_size', key, len(obj))\nself.metrics.add_time('store.set.serialize', key, stime)\nself.metrics.add_time('store.set.connector', key, ctime)\nself.metrics.add_time('store.set', key, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): SET {key} in '\nf'{timer.elapsed_ms:.3f} ms',\n)\nreturn key\n</code></pre>"},{"location":"api/store/base/#proxystore.store.base.Store.set_batch","title":"set_batch()","text":"<pre><code>set_batch(\nobjs: Sequence[Any],\n*,\nserializer: SerializerT | None = None,\n**kwargs: Any\n) -&gt; list[ConnectorKeyT]\n</code></pre> <p>Put multiple objects in the store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[Any]</code>)         \u2013 <p>Sequence of objects to put in the store.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optionally override the default serializer for the store instance.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional keyword arguments to pass to <code>Connector.put_batch()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ConnectorKeyT]</code>         \u2013 <p>A list of keys which can be used to retrieve the objects.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If the output of <code>serializer</code> is not bytes.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def set_batch(\nself,\nobjs: Sequence[Any],\n*,\nserializer: SerializerT | None = None,\n**kwargs: Any,\n) -&gt; list[ConnectorKeyT]:\n\"\"\"Put multiple objects in the store.\n    Args:\n        objs: Sequence of objects to put in the store.\n        serializer: Optionally override the default serializer for the\n            store instance.\n        kwargs: Additional keyword arguments to pass to\n            [`Connector.put_batch()`][proxystore.connectors.connector.Connector.put_batch].\n    Returns:\n        A list of keys which can be used to retrieve the objects.\n    Raises:\n        TypeError: If the output of `serializer` is not bytes.\n    \"\"\"\ntimer = Timer()\ntimer.start()\ndef _serialize(obj: Any) -&gt; bytes:\nif serializer is not None:\nobj = serializer(obj)\nelse:\nobj = self.serializer(obj)\nif not isinstance(obj, bytes):\nraise TypeError('Serializer must produce bytes.')\nreturn obj\nwith Timer() as serialize_timer:\n_objs = list(map(_serialize, objs))\nwith Timer() as connector_timer:\nkeys = self.connector.put_batch(_objs, **kwargs)\ntimer.stop()\nif self.metrics is not None:\nctime = connector_timer.elapsed_ns\nstime = serialize_timer.elapsed_ns\nsizes = sum(len(obj) for obj in _objs)\nself.metrics.add_attribute(\n'store.set_batch.object_sizes',\nkeys,\nsizes,\n)\nself.metrics.add_time('store.set_batch.serialize', keys, stime)\nself.metrics.add_time('store.set_batch.connector', keys, ctime)\nself.metrics.add_time('store.set_batch', keys, timer.elapsed_ns)\nlogger.debug(\nf'Store(name=\"{self.name}\"): SET_BATCH ({len(keys)} items) in '\nf'{timer.elapsed_ms:.3f} ms',\n)\nreturn keys\n</code></pre>"},{"location":"api/store/cache/","title":"proxystore.store.cache","text":"<code>proxystore/store/cache.py</code> <p>Simple Cache Implementation.</p>"},{"location":"api/store/cache/#proxystore.store.cache.LRUCache","title":"LRUCache","text":"<pre><code>LRUCache(maxsize: int = 16) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[KeyT, ValueT]</code></p> <p>Simple LRU Cache.</p> <p>Parameters:</p> <ul> <li> maxsize             (<code>int</code>)         \u2013 <p>Maximum number of value to cache.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>maxsize &lt;= 0</code>.</p> </li> </ul> Source code in <code>proxystore/store/cache.py</code> <pre><code>def __init__(self, maxsize: int = 16) -&gt; None:\nif maxsize &lt; 0:\nraise ValueError('Cache size must by &gt;= 0')\nself.maxsize = maxsize\nself.data: dict[KeyT, ValueT] = {}\nself.lru: list[KeyT] = []\n# Count hits/misses\nself.hits = 0\nself.misses = 0\n</code></pre>"},{"location":"api/store/cache/#proxystore.store.cache.LRUCache.evict","title":"evict()","text":"<pre><code>evict(key: KeyT) -&gt; None\n</code></pre> <p>Evict key from cache.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def evict(self, key: KeyT) -&gt; None:\n\"\"\"Evict key from cache.\"\"\"\nif key in self.data:\ndel self.data[key]\nself.lru.remove(key)\n</code></pre>"},{"location":"api/store/cache/#proxystore.store.cache.LRUCache.exists","title":"exists()","text":"<pre><code>exists(key: KeyT) -&gt; bool\n</code></pre> <p>Check if key is in cache.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def exists(self, key: KeyT) -&gt; bool:\n\"\"\"Check if key is in cache.\"\"\"\nreturn key in self.data\n</code></pre>"},{"location":"api/store/cache/#proxystore.store.cache.LRUCache.get","title":"get()","text":"<pre><code>get(\nkey: KeyT, default: ValueT | None = None\n) -&gt; ValueT | None\n</code></pre> <p>Get value for key if it exists else returns default.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def get(self, key: KeyT, default: ValueT | None = None) -&gt; ValueT | None:\n\"\"\"Get value for key if it exists else returns default.\"\"\"\nif self.exists(key):\n# Move to front b/c most recently used\nself.hits += 1\nself.lru.remove(key)\nself.lru.insert(0, key)\nreturn self.data[key]\nelse:\nself.misses += 1\nreturn default\n</code></pre>"},{"location":"api/store/cache/#proxystore.store.cache.LRUCache.set","title":"set()","text":"<pre><code>set(key: KeyT, value: ValueT) -&gt; None\n</code></pre> <p>Set key to value.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def set(self, key: KeyT, value: ValueT) -&gt; None:\n\"\"\"Set key to value.\"\"\"\nif self.maxsize == 0:\nreturn\nif len(self.data) &gt;= self.maxsize:\nlru_key = self.lru.pop()\ndel self.data[lru_key]\nself.lru.insert(0, key)\nself.data[key] = value\n</code></pre>"},{"location":"api/store/endpoint/","title":"proxystore.store.endpoint","text":"<code>proxystore/store/endpoint.py</code> <p>EndpointStore Implementation.</p>"},{"location":"api/store/endpoint/#proxystore.store.endpoint.EndpointStore","title":"EndpointStore","text":"<pre><code>EndpointStore(\nname: str,\nendpoints: Sequence[str | uuid.UUID],\nproxystore_dir: str | None = None,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[EndpointConnector]</code></p> <p>Store wrapper for ProxyStore Endpoints.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance (default: None).</p> </li> <li> endpoints             (<code>Sequence[str | uuid.UUID]</code>)         \u2013 <p>Sequence of valid and running endpoint UUIDs to use. At least one of these endpoints must be accessible by this process.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to [<code>home_dir()</code>[proxystore.utils.home_dir].</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/endpoint.py</code> <pre><code>def __init__(\nself,\nname: str,\nendpoints: Sequence[str | uuid.UUID],\nproxystore_dir: str | None = None,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The EndpointStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = EndpointConnector(\nendpoints=endpoints,\nproxystore_dir=proxystore_dir,\n)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/exceptions/","title":"proxystore.store.exceptions","text":"<code>proxystore/store/exceptions.py</code> <p>Exceptions for Stores.</p>"},{"location":"api/store/exceptions/#proxystore.store.exceptions.StoreError","title":"StoreError","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception class for store errors.</p>"},{"location":"api/store/exceptions/#proxystore.store.exceptions.StoreExistsError","title":"StoreExistsError","text":"<p>         Bases: <code>StoreError</code></p> <p>Exception raised when a store with the same name already exists.</p>"},{"location":"api/store/exceptions/#proxystore.store.exceptions.ProxyStoreFactoryError","title":"ProxyStoreFactoryError","text":"<p>         Bases: <code>StoreError</code></p> <p>Exception raised when a proxy was not created by a Store.</p>"},{"location":"api/store/exceptions/#proxystore.store.exceptions.ProxyResolveMissingKeyError","title":"ProxyResolveMissingKeyError","text":"<pre><code>ProxyResolveMissingKeyError(\nkey: base.ConnectorKeyT,\nstore_type: type[base.Store[Any]],\nstore_name: str,\n) -&gt; None\n</code></pre> <p>         Bases: <code>Exception</code></p> <p>Exception raised when the key associated with a proxy is missing.</p> <p>Init ProxyResolveMissingKeyError.</p> <p>Parameters:</p> <ul> <li> key             (<code>base.ConnectorKeyT</code>)         \u2013 <p>Key associated with target object that could not be found in the store.</p> </li> <li> store_type             (<code>type[base.Store[Any]]</code>)         \u2013 <p>Type of store that the key could not be found in.</p> </li> <li> store_name             (<code>str</code>)         \u2013 <p>Name of store that the key could not be found in.</p> </li> </ul> Source code in <code>proxystore/store/exceptions.py</code> <pre><code>def __init__(\nself,\nkey: base.ConnectorKeyT,\nstore_type: type[base.Store[Any]],\nstore_name: str,\n) -&gt; None:\n\"\"\"Init ProxyResolveMissingKeyError.\n    Args:\n        key: Key associated with target object that could not be found in\n            the store.\n        store_type: Type of store that the key could not be found in.\n        store_name: Name of store that the key could not be found in.\n    \"\"\"\nself.key = key\nself.store_type = store_type\nself.store_name = store_name\nsuper().__init__(\nf\"Proxy cannot resolve target object with key='{self.key}' \"\nf\"from {self.store_type.__name__}(name='{self.store_name}'): \"\n'store returned NoneType with key.',\n)\n</code></pre>"},{"location":"api/store/file/","title":"proxystore.store.file","text":"<code>proxystore/store/file.py</code> <p>FileStore Implementation.</p>"},{"location":"api/store/file/#proxystore.store.file.FileStore","title":"FileStore","text":"<pre><code>FileStore(\nname: str,\nstore_dir: str,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[FileConnector]</code></p> <p>Store wrapper for shared filesystems.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> store_dir             (<code>str</code>)         \u2013 <p>Path to directory to store data in. Note this directory will be deleted upon closing the store.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/file.py</code> <pre><code>def __init__(\nself,\nname: str,\nstore_dir: str,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The FileStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = FileConnector(store_dir)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/globus/","title":"proxystore.store.globus","text":"<code>proxystore/store/globus.py</code> <p>GlobusStore Implementation.</p>"},{"location":"api/store/globus/#proxystore.store.globus.GlobusStore","title":"GlobusStore","text":"<pre><code>GlobusStore(\nname: str,\nendpoints: GlobusEndpoints\n| list[GlobusEndpoint]\n| dict[str, dict[str, str]],\npolling_interval: int = 1,\nsync_level: int\n| Literal[exists, size, mtime, checksum] = \"mtime\",\ntimeout: int = 60,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[GlobusConnector]</code></p> <p>Store wrapper for Globus transfers.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> endpoints             (<code>GlobusEndpoints | list[GlobusEndpoint] | dict[str, dict[str, str]]</code>)         \u2013 <p>Globus endpoints to keep in sync. If passed as a <code>dict</code>, the dictionary must match the format expected by <code>GlobusEndpoints.from_dict()</code>.</p> </li> <li> polling_interval             (<code>int</code>)         \u2013 <p>Interval in seconds to check if Globus tasks have finished.</p> </li> <li> sync_level             (<code>int | Literal[exists, size, mtime, checksum]</code>)         \u2013 <p>Globus transfer sync level.</p> </li> <li> timeout             (<code>int</code>)         \u2013 <p>Timeout in seconds for waiting on Globus tasks.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/globus.py</code> <pre><code>def __init__(\nself,\nname: str,\nendpoints: GlobusEndpoints\n| list[GlobusEndpoint]\n| dict[str, dict[str, str]],\npolling_interval: int = 1,\nsync_level: int\n| Literal['exists', 'size', 'mtime', 'checksum'] = 'mtime',\ntimeout: int = 60,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The GlobusStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = GlobusConnector(\nendpoints=endpoints,\npolling_interval=polling_interval,\nsync_level=sync_level,\ntimeout=timeout,\n)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/local/","title":"proxystore.store.local","text":"<code>proxystore/store/local.py</code> <p>LocalStore Implementation.</p>"},{"location":"api/store/local/#proxystore.store.local.LocalStore","title":"LocalStore","text":"<pre><code>LocalStore(\nname: str,\nstore_dict: dict[LocalKey, bytes] | None = None,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[LocalConnector]</code></p> <p>Store wrapper for local in-process storage.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> store_dict             (<code>dict[LocalKey, bytes] | None</code>)         \u2013 <p>Dictionary to store data in. If not specified, a new empty dict will be generated.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/local.py</code> <pre><code>def __init__(\nself,\nname: str,\nstore_dict: dict[LocalKey, bytes] | None = None,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The LocalStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = LocalConnector(store_dict)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/metrics/","title":"proxystore.store.metrics","text":"<code>proxystore/store/metrics.py</code> <p>Utilities for recording Store operation metrics.</p> <p>See the Performance Guide to learn more about interacting with metrics recorded for <code>Store</code> operations.</p>"},{"location":"api/store/metrics/#proxystore.store.metrics.KeyT","title":"KeyT  <code>module-attribute</code>","text":"<pre><code>KeyT = Union[ConnectorKeyT, Sequence[ConnectorKeyT]]\n</code></pre> <p>Key types supported by <code>StoreMetrics</code>.</p>"},{"location":"api/store/metrics/#proxystore.store.metrics.ProxyT","title":"ProxyT  <code>module-attribute</code>","text":"<pre><code>ProxyT = Union[Proxy[Any], Sequence[Proxy[Any]]]\n</code></pre> <p>Proxy types supported by <code>StoreMetrics</code>.</p> <p>When a <code>ProxyT</code> is passed, the keys are extracted from the proxies.</p>"},{"location":"api/store/metrics/#proxystore.store.metrics.TimeStats","title":"TimeStats  <code>dataclass</code>","text":"<p>Tracks time statistics of a reoccuring event.</p>"},{"location":"api/store/metrics/#proxystore.store.metrics.TimeStats.as_dict","title":"as_dict()","text":"<pre><code>as_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the dataclass to a <code>dict</code>.</p> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Convert the dataclass to a [`dict`][dict].\"\"\"\nreturn dataclasses.asdict(self)\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.Metrics","title":"Metrics  <code>dataclass</code>","text":"<p>Records metrics and attributes for events.</p>"},{"location":"api/store/metrics/#proxystore.store.metrics.Metrics.as_dict","title":"as_dict()","text":"<pre><code>as_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the dataclass to a <code>dict</code>.</p> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n\"\"\"Convert the dataclass to a [`dict`][dict].\"\"\"\nreturn dataclasses.asdict(self)\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics","title":"StoreMetrics","text":"<pre><code>StoreMetrics() -&gt; None\n</code></pre> <p>Record and query metrics on <code>Store</code> operations.</p> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def __init__(self) -&gt; None:\nself._metrics: dict[int, Metrics] = defaultdict(Metrics)\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics.add_attribute","title":"add_attribute()","text":"<pre><code>add_attribute(name: str, key: KeyT, value: Any) -&gt; None\n</code></pre> <p>Add an attribute associated with the key.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of attribute.</p> </li> <li> key             (<code>KeyT</code>)         \u2013 <p>Key to add attribute to.</p> </li> <li> value             (<code>Any</code>)         \u2013 <p>Attribute value.</p> </li> </ul> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def add_attribute(self, name: str, key: KeyT, value: Any) -&gt; None:\n\"\"\"Add an attribute associated with the key.\n    Args:\n        name: Name of attribute.\n        key: Key to add attribute to.\n        value: Attribute value.\n    \"\"\"\nself._metrics[_hash_key(key)].attributes[name] = value\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics.add_counter","title":"add_counter()","text":"<pre><code>add_counter(name: str, key: KeyT, value: int) -&gt; None\n</code></pre> <p>Add to a counter.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of counter.</p> </li> <li> key             (<code>KeyT</code>)         \u2013 <p>Key associated with the counter.</p> </li> <li> value             (<code>int</code>)         \u2013 <p>Amount to increment counter by.</p> </li> </ul> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def add_counter(self, name: str, key: KeyT, value: int) -&gt; None:\n\"\"\"Add to a counter.\n    Args:\n        name: Name of counter.\n        key: Key associated with the counter.\n        value: Amount to increment counter by.\n    \"\"\"\ncounters = self._metrics[_hash_key(key)].counters\nif name in counters:\ncounters[name] += value\nelse:\ncounters[name] = value\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics.add_time","title":"add_time()","text":"<pre><code>add_time(name: str, key: KeyT, time_ns: int) -&gt; None\n</code></pre> <p>Record a new time for an event.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Event or operation the time is for.</p> </li> <li> key             (<code>KeyT</code>)         \u2013 <p>Key associated with the event.</p> </li> <li> time_ns             (<code>int</code>)         \u2013 <p>The time in nanoseconds of the event.</p> </li> </ul> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def add_time(self, name: str, key: KeyT, time_ns: int) -&gt; None:\n\"\"\"Record a new time for an event.\n    Args:\n        name: Event or operation the time is for.\n        key: Key associated with the event.\n        time_ns: The time in nanoseconds of the event.\n    \"\"\"\ntimes = self._metrics[_hash_key(key)].times\nif name not in times:\ntimes[name] = TimeStats()\ntimes[name].add_time(time_ns / 1000)\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics.aggregate_times","title":"aggregate_times()","text":"<pre><code>aggregate_times() -&gt; dict[str, TimeStats]\n</code></pre> <p>Aggregate time statistics over all keys.</p> <p>Returns:</p> <ul> <li> <code>dict[str, TimeStats]</code>         \u2013 <p>Dictionary mapping event names to the time statistics aggregated</p> </li> <li> <code>dict[str, TimeStats]</code>         \u2013 <p>for that event.</p> </li> </ul> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def aggregate_times(self) -&gt; dict[str, TimeStats]:\n\"\"\"Aggregate time statistics over all keys.\n    Returns:\n        Dictionary mapping event names to the time statistics aggregated\n        for that event.\n    \"\"\"\ntimes: dict[str, TimeStats] = defaultdict(TimeStats)\nfor metrics in self._metrics.values():\nfor key, value in metrics.times.items():\ntimes[key] += value\nreturn times\n</code></pre>"},{"location":"api/store/metrics/#proxystore.store.metrics.StoreMetrics.get_metrics","title":"get_metrics()","text":"<pre><code>get_metrics(key_or_proxy: KeyT | ProxyT) -&gt; Metrics | None\n</code></pre> <p>Get the metrics associated with a key.</p> <p>Parameters:</p> <ul> <li> key_or_proxy             (<code>KeyT | ProxyT</code>)         \u2013 <p>Key to get associated metrics. If a proxy or sequence of proxies, the key(s) will be extracted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Metrics | None</code>         \u2013 <p>Metrics associated with the key or <code>None</code> if the key does not</p> </li> <li> <code>Metrics | None</code>         \u2013 <p>exist.</p> </li> </ul> Source code in <code>proxystore/store/metrics.py</code> <pre><code>def get_metrics(self, key_or_proxy: KeyT | ProxyT) -&gt; Metrics | None:\n\"\"\"Get the metrics associated with a key.\n    Args:\n        key_or_proxy: Key to get associated metrics. If a proxy or\n            sequence of proxies, the key(s) will be extracted.\n    Returns:\n        Metrics associated with the key or `None` if the key does not\n        exist.\n    \"\"\"\nkey_hash = _hash_key(key_or_proxy)\nif key_hash in self._metrics:\nreturn copy.deepcopy(self._metrics[key_hash])\nreturn None\n</code></pre>"},{"location":"api/store/multi/","title":"proxystore.store.multi","text":"<code>proxystore/store/multi.py</code> <p>MultiStore Implementation.</p>"},{"location":"api/store/multi/#proxystore.store.multi.MultiStore","title":"MultiStore","text":"<pre><code>MultiStore(\nname: str,\nconnectors: dict[str, tuple[Connector[Any], Policy]],\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[MultiConnector]</code></p> <p>Store wrapper for <code>MultiConnector</code>.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> connectors             (<code>dict[str, tuple[Connector[Any], Policy]]</code>)         \u2013 <p>Mapping of names to tuples of a <code>Connector</code> and <code>Policy</code>.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/multi.py</code> <pre><code>def __init__(\nself,\nname: str,\nconnectors: dict[str, tuple[Connector[Any], Policy]],\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The MultiStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = MultiConnector(connectors)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/redis/","title":"proxystore.store.redis","text":"<code>proxystore/store/redis.py</code> <p>RedisStore Implementation.</p>"},{"location":"api/store/redis/#proxystore.store.redis.RedisStore","title":"RedisStore","text":"<pre><code>RedisStore(\nname: str,\nhostname: str,\nport: int,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[RedisConnector]</code></p> <p>Store wrapper for Redis servers.</p> Warning <p>This wrapper exists for backwards compatibility with ProxyStore &lt;=0.4.* and will be deprecated in version 0.6.0.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> hostname             (<code>str</code>)         \u2013 <p>Redis server hostname.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Redis server port.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> metrics             (<code>bool</code>)         \u2013 <p>Enable recording operation metrics.</p> </li> </ul> Source code in <code>proxystore/store/redis.py</code> <pre><code>def __init__(\nself,\nname: str,\nhostname: str,\nport: int,\n*,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\ncache_size: int = 16,\nmetrics: bool = False,\n) -&gt; None:\nwarnings.warn(\n'The RedisStore will be deprecated in v0.6.0. Initializing a '\n'Store with a Connector is preferred. See '\n'https://github.com/proxystore/proxystore/issues/214 for details.',\nDeprecationWarning,\nstacklevel=2,\n)\nconnector = RedisConnector(hostname, port)\nsuper().__init__(\nname,\nconnector,\nserializer=serializer,\ndeserializer=deserializer,\ncache_size=cache_size,\nmetrics=metrics,\n)\n</code></pre>"},{"location":"api/store/utils/","title":"proxystore.store.utils","text":"<code>proxystore/store/utils.py</code> <p>Store utilities.</p>"},{"location":"api/store/utils/#proxystore.store.utils.get_key","title":"get_key()","text":"<pre><code>get_key(proxy: Proxy[T]) -&gt; ConnectorKeyT\n</code></pre> <p>Extract the key from the proxy's factory.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>Proxy[T]</code>)         \u2013 <p>Proxy instance to get key from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorKeyT</code>         \u2013 <p>The key, a NamedTuple unique to the</p> </li> <li> <code>ConnectorKeyT</code>         \u2013 <p><code>Store</code> that created the proxy..</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ProxyStoreFactoryError</code>           \u2013         <p>If the proxy's factory is not an instance of <code>StoreFactory</code>.</p> </li> </ul> Source code in <code>proxystore/store/utils.py</code> <pre><code>def get_key(proxy: Proxy[T]) -&gt; ConnectorKeyT:\n\"\"\"Extract the key from the proxy's factory.\n    Args:\n        proxy: Proxy instance to get key from.\n    Returns:\n        The key, a NamedTuple unique to the\n        [`Store`][proxystore.store.base.Store] that created the proxy..\n    Raises:\n        ProxyStoreFactoryError: If the proxy's factory is not an instance of\n            [`StoreFactory`][proxystore.store.base.StoreFactory].\n    \"\"\"\nfactory = proxy.__factory__\nif isinstance(factory, base.StoreFactory):\nreturn factory.key\nelse:\nraise ProxyStoreFactoryError(\n'The proxy must contain a factory with type '\nf'{type(base.StoreFactory).__name__}. {type(factory).__name__} '\n'is not supported.',\n)\n</code></pre>"},{"location":"api/store/utils/#proxystore.store.utils.resolve_async","title":"resolve_async()","text":"<pre><code>resolve_async(proxy: Proxy[T]) -&gt; None\n</code></pre> <p>Begin resolving proxy asynchronously.</p> <p>Useful if the user knows a proxy will be needed soon and wants to resolve the proxy concurrently with other computation.</p> <pre><code>from proxystore.store.utils import resolve_async\nresolve_async(my_proxy)\ncomputation_without_proxy(...)\n# p is hopefully resolved\ncomputation_with_proxy(my_proxy, ...)\n</code></pre> Note <p>The asynchronous resolving functionality is implemented by <code>StoreFactory</code>. Factories that are not of this type will error when used with this function.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>Proxy[T]</code>)         \u2013 <p>Proxy instance to begin asynchronously resolving.</p> </li> </ul> Source code in <code>proxystore/store/utils.py</code> <pre><code>def resolve_async(proxy: Proxy[T]) -&gt; None:\n\"\"\"Begin resolving proxy asynchronously.\n    Useful if the user knows a proxy will be needed soon and wants to\n    resolve the proxy concurrently with other computation.\n    ```python\n    from proxystore.store.utils import resolve_async\n    resolve_async(my_proxy)\n    computation_without_proxy(...)\n    # p is hopefully resolved\n    computation_with_proxy(my_proxy, ...)\n    ```\n    Note:\n        The asynchronous resolving functionality is implemented\n        by [`StoreFactory`][proxystore.store.base.StoreFactory]. Factories that\n        are not of this type will error when used with this function.\n    Args:\n        proxy: Proxy instance to begin asynchronously resolving.\n    \"\"\"\nif not is_resolved(proxy):\nproxy.__factory__.resolve_async()\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":"<p>ProxyStore is composed of three main components: the <code>Proxy</code>, <code>Connector</code>, and <code>Store</code>.</p> <p>The <code>Proxy</code> model provides pass-by-reference semantics and just-in-time object resolution transparently to consumers.</p> <p>The <code>Connector</code> is a <code>Protocol</code> that defines the low-level interface to a mediated communication channel or object store. Many <code>Connector</code> implementations are provided in the <code>proxystore.connectors</code> module, and users can easily create their own.</p> <p>The <code>Store</code> is a high-level abstraction of an object store and the intended means by which an application uses ProxyStore. The <code>Store</code> is initialized with a <code>Connector</code> and provides extra functionality like caching and serialization. Most important is that the <code>.proxy()</code> method is provided which can produce a <code>Proxy</code> of an arbitrary object put in the store.</p>"},{"location":"concepts/connector/","title":"Connector","text":"<p>The <code>Connector</code> is a <code>Protocol</code> that defines the low-level interface to a mediated communication channel or object store. The <code>Connector</code> methods operate of <code>bytes</code> of data and keys which are tuples of metadata that can identify a unique object.</p> <p>The protocol is as follows: <pre><code>KeyT = TypeVar('KeyT', bound=NamedTuple)\nclass Connector(Protocol[KeyT]):\ndef close(self) -&gt; None: ...\ndef config(self) -&gt; dict[str, Any]: ...\ndef from_config(self, config: dict[str, Any]) -&gt; Connector[KeyT]: ...\ndef evict(self, key: KeyT) -&gt; None: ...\ndef exists(self, key: KeyT) -&gt; bool: ...\ndef get(self, key: KeyT) -&gt; bytes | None: ...\ndef get_batch(self, Sequence[KeyT]) -&gt; list[bytes | None]: ...\ndef put(self, obj: bytes) -&gt; KeyT: ...\ndef put_batch(self, objs: Sequence[bytes]) -&gt; list[KeyT]: ...\n</code></pre> Implementing a custom <code>Connector</code> requires creating a class which implements the above methods. Note that the custom class does not need to inherit from <code>Connector</code> because it is a <code>Protocol</code>.</p> <p>Many <code>Connector</code> implementations are provided in the <code>proxystore.connectors</code> module, and users can easily create their own. A <code>Connector</code> instance is used by the <code>Store</code> to interact with the store.</p>"},{"location":"concepts/proxy/","title":"Proxy","text":"<p>Proxies are commonly used to add additional functionality to their target object or enforce assertions prior to forwarding operations to the target. For example, a proxy can wrap sensitive objects with access control or provide caching for expensive operations.</p> <p>Two valuable properties that a proxy can provide are transparency and lazy resolution. A transparent proxy behaves identically to its target object by forwarding all operations on itself to the target. For example, given a proxy <code>p</code> of an arbitrary object <code>v</code>, the types of <code>v</code> and <code>p</code> will be equivalent, i.e., <code>isinstance(p, type(v))</code> and any operation on <code>p</code> will invoke the corresponding operation on <code>v</code>.</p> <p>A lazy or virtual proxy provides just-in-time resolution of its target object. In this case, the proxy is initialized with a factory rather than the target object. A factory is any object that is callable like a function and returns the target object. The proxy is lazy in that it does not call the factory to retrieve the target until it is first accessed. This process is referred to as resolving the proxy. Functionally, proxies have both pass-by-reference and pass-by-value attributes. The eventual user of the proxied data gets a copy, but unnecessary copies are avoided when the proxy is passed between multiple functions.</p>"},{"location":"concepts/proxy/#creating-proxies","title":"Creating Proxies","text":"<pre><code>from proxystore.proxy import Proxy\ndef resolve_object(...):\n# Function that produces the object of interest\nreturn obj\np = Proxy(resolve_object)\n</code></pre> <p><code>resolve_object()</code> will be called when the proxy <code>p</code> does its just-in-time resolution, and then <code>p</code> will behave exactly like <code>obj</code>. A factory for a <code>Proxy</code> can be any callable object (i.e., object which implements <code>__call__</code>).</p> <p>Proxies are powerful because they can intercept and redefine functionality of an object while emulating the rest of the objects behavior.</p> <pre><code>import numpy as np\nfrom proxystore.proxy import Proxy\nx = np.array([1, 2, 3])\nclass MyFactory():\ndef __init__(self, obj):\nself.obj = obj\ndef __class__(self):\nreturn self.obj\np = Proxy(MyFactory(x))\n# A proxy is an instance of its wrapped object\nassert isinstance(p, Proxy)\nassert isinstance(p, np.ndarray)\n# The proxy can do everything the numpy array can\nassert np.array_equal(p, [1, 2, 3])\nassert np.sum(p) == 6\ny = x + p\nassert np.array_equal(y, [2, 4, 6])\n</code></pre> <p>The ProxyStore <code>Proxy</code> is built on the proxy from <code>lazy-object-proxy</code> which intercepts all calls to the object's magic functions (<code>__func_name__()</code> functions) and forwards the calls to the factory that was passed to the proxy constructor to retrieve the object that should be wrapped.</p> <p>Generally, a proxy is only ever resolved once. However, when a proxy is serialized, only the factory is serialized, and when the proxy is deserialized again and used, the factory will be called again to resolve the object.</p>"},{"location":"concepts/proxy/#interacting-with-proxies","title":"Interacting with Proxies","text":"<p>While a proxy can be used just as one would normally use the proxy's target object, additional functions are provided for interacting with the proxy directly.</p> <pre><code>from proxystore import proxy\np = proxy.Proxy(...)\n# Check if a proxy has been resolved yet\nproxy.is_resolved(p)\n# Force a proxy to resolve itself\nproxy.resolve(p)\n# Extract the wrapped object from the proxy\nx = proxy.extract(p)\nassert not isinstance(x, proxy.Proxy)\n</code></pre>"},{"location":"concepts/store/","title":"Store","text":"<p>A <code>Store</code> is initialized with a <code>Connector</code> instance and provides extra functionality. Similar to the <code>Connector</code>, the <code>Store</code> exposes <code>evict</code>, <code>exist</code>, <code>get</code>, and <code>set</code> operations; however, these operations act on Python objects rather than <code>bytes</code>. The <code>Store</code> will (de)serialize objects accordingly before invoking the corresponding operation on the <code>Connector</code>. The <code>Store</code> also provides caching of operations to reduce communication costs, and objects are cached after deserialization to avoid duplicate deserialization.</p> <p>However, instead of the application directly invoking these aforementioned operations, the proxy method, also provided by the <code>Store</code>, is used. Calling <code>Store.proxy()</code> puts an object in the mediated channel and returns a proxy (see example below). The object is serialized before being put in the mediated channel, a factory with the key returned by the <code>Connector</code> and other information necessary to retrieve the object from the mediated channel is generated, and then a new proxy, internalized with the factory, is returned.</p> <pre><code>from proxystore.connectors.redis import RedisConnector\nfrom proxystore.proxy import Proxy\nfrom proxystore.store import Store\nfrom proxystore.store import register_store\ndef my_function(x: MyDataType) -&gt; ...:\n# x is resolved from \"my-store\" on first use\nassert isinstance(x, MyDataType)\n# More computation...\nstore = Store('my-store', RedisConnector(...))\n# Registering the Store enables proxies to reuse the\n# same Store instance in a process to improve performance\nregister_store(store)\n# Store the object and get a proxy\nmy_object = MyDataType(...)\np = store.proxy(my_object)\nisinstance(p, Proxy)\nmy_function(p)  # Succeeds\n</code></pre>"},{"location":"concepts/store/#asynchronous-resolving","title":"Asynchronous Resolving","text":"<p>It is common in distributed computation for inputs to functions executed remotely to not be needed immediately upon execution. Proxies created by a <code>Store</code> support asynchronous resolution to overlap communication and computation.</p> <pre><code>from proxystore.store.utils import resolve_async\ndef complex_function(large_proxied_input):\nresolve_async(large_proxied_input)\n# More computation...\n# First access to the proxy will not be as expensive because\n# of the asynchronous resolution\ncompute_input(large_proxied_input)\n</code></pre>"},{"location":"concepts/store/#caching","title":"Caching","text":"<p>The <code>Store</code> provides built in caching functionality. Caches are local to the Python process but will speed up the resolution when multiple proxies refer to the same object.</p> <pre><code>from proxystore.store import Store\n# Cache size of 16 is the default\nStore('mystore', connector=..., cache_size=16)\n</code></pre>"},{"location":"concepts/store/#transactional-guarantees","title":"Transactional Guarantees","text":"<p>ProxyStore is designed around optimizing the communication of ephemeral data (e.g., inputs and outputs of functions) which is typically write-once, read-many. Thus, ProxyStore does not provide <code>update</code> semantics on keys.</p>"},{"location":"concepts/store/#serialization","title":"Serialization","text":"<p>All <code>Store</code> operation uses ProxyStore's provided serialization utilities (<code>proxystore.serialize</code>) by default. However, the <code>Store</code> can be initialized with custom default serializers or deserializers of the form:</p> <p><pre><code>serializer = Callable[[Any], bytes]\ndeserializer = Callable[[bytes], Any]\n</code></pre> Most methods also support specifying an alternative serializer or deserializer to the default.</p> <p>In some cases, data may already be serialized in which case an identity function can be passed as the serializer/deserializer (e.g., <code>lambda x: x</code>). Implementing a custom serializer may be beneficial for complex structures where pickle/cloudpickle (the default serializers used by ProxyStore) are innefficient. E.g.,</p> <pre><code>import torch\nimport io\nfrom proxystore.serialize import serialize\nfrom proxystore.store import Store\ndef serialize_torch_model(obj: Any) -&gt; bytes:\nif isinstance(obj, torch.nn.Module):\nbuffer = io.BytesIO()\ntorch.save(model, buffer)\nreturn buffer.read()\nelse:\n# Fallback for unsupported types\nreturn serialize(obj)\nmymodel = torch.nn.Module()\nstore = Store(...)\nkey = store.set(mymodel, serializer=serialize_torch_model)\n</code></pre> <p>Rather than providing a custom serializer or deserializer to each method invocation, a default serializer and deserializer can be provided when initializing a new <code>Store</code>. See Issue #146 for further discussion on where custom serializers can be helpful.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#getting-started-for-local-development","title":"Getting Started for Local Development","text":"<p>We recommend using Tox to setup the development environment. This will create a new virtual environment with all of the required packages installed and ProxyStore installed in editable mode with the necessary extras options.</p> <pre><code>$ git clone https://github.com/proxystore/proxystore\n$ cd proxystore\n$ tox --devenv venv -e py310\n$ . venv/bin/activate\n</code></pre> <p>Warning</p> <p>Running Tox in a Conda environment is possible but it may conflict with Tox's ability to find the correct Python versions. E.g., if your Conda environment is Python 3.9, running <code>$ tox -e p38</code> may still use Python 3.9.</p> <p>To install manually: <pre><code>$ git clone https://github.com/proxystore/proxystore\n$ cd proxystore\n$ python -m venv venv\n$ . venv/bin/activate\n$ pip install -e .[dev,docs,endpoints,...]\n</code></pre></p>"},{"location":"contributing/#continuous-integration","title":"Continuous Integration","text":"<p>ProxyStore uses pre-commit and Tox for continuous integration (test, linting, etc.).</p>"},{"location":"contributing/#linting-and-type-checking-pre-commit","title":"Linting and Type Checking (pre-commit)","text":"<p>To use pre-commit, install the hook and then run against files.</p> <pre><code>$ pre-commit install\n$ pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#tests-tox","title":"Tests (tox)","text":"<p>The entire CI workflow can be run with <code>$ tox</code>. This will test against multiple versions of Python and can be slow.</p> <p>Module-level unit-test are located in the <code>tests/</code> directory and its structure is intended to match that of <code>proxystore/</code>. E.g. the tests for <code>proxystore/store/cache.py</code> are located in <code>tests/store/cache_test.py</code>; however, additional test files can be added as needed. Tests should be narrowly focused and target a single aspect of the code's functionality, tests should not test internal implementation details of the code, and tests should not be dependent on the order in which they are run.</p> <p>Code that is useful for building tests but is not a test itself belongs in the <code>testing/</code> directory.</p> <pre><code># Run all tests in tests/\n$ tox -e py39\n# Run a specific test\n$ tox -e py39 -- tests/factory_test.py::test_lambda_factory\n</code></pre> <p>Many of the tests are asyncio tests. The asyncio default event loop is used by default, but uvloop can be used instead by passing <code>--use-uvloop</code> to pytest.</p>"},{"location":"contributing/#tests-docker","title":"Tests (docker)","text":"<p>The test suite mocks certain third-party programs that cannot be installed via pip (e.g., Margo, UCX, Redis). For Margo and UCX, a Docker image is provided at proxystore/images with the software pre-built and Python installed. The tox environments <code>py{version}-dim</code> can be run in the container to validate changes against the un-mocked software.</p> <pre><code>$ docker pull ghcr.io/proxystore/proxystore-dim:nightly\n# Be sure to change the path to your proxystore repo directory\n$ docker run --rm -it --network host -v /path/to/proxystore:/proxystore ghcr.io/proxystore/proxystore-dim:nightly\n# Inside container\n$ tox -e py310-dim\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<p>If code changes require an update to the documentation (e.g., for function signature changes, new modules, etc.), the documentation can be built using MKDocs.</p> <pre><code># Manually\n$ pip install -e .[docs]\n$ mkdocs build --strict  # Build only to site/index.html\n$ mkdocs serve           # Serve locally\n# With tox (will only build, does not serve)\n$ tox -e docs\n</code></pre> <p>Docstrings are automatically generated, but it is recommended to check the generated docstrings to make sure details/links/etc. are correct.</p>"},{"location":"contributing/issues-pull-requests/","title":"Issues and Pull Requests","text":""},{"location":"contributing/issues-pull-requests/#issues","title":"Issues","text":"<p>Issue Tracker</p> <p>We use GitHub issues to report problems, request and track changes, and discuss future ideas. If you open an issue for a specific problem, please follow the template guides.</p>"},{"location":"contributing/issues-pull-requests/#pull-requests","title":"Pull Requests","text":"<p>We use the standard GitHub contribution cycle where all contributions are made via pull requests (including code owners!).</p> <ol> <li>Fork the repository and clone to your local machine.</li> <li>Create local changes.<ul> <li>Changes should conform to the style and testing guidelines, referenced   above.</li> <li>Preferred commit message format (source):<ul> <li>separate subject from body with a blank line,</li> <li>limit subject line to 50 characters,</li> <li>capitalize first word of subject line,</li> <li>do not end the subject line with a period,</li> <li>use the imperative mood for subject lines,</li> <li>include related issue numbers at end of subject line,</li> <li>wrap body at 72 characters, and</li> <li>use the body to explain what/why rather than how.   Example: <code>Fix concurrency bug in Store (#42)</code></li> </ul> </li> </ul> </li> <li>Push commits to your fork.<ul> <li>Please squash commits fixing mistakes to keep the git history clean.   For example, if commit \"b\" follows commit \"a\" and only fixes a small typo   from \"a\", please squash \"a\" and \"b\" into a single, correct commit.   This keeps the commit history readable and easier to search through when   debugging (e.g., git blame/bisect).</li> </ul> </li> <li>Open a pull request in this repository.<ul> <li>The pull request should include a description of the motivation for the   PR and included changes. A PR template is provided to guide this process.</li> </ul> </li> </ol>"},{"location":"contributing/releases/","title":"Releases","text":""},{"location":"contributing/releases/#release-timeline","title":"Release Timeline","text":"<p>Releases are created on an as-needed basis. Milestones are the Issue Tracker are used to track features to be included in upcoming releases.</p>"},{"location":"contributing/releases/#creating-releases","title":"Creating Releases","text":"<ol> <li>Choose the next version number, referred to as <code>{VERSION}</code> for the    rest of the instructions. ProxyStore versioning follows semver    (<code>major.minor.patch</code>) with optional PEP-440    pre-release/post-release/dev-release segments. Major/minor/patch numbers    start at 0 and pre-release/post-release/dev-release segments start at 1.</li> <li>Update the version in <code>pyproject.toml</code> to <code>{VERSION}</code>.</li> <li>Commit and merge the version updates/changelogs into main.</li> <li>Tag the release commit and push (typically this is the commit updating the    version numbers).    <pre><code>$ git tag -s v{VERSION} -m \"ProxyStore v{VERSION}\"\n$ git push origin v{VERSION}\n</code></pre>    Note the version number is prepended by \"v\" for the tags so we can    distinguish release tags from non-release tags.</li> <li>Create a new release on GitHub using the tag. The title should be    <code>ProxyStore v{VERSION}</code>.</li> <li>Official release:<ol> <li>Use the \"Generate release notes\" option and set the previous tag as the previous official release tag. E.g., for <code>v0.4.1</code>, the previous release tag should be <code>v0.4.0</code> and NOT <code>v0.4.1a1</code>.</li> <li>Add an \"Upgrade Steps\" section at the top (see previous releases for examples).</li> <li>Review the generated notes and edit as needed. PRs are organized by tag, but some PRs will be missing tags and need to be moved from the \"Other Changes\" section to the correct section.</li> <li>Select \"Set as the latest release.\"</li> </ol> </li> <li>Unnofficial release: (alpha/dev builds)<ol> <li>Do NOT generate release notes. The body can be along the lines of \"Development pre-prelease for <code>V{VERSION}</code>.\"</li> <li>Leave the previous tag as \"auto.\"</li> <li>Select \"Set as a pre-release.\"</li> </ol> </li> </ol>"},{"location":"contributing/style-guide/","title":"Style Guide","text":"<p>The Python code and docstring format mostly follows Google's Python Style Guide, but the pre-commit config is the authoritative source for code format compliance.</p> <p>Nits:</p> <ul> <li>Avoid imports in <code>__init__.py</code> (reduces the likelihood of circular imports).</li> <li>Prefer pure functions where possible.</li> <li>Define all class attributes inside <code>__init__</code> so all attributes are visible   in one place. Attributes that are defined later can be set as <code>None</code>   as a placeholder.</li> <li>Prefer f-strings (<code>f'name: {name}</code>) over string format   (<code>'name: {}'.format(name)</code>). Never use the <code>%</code> operator.</li> <li>Prefer typing.NamedTuple over collections.namedtuple.</li> <li>Exception messages should read as complete sentences with punctuation.   Logging messages can forgo trailing punctuation.   <pre><code>raise ValueError('Name must contain alphanumeric characters only.')\nlogger.info(f'New connection opened to {address}')\n</code></pre></li> <li>Document all exceptions that may be raised by a function in the docstring.</li> </ul>"},{"location":"guides/","title":"Guides","text":"<ul> <li>Peer-to-peer Endpoints</li> <li>Performance Tracking</li> </ul>"},{"location":"guides/endpoints/","title":"Peer-to-Peer Endpoints","text":"<p>ProxyStore Endpoints are in-memory object stores with peering capabilities. Endpoints enable data transfer with proxies between multiple sites using NAT traversal.</p> <p>Warning</p> <p>Endpoints are experimental and the interfaces and underlying implementations will likely change. Refer to the API docs for the most up-to-date information.</p> <p>Warning</p> <p>Endpoints do not have user authentication yet, so use at your own risk.</p>"},{"location":"guides/endpoints/#overview","title":"Overview","text":"<p>At its core, the <code>Endpoint</code> is an in-memory data store built on asyncio. Endpoints provide a REST API, served using <code>Quart</code>, and ProxyStore provides the <code>EndpointConnector</code> as the primary interface for clients to interact with endpoints.</p> <p> </p> Figure 1: ProxyStore Endpoints overview. Clients can make requests to   any endpoint and those request will be forwarded to the correct endpoint.   Endpoints establish peer-to-peer connections using UDP hole-punching and a   publicly accessible relay server.    <p>Unlike popular in-memory data stores (Redis, Memcached, etc.), ProxyStore endpoints can operate as peers even from behind different NATs without the need to open ports or SSH tunnels. To achieve direct data transfer between peers, endpoints use the WebRTC standard to determine how the peers can connect.</p> <p>As shown in Fig. 1, endpoints use a commonly accessible relay server to facilitate peer connections. When an endpoint is started, the Endpoint registers with the relay server. Then, when an endpoint needs to make a request from a peer, (1) the endpoint creates an offer and asks the relay server to forward the offer to the peer endpoint. The relay server forwards the offer (2) and the peer endpoint creates an answer to the received offer. The peer endpoint returns the answer to the original endpoint via the relay server (3, 4).</p> <p>The offer and answer contain information about the local and remote sessions of the endpoints which can be used to complete the peer-to-peer connection (5). (Note: this is a great simplification and more details can be found at https://webrtc.org/getting-started/peer-connections.) The peers will then keep a data channel open between themselves for the remainder of their lifetime.</p> <p>Clients interacting with an endpoint via the REST API and typical object store operations (get, set, etc.) specify a key and an endpoint UUID. Endpoints that receive a request with a different endpoint UUID will attempt a peer connection to the endpoint if one does not exist already and forward the request along and facilitate returning the response back to the client.</p>"},{"location":"guides/endpoints/#endpoint-cli","title":"Endpoint CLI","text":"<p>Endpoints can be configure and started with the <code>proxystore-endpoint</code> command.</p> <pre><code>$ proxystore-endpoint configure my-endpoint --relay-server wss://relay-address.com\nConfigured endpoint my-endpoint &lt;12b8f3b6-6c0e-4141-b851-870895e3eb3c&gt;.\n\nTo start the endpoint:\n   $ proxystore-endpoint start my-endpoint\n</code></pre> <p>Endpoint configurations are stored to <code>$PROXYSTORE_HOME/{endpoint-name}</code> or <code>$XDG_DATA_HOME/proxystore/{endpoint-name}</code> (see <code>home_dir()</code>) and contain the name, UUID, host address, port, and singaling server address.</p> <ol> <li>Name: readable name of the endpoint. Used for management in the CLI and    to improve log readability.</li> <li>UUID: primary identifier of the endpoint. The relay server will    use this UUID to keep track of endpoints.</li> <li>Host address: address of the host the endpoint was last started on.    Each time the endpoint is started, this address is updated.</li> <li>Port: port the endpoint will listening on. Defaults to 8765.</li> <li>Relay server address: address of relay server to use for peer    connections. All endpoints that may peer with each other must use the same    relay server. Relay servers are optional, and if unspecified, the    endpoint will operate without peering functionalities.</li> </ol> <p>An up-to-date configuration description can found in the <code>EndpointConfig</code> docstring.</p> <p>Starting the endpoint will load the configuration from the ProxyStore home directory, initialize the endpoint, and start a Quart app using the host and port.</p> <pre><code>$ proxystore-endpoint start my-endpoint\n</code></pre>"},{"location":"guides/endpoints/#endpointconnector","title":"EndpointConnector","text":"<p>The primary interface to endpoints is the <code>EndpointConnector</code>.</p> <p>Note</p> <p>This section assumes familiarity with proxies and the <code>Store</code> interface. See the Get Started guide before getting started with endpoints.</p> <pre><code>from proxystore.connectors.endpoint import EndpointConnector\nfrom proxystore.store import Store\nconnector = EndpointConnector(\nendpoints=[\n'5349ffce-edeb-4a8b-94a6-ab16ade1c1a1',\n'd62910f6-0d29-452e-80b7-e0cd601949db',\n...\n],\n)\nstore = Store(name='default', connector=connector)\np = store.proxy(my_object)\n</code></pre> <p>The <code>EndpointConnector</code> takes a list of endpoint UUIDs. This list represents any endpoint that proxies created by this store may interact with to resolve themselves. The <code>EndpointConnector</code> will use this list to find its home endpoint, the endpoint that will be used to issue operations to. To find the home endpoint, the ProxyStore home directory will be scanned for any endpoint configurations matching the one of the UUIDs. If a match is found, the <code>EndpointConnector</code> will attempt to connect to the endpoint using the host and port in the configuration. This process is repeated until a reachable endpoint is found. While the user could specify the home endpoint directly, the home endpoint may change when a proxy travels to a different machine.</p>"},{"location":"guides/endpoints/#proxy-lifecycle","title":"Proxy Lifecycle","text":"Figure 2: Flow of data when transferring objects via proxies and   endpoints.    <p>In distributed systems, proxies created from an <code>EndpointConnector</code> can be used to facilitate simple and fast data communication. The flow of data and their associated proxies are shown in Fig. 2.</p> <ol> <li>Host A creates a proxy of the target object. The serialized target    is placed in Host A's home/local endpoint (Endpoint 1).    The proxy contains the key referencing the target, the endpoint UUID with    the target data (Endpoint 1's UUID), and the list of    all endpoint UUIDs configured with the    <code>EndpointConnector</code>    (the UUIDs of Endpoints 1 and 2).</li> <li>Host A communicates the proxy object to Host B. This communication is    cheap because the proxy is just a thin reference to the object.</li> <li>Host B receives the proxy and attempts to use the proxy initiating the    proxy resolve process. The proxy requests the data from Host B's    home endpoint (Endpoint 2).</li> <li>Endpoint 2 sees that the proxy is requesting data from a different endpoint    (Endpoint 1) so Endpoint 2 initiates a peer connection to Endpoint 1 and    requests the data.</li> <li>Endpoint 1 sends the data to Endpoint 2.</li> <li>Endpoint 2 replies to Host B's request for the data with the data received    from Endpoint 2. Host B deserializes the target object and the proxy    is resolved.</li> </ol>"},{"location":"guides/endpoints/#hosting-a-relay-server","title":"Hosting a Relay Server","text":"<p>Currently, ProxyStore does not provided any publicly host relay servers, though we hope to in the future! Hosting your own relay server is simple if you have a host accessible from the internet (e.g., a compute instance from a cloud provider or a machine behind a NAT with an open port) and the ProxyStore package installed.</p> <pre><code>$ proxystore-relay --port 3579\n</code></pre>"},{"location":"guides/performance/","title":"Performance Tracking","text":"<p>The <code>Store</code> can record metrics on executed operations (e.g., <code>get</code> and <code>set</code>). Metric collection is disabled by default and can be enabled by passing <code>metrics=True</code> to a <code>Store</code> constructor.</p>"},{"location":"guides/performance/#enabling-metrics","title":"Enabling Metrics","text":"<pre><code>import dataclasses\nfrom proxystore.connectors.file import FileConnector\nfrom proxystore.store import register_store\nfrom proxystore.store.base import Store\nstore = Store(\nname='example-store',\nconnector=FileConnector('/tmp/proxystore-dump'),\nmetrics=True,\n)\nregister_store(store)\nassert store.metrics is not None\n</code></pre> <p>Metrics are accessed via the <code>Store.metrics</code> property. This property will be <code>None</code> when metrics are disabled.</p> <p>Warning</p> <p>Metrics are local to each <code>Store</code> instance. In multi-process applications or applications that instantiate multiple <code>Store</code> instances, <code>Store.metrics</code> will only represent a partial view of the overall performance.</p> <p>Three types of metrics are collected.</p> <ul> <li>Attributes: arbitrary attributes associated with an operation.</li> <li>Counters: scalar counters that represent the number of times an event occurs.</li> <li>Times: durations of events.</li> </ul>"},{"location":"guides/performance/#a-simple-example","title":"A Simple Example","text":"<p>Consider executing a <code>get</code> and <code>set</code> operation on <code>store</code>. <pre><code>key = store.set([0, 1, 2, 3, 4, 5])\nstore.get(key)\n</code></pre></p> <p>We can inspect the metrics recorded for operations on <code>key</code>. <pre><code>metrics = store.metrics.get_metrics(key)\ntuple(field.name for field in dataclasses.fields(metrics))\n&gt;&gt;&gt; ('attributes', 'counters', 'times')\n</code></pre></p> <p><code>metrics</code> is an instance of <code>Metrics</code> which is a <code>dataclass</code> with three fields: <code>attributes</code>, <code>counters</code>, and <code>times</code>. We can further inspect these fields. <pre><code>metrics.attributes\n&gt;&gt;&gt; {'store.get.object_size': 219, 'store.set.object_size': 219}\nmetrics.counters\n&gt;&gt;&gt; {'store.get.cache_misses': 1}\nmetrics.times\n&gt;&gt;&gt; {\n&gt;&gt;&gt;     'store.set.serialize': TimeStats(\n&gt;&gt;&gt;         count=1, avg_time_ms=9.9, min_time_ms=9.9, max_time_ms=9.9\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     'store.set.connector': TimeStats(\n&gt;&gt;&gt;         count=1, avg_time_ms=36.9, min_time_ms=36.9, max_time_ms=36.9\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     'store.set': TimeStats(\n&gt;&gt;&gt;         count=1, avg_time_ms=53.4, min_time_ms=53.4, max_time_ms=53.4\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     'store.get.connector': TimeStats(\n&gt;&gt;&gt;         count=1, avg_time_ms=16.1, min_time_ms=16.1, max_time_ms=16.1\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     'store.get.deserialize': TimeStats(\n&gt;&gt;&gt;         count=1, avg_time_ms=7.6, min_time_ms=7.6, max_time_ms=7.6\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     'store.get': TimeStats(\n&gt;&gt;&gt;         count=1, avg_time_ms=45.6, min_time_ms=45.6, max_time_ms=45.6\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt; }\n</code></pre></p> <p>Operations or events are represented by a hierarchical namespace. E.g., <code>store.get.object_size</code> is the serialized object size from the call to <code>Store.get()</code>. In <code>metrics.attributes</code>, we see the serialized object was 219 bytes. In <code>metrics.counters</code>, we see we had one cache miss when getting the object. In <code>metrics.times</code>, we see statistics about the duration of each operation. For example, <code>store.get</code> is the overall time <code>Store.get()</code> took, <code>store.get.connector</code> is the time spent calling <code>Connector.get()</code>, and <code>store.get.deserialize</code> is the time spent deserializing the object returned by <code>Connector.get()</code>.</p> <p>If we get the object again, we'll see the metrics change. <pre><code>store.get(key)\nmetrics = store.metrics.get_metrics(key)\nmetrics.counters\n&gt;&gt;&gt; {'store.get.cache_hits': 1, 'store.get.cache_misses': 1}\nmetrics.times['store.get']\n&gt;&gt;&gt; TimeStats(count=2, avg_time_ms=24.4, min_time_ms=3.2, max_time_ms=45.6)\n</code></pre> Here, we see that the second get resulted in a cache hit, and our average time for <code>store.get</code> dropped significantly.</p> <p>Attributes of a <code>TimeStats</code> instance can be directly accessed. <pre><code>metrics.times['store.get'].avg_time_ms\n&gt;&gt;&gt; 24.4\n</code></pre></p>"},{"location":"guides/performance/#metrics-with-proxies","title":"Metrics with Proxies","text":"<p>Metrics are also tracked on proxy operations. <pre><code>proxy = store.proxy(target)\n# Access the proxy to force it to resolve.\nassert target_proxy[0] == 0\nmetrics = store.metrics.get_metrics(proxy)\nmetrics.times\n&gt;&gt;&gt; {\n&gt;&gt;&gt;     'factory.call': TimeStats(...)\n&gt;&gt;&gt;     'factory.resolve': TimeStats(...),\n&gt;&gt;&gt;     'store.get': TimeStats(...),\n&gt;&gt;&gt;     'store.get.connector': TimeStats(...),\n&gt;&gt;&gt;     'store.get.deserialize': TimeStats(...),\n&gt;&gt;&gt;     'store.proxy': TimeStats(...),\n&gt;&gt;&gt;     'store.set': TimeStats(...),\n&gt;&gt;&gt;     'store.set.connector': TimeStats(...),\n&gt;&gt;&gt;     'store.set.serialize': TimeStats(...),\n&gt;&gt;&gt; }\n</code></pre> Calling <code>Store.proxy()</code> internally called <code>Store.set()</code>. Accessing the proxy internally resolved the factory so we also see metrics about the <code>factory</code> and <code>store.get</code>.</p> <p>Warning</p> <p>For metrics to appropriately be tracked when a proxy is resolved, the <code>Store</code> needs to be registered globally with <code>register_store()</code>. Otherwise, the factory will initialize a second <code>Store</code> to register and record its metrics to the second instance.</p>"},{"location":"guides/performance/#metrics-for-batch-operations","title":"Metrics for Batch Operations","text":"<p>For batch <code>Store</code> operations, metrics are recorded for the entire batch. I.e., the batch of keys is treated as a single super key.</p> <pre><code>keys = store.set_batch(['value1', 'value2', 'value3'])\nmetrics = store.metrics.get_metrics(keys)\nmetrics.times\n&gt;&gt;&gt; {\n&gt;&gt;&gt;     'store.set_batch.serialize': TimeStats(...),\n&gt;&gt;&gt;     'store.set_batch.connector': TimeStats(...),\n&gt;&gt;&gt;     'store.set_batch': TimeStats(...)\n&gt;&gt;&gt; }\n</code></pre>"},{"location":"guides/performance/#aggregating-metrics","title":"Aggregating Metrics","text":"<p>Rather than accessing metrics associated with a specific key (or batched key), time statistics can be aggregated over all keys.</p> <p><pre><code>store.metrics.aggregate_times()\n&gt;&gt;&gt; {\n&gt;&gt;&gt;     'factory.call': TimeStats(...),\n&gt;&gt;&gt;     'factory.resolve': TimeStats(...),\n&gt;&gt;&gt;     'store.get': TimeStats(...),\n&gt;&gt;&gt;     'store.get.connector': TimeStats(...),\n&gt;&gt;&gt;     'store.get.deserialize': TimeStats(...),\n&gt;&gt;&gt;     'store.proxy': TimeStats(...),\n&gt;&gt;&gt;     'store.set': TimeStats(...),\n&gt;&gt;&gt;     'store.set.connector': TimeStats(...),\n&gt;&gt;&gt;     'store.set.serialize': TimeStats(...),\n&gt;&gt;&gt;     'store.set_batch': TimeStats(...),\n&gt;&gt;&gt;     'store.set_batch.connector': TimeStats(...),\n&gt;&gt;&gt;     'store.set_batch.serialize': TimeStats(...),\n&gt;&gt;&gt; }\n</code></pre> Each of these <code>TimeStats</code> represents the aggregate over all keys.</p> <p>The Python code used to generate the above examples can be found at github.com/proxystore/proxystore/examples/store_metrics.py.</p>"}]}