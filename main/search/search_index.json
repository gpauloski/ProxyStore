{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ProxyStore","text":"<p>ProxyStore provides a unique interface to object stores through transparent object proxies that is designed to simplify the use of object stores for transferring large objects in distributed applications. ProxyStore's goals are to:</p> <ul> <li>Improve productivity. ProxyStore enables easy decoupling of   communication from the rest of the code, allowing developers to focus   on functionality and performance.</li> <li>Improve compatibility. Consumers of data can be agnostic to the   communication method because object proxies handle the communication   behind the scenes.</li> <li>Improve performance. Transport methods and object stores can be changed   at runtime to optimal choices for the given data without the consumers   being aware of the change.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install via pip: <pre><code># Base install\npip install proxystore\n# Extras install for serving Endpoints\npip install proxystore[endpoints]\n</code></pre></p> <p>More details are available on the Get Started guide. For local development, see the Contributing guide.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Complete documentation for ProxyStore at https://proxystore.dev.</p>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#proxies","title":"Proxies","text":"<p>Proxies can be created easily using ProxyStore.</p> <pre><code>from proxystore.proxy import Proxy\ndef resolve_object(...):\n# Function that produces the object of interest\nreturn obj\np = Proxy(resolve_object)\n</code></pre> <p><code>resolve_object()</code> will be called when the proxy <code>p</code> does its just-in-time resolution, and then <code>p</code> will behave exactly like <code>obj</code>. A factory for a <code>Proxy</code> can be any callable object (i.e., object which implements <code>__call__</code>).</p> <p>Proxies are powerful because they can intercept and redefine functionality of an object while emulating the rest of the objects behavior.</p> <pre><code>import numpy as np\nfrom proxystore.proxy import Proxy\nx = np.array([1, 2, 3])\nclass MyFactory():\ndef __init__(self, obj):\nself.obj = obj\ndef __class__(self):\nreturn self.obj\np = Proxy(MyFactory(x))\n# A proxy is an instance of its wrapped object\nassert isinstance(p, Proxy)\nassert isinstance(p, np.ndarray)\n# The proxy can do everything the numpy array can\nassert np.array_equal(p, [1, 2, 3])\nassert np.sum(p) == 6\ny = x + p\nassert np.array_equal(y, [2, 4, 6])\n</code></pre> <p>The ProxyStore <code>Proxy</code> is built on the proxy from <code>lazy-object-proxy</code> which intercepts all calls to the object's magic functions (<code>__func_name__()</code> functions) and forwards the calls to the wrapped object. If the wrapped object has not been resolved yet, the proxy calls the factory that was passed to the proxy constructor to retrieve the object that should be wrapped.</p> <p>Generally, a proxy is only ever resolved once. However, when a proxy is serialized, only the factory is serialized, and when the proxy is deserialized again and used, the factory will be called again to resolve the object.</p>"},{"location":"advanced/#utilities","title":"Utilities","text":"<p>Proxystore provides some useful utility functions for dealing with proxies.</p> <pre><code>from proxystore import proxy\np = proxy.Proxy(...)\n# Check if a proxy has been resolved yet\nproxy.is_resolved(p)\n# Force a proxy to resolve itself\nproxy.resolve(p)\n# Extract the wrapped object from the proxy\nx = proxy.extract(p)\nassert not isinstance(x, proxy.Proxy)\n</code></pre>"},{"location":"advanced/#other-uses","title":"Other Uses","text":"<p>Proxies can be used add functionality to existing objects. Two common examples are access control and partial resoluion.</p>"},{"location":"advanced/#stores","title":"Stores","text":""},{"location":"advanced/#asynchronous-resolving","title":"Asynchronous Resolving","text":"<p>It is common in distributed computation for inputs to functions executed remotely to not be needed immediately upon execution. Proxies created by a <code>Store</code> support asynchronous resolution to overlap communication and computation.</p> <pre><code>from proxystore.store.utils import resolve_async\ndef complex_function(large_proxied_input):\nresolve_async(large_proxied_input)\n# More computation...\n# First access to the proxy will not be as expensive because\n# of the asynchronous resolution\ncompute_input(large_proxied_input)\n</code></pre>"},{"location":"advanced/#caching","title":"Caching","text":"<p><code>Store</code> provides built in caching functionality. Caches are local to the Python process but will speed up the resolution when multiple proxies refer to the same object.</p> <pre><code>from proxystore.store.file import FileStore\n# Cache size of 16 is the default\nFileStore('mystore', store_dir='/tmp/proxystore', cache_size=16)\n</code></pre>"},{"location":"advanced/#transactional-guarantees","title":"Transactional Guarantees","text":"<p>ProxyStore is designed around optimizing the communication of ephemeral data (e.g., inputs and outputs of functions) which is typically write-once, read-many. Thus, ProxyStore does not provides any guarantees about object versions if a user manually overwrites an object.</p>"},{"location":"advanced/#serialization","title":"Serialization","text":"<p>All <code>Store</code> operation uses ProxyStore's provided serialization utilities (proxystore.serialize) by default. However, all <code>Store</code> methods that move data in or out of the store can be provided custom serializers or deserializers of the form:</p> <pre><code>serializer = Callable[[Any], bytes]\ndeserializer = Callable[[bytes], Any]\n</code></pre> <p>In some cases, data may already be serialized in which case an identity function can be passed as the serializer/deserializer (e.g., <code>lambda x: x</code>). Implementing a custom serializer may be beneficial for complex structures where pickle/cloudpickle (the default serializers used by ProxyStore) are innefficient. E.g.,</p> <pre><code>import torch\nimport io\nfrom proxystore.serialize import serialize\nfrom proxystore.store.redis import RedisStore\ndef serialize_torch_model(obj: Any) -&gt; bytes:\nif isinstance(obj, torch.nn.Module):\nbuffer = io.BytesIO()\ntorch.save(model, buffer)\nreturn buffer.read()\nelse:\n# Fallback for unsupported types\nreturn serialize(obj)\nmymodel = torch.nn.Module()\nstore = RedisStore(...)\nkey = store.set(mymodel, serializer=serialize_torch_model)\n</code></pre> <p>See Issue #146 for further discussion.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#getting-started-for-local-development","title":"Getting Started for Local Development","text":"<p>We recommend using Tox to setup the development environment. This will create a new virtual environment with all of the required packages installed and ProxyStore installed in editable mode.</p> <pre><code>$ git clone https://github.com/proxystore/proxystore\n$ cd ProxyStore\n$ tox --devenv venv -e py39\n$ . venv/bin/activate\n</code></pre> <p>Warning</p> <p>Running Tox in a Conda environment is possible but it may conflict with Tox's ability to find the correct Python versions. E.g., if your Conda environment is Python 3.9, running <code>$ tox -e p38</code> may still use Python 3.9.</p>"},{"location":"contributing/#continuous-integration","title":"Continuous Integration","text":"<p>ProxyStore uses pre-commit and Tox for continuous integration (test, linting, etc.).</p>"},{"location":"contributing/#linting-and-type-checking-pre-commit","title":"Linting and Type Checking (pre-commit)","text":"<p>To use pre-commit, install the hook and then run against files.</p> <pre><code>$ pre-commit install\n$ pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#tests-tox","title":"Tests (tox)","text":"<p>The entire CI workflow can be run with <code>$ tox</code>. This will test against multiple versions of Python and can be slow.</p> <p>Module-level unit-test are located in the <code>tests/</code> directory and its structure is intended to match that of <code>proxystore/</code>. E.g. the tests for <code>proxystore/store/cache.py</code> are located in <code>tests/store/cache_test.py</code>; however, additional test files can be added as needed. Tests should be narrowly focused and target a single aspect of the code's functionality, tests should not test internal implementation details of the code, and tests should not be dependent on the order in which they are run.</p> <p>Code that is useful for building tests but is not a test itself belongs in the <code>testing/</code> directory.</p> <pre><code># Run all tests in tests/\n$ tox -e py39\n# Run a specific test\n$ tox -e py39 -- tests/factory_test.py::test_lambda_factory\n</code></pre> <p>Many of the tests are asyncio tests. The asyncio default event loop is used by default, but uvloop can be used instead by passing <code>--use-uvloop</code> to pytest.</p>"},{"location":"contributing/#tests-docker","title":"Tests (docker)","text":"<p>The test suite mocks certain third-party programs that cannot be installed via pip (e.g., Margo, UCX, Redis). For Margo and UCX, a Docker image is provided at proxystore/images with the software pre-built and Python installed. The tox environments <code>py{version}-dim</code> can be run in the container to validate changes against the un-mocked software.</p> <pre><code>$ docker pull ghcr.io/proxystore/proxystore-dim:nightly\n$ docker run --rm -it --network host -v /path/to/proxystore:/proxystore proxystore-dim\n# Inside container\n$ tox -e py310-dim\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<p>If code changes require an update to the documentation (e.g., for function signature changes, new modules, etc.), the documentation can be built using MKDocs.</p> <pre><code># Manually\n$ pip install -e .[docs]\n$ mkdocs build --strict  # Build only to site/index.html\n$ mkdocs server          # Serve locally\n# With tox\n$ tox -e docs\n</code></pre> <p>Docstrings are automatically generated, but it is recommended to check the generated docstrings to make sure details/links/etc. are correct.</p>"},{"location":"contributing/#style-guide","title":"Style Guide","text":"<p>The Python code and docstring format mostly follows Google's Python Style Guide, but the pre-commit config is the authoritative source for code format compliance.</p> <p>Nits:</p> <ul> <li>Avoid imports in <code>__init__.py</code> (reduces the likelihood of circular imports).</li> <li>Prefer pure functions where possible.</li> <li>Define all class attributes inside <code>__init__</code> so all attributes are visible   in one place. Attributes that are defined later can be set as <code>None</code>   as a placeholder.</li> <li>Prefer f-strings (<code>f'name: {name}</code>) over string format   (<code>'name: {}'.format(name)</code>). Never use the <code>%</code> operator.</li> <li>Prefer typing.NamedTuple over collections.namedtuple.</li> <li>Use lower-case and no punctuation for log messages, but use upper-case and   punctuation for exception values.   <pre><code>logger.info(f'new connection opened to {address}')\nraise ValueError('Name must contain alphanumeric characters only.')\n</code></pre></li> <li>Document all exceptions that may be raised by a function in the docstring.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<p>We use GitHub issues to report problems, request and track changes, and discuss future ideas. If you open an issue for a specific problem, please follow the template guides.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>We use the standard GitHub contribution cycle where all contributions are made via pull requests (including code owners!).</p> <ol> <li>Fork the repository and clone to your local machine.</li> <li>Create local changes.<ul> <li>Changes should conform to the style and testing guidelines, referenced   above.</li> <li>Preferred commit message format (source):<ul> <li>separate subject from body with a blank line,</li> <li>limit subject line to 50 characters,</li> <li>capitalize first word of subject line,</li> <li>do not end the subject line with a period,</li> <li>use the imperative mood for subject lines,</li> <li>include related issue numbers at end of subject line,</li> <li>wrap body at 72 characters, and</li> <li>use the body to explain what/why rather than how.   Example: <code>Fix concurrency bug in Store (#42)</code></li> </ul> </li> </ul> </li> <li>Push commits to your fork.<ul> <li>Please squash commits fixing mistakes to keep the git history clean.   For example, if commit \"b\" follows commit \"a\" and only fixes a small typo   from \"a\", please squash \"a\" and \"b\" into a single, correct commit.   This keeps the commit history readable and easier to search through when   debugging (e.g., git blame/bisect).</li> </ul> </li> <li>Open a pull request in this repository.<ul> <li>The pull request should include a description of the motivation for the   PR and included changes. A PR template is provided to guide this process.</li> </ul> </li> </ol>"},{"location":"contributing/#release-instructions","title":"Release Instructions","text":"<ol> <li>Choose the next version number, referred to as <code>{VERSION}</code> for the    rest of the instructions. ProxyStore versioning follows semver    (<code>major.minor.patch</code>) with optional PEP-440    pre-release/post-release/dev-release segments. Major/minor/patch numbers    start at 0 and pre-release/post-release/dev-release segments start at 1.</li> <li>Update the version in <code>pyproject.toml</code> to <code>{VERSION}</code>.</li> <li>Commit and merge the version updates/changelogs into main.</li> <li>Tag the release commit and push (typically this is the commit updating the    version numbers).    <pre><code>$ git tag -s v{VERSION} -m \"ProxyStore v{VERSION}\"\n$ git push origin v{VERSION}\n</code></pre>    Note the version number is prepended by \"v\" for the tags so we can    distinguish release tags from non-release tags.</li> <li>Create a new release on GitHub using the tag. The title should be    <code>ProxyStore v{VERSION}</code>.</li> <li>Official release:<ol> <li>Use the \"Generate release notes\" option and set the previous tag as the previous official release tag. E.g., for <code>v0.4.1</code>, the previous release tag should be <code>v0.4.0</code> and NOT <code>v0.4.1a1</code>.</li> <li>Add an \"Upgrade Steps\" section at the top (see previous releases for examples).</li> <li>Review the generated notes and edit as needed. PRs are organized by tag, but some PRs will be missing tags and need to be moved from the \"Other Changes\" section to the correct section.</li> <li>Select \"Set as the latest release.\"</li> </ol> </li> <li>Unnofficial release: (alpha/dev builds)<ol> <li>Do NOT generate release notes. The body can be along the lines of \"Development pre-prelease for <code>V{VERSION}</code>.\"</li> <li>Leave the previous tag as \"auto.\"</li> <li>Select \"Set as a pre-release.\"</li> </ol> </li> </ol>"},{"location":"getstarted/","title":"Get Started","text":"ProxyStore allows developers to communicate objects via *proxies*. Proxies   act as lightweight references that resolve to a *target* object upon use.   Communication via proxies gives applications the illusion that objects   are moving through a specified path (e.g., through a network   socket, cloud server, workflow engine, etc.) while the true path the data   takes is different. Transporting the lightweight proxies through the   application or systems can be far more efficient and reduce overheads."},{"location":"getstarted/#overview","title":"Overview","text":"<p>ProxyStore provides a unique interface to object stores through transparent object proxies that is designed to simplify the use of object stores for transferring large objects in distributed applications.</p> <p>Proxies are used to intercept and redefine operations on a target object. A transparent proxy behaves identically to its target object because the proxy forwards all operations on itself to the target. A lazy proxy provides just-in-time resolution of the target object via a factory function. Factories return the target object when called, and a proxy, initialized with a factory, will delay calling the factory to retrieve the target object until the first time the proxy is accessed.</p> <p>ProxyStore uses lazy transparent object proxies as the interface to object stores. When an object is proxied, the object is placed in the specified object store, a factory containing the information needed to retrieve the object from the store is created, and a proxy, initialized with the factory, is returned. The resulting proxy is essentially a lightweight reference to the target that will resolve itself to the target and behave as the target once the proxy is first used. Thus, proxies can be used anywhere in-place of the true object and will resolve themselves without the program being aware.</p> <p>ProxyStore provides the proxy interface to a number of commonly used object stores as well as the <code>Proxy</code> and <code>Factory</code> building blocks to allow developers to create powerful just-in-time resolution functionality for Python objects.</p>"},{"location":"getstarted/#installation","title":"Installation","text":"<pre><code>$ pip install proxystore\n</code></pre> <p>Serving ProxyStore Endpoints requires installing using the extras install.</p> <pre><code>$ pip install proxystore[endpoints]\n</code></pre> <p>See Contributing if you are installing for local development.</p>"},{"location":"getstarted/#usage","title":"Usage","text":"<p>ProxyStore is intended to be used via the <code>Store</code> interface which provide the <code>Store.proxy()</code> method for placing objects in stores and creating proxies that will resolve to the associated object in the store.</p> <p>ProxyStore provides many <code>Store</code> implementations and more can be added by extending the <code>Store</code> class.</p> <p>The following example uses the <code>RedisStore</code> to interface with a running Redis server using proxies.</p> <pre><code>from proxystore.store import get_store\nfrom proxystore.store import register_store\nfrom proxystore.store.redis import RedisStore\nstore = RedisStore(name='my-store', hostname='localhost', port=1234)\nregister_store(store)\n# A registered store can be retrieved by name\nstore = get_store('my-store')\n# Stores have basic get/set functionality\nkey = store.set(my_object)\nassert my_object == store.get(key)\n# Place an object in the store and return a proxy\np = store.proxy(my_object)\n# The proxy, when used, will behave as the target\nassert isinstance(p, type(my_object))\n</code></pre> <p>This proxy, <code>p</code>, can be cheaply serialized and communicated to any arbitrary Python process as if it were the target object itself. Once the proxy is used on the remote process, the underlying factory function will be executed to retrieve the target object from the Redis server.</p> <p>Using the <code>Store</code> store interface allows developers to write code without needing to worry about how data communication is handled and reduces the number of lines of code that need to be changed when adding or changing the communication methods.</p> <p>For example, if you want to execute a function and the input data may be passed directly, via a key to an object in Redis, or as a filepath to a serialized object on disk, you will need boilerplate code that looks like:</p> <pre><code>def my_function(input: MyDataType | str | ...) -&gt; None:\nif is_filepath(input_data):\ndata = read_and_deserialize(input)\nelif is_redis_key(input_data):\ndata = redis_client.get(input)\nelif is_other_communication_method(input_data):\n...\nelif isinstance(input, MyDataType):\ndata = input\nelse:\nraise ValueError(...)\n# Compute using the data\n</code></pre> <p>This function is hard to type and must be extended every time a new communication method is used. With proxies, all of the boilerplate code can be removed because the proxy will contain within itself all of the necessary code to resolve the object.</p> <pre><code>def my_function(input: MyDataType) -&gt; None:\n# Always true even if input is a proxy\nassert isinstance(input, MyDataType)\n# Compute using the data\n</code></pre> <p>In this model, only the producer of the data needs to be aware of which ProxyStore backend to use, and no modification to consumer code are ever required.</p> <p>How is this more efficient?</p> <p>The ProxyStore model can improve application performance in many ways:</p> <ol> <li>Unused proxies are not resolved so not resources/time were wasted on the    communication.</li> <li>Object communication always takes place between the producer, the store, and    the consumer meaning communication is not wasted on intermediate processes    which have a proxy but do not use it.</li> <li>Different backends can be used that are optimized for specific usage    patterns.</li> <li>Proxies have built-in caching for frequently used objects    (Caching).</li> </ol> <p>See Advanced Usage to learn more!</p>"},{"location":"getstarted/#related","title":"Related","text":"<p>Examples: Examples of integrating ProxyStore into distributed applications built on FuncX and Parsl are here.</p> <p>Benchmarks: ProxyStore benchmarks are maintained at https://github.com/proxystore/benchmarks.</p>"},{"location":"getstarted/#known-issues","title":"Known Issues","text":"<ul> <li>ProxyStore Endpoints are not supported for   Python 3.7 on ARM-based Macs because   aiortc does not have the corresponding   wheels. The base ProxyStore package can still be installed on this   software/hardware configurations---just not with the <code>endpoints</code> extras.</li> </ul>"},{"location":"legacy-docs/","title":"Legacy Documentation","text":"<p>Documentation for ProxyStore version older than 0.4.1 are hosted at https://proxystore.readthedocs.io/.</p>"},{"location":"guides/","title":"Guides","text":"<ul> <li>Peer-to-peer Endpoints</li> <li>Performance Tracking</li> </ul>"},{"location":"guides/endpoints/","title":"Peer-to-Peer Endpoints","text":"<p>ProxyStore Endpoints are in-memory object stores with peering capabilities. Endpoints enable data transfer with proxies between multiple sites using NAT traversal.</p> <p>Warning</p> <p>Endpoints are experimental and the interfaces and underlying implementations will likely change. Refer to the API docs for the most up-to-date information.</p> <p>Warning</p> <p>Endpoints do not have user authentication yet, so use at your own risk.</p>"},{"location":"guides/endpoints/#overview","title":"Overview","text":"<p>At its core, the <code>Endpoint</code> is an in-memory data store built on asyncio. Endpoints provide a REST API, served using <code>Quart</code>, and ProxyStore provides the <code>EndpointStore</code> as the primary interface for clients to interact with endpoints.</p> <p> </p> Figure 1: ProxyStore Endpoints overview. Clients can make requests to   any endpoint and those request will be forwarded to the correct endpoint.   Endpoints establish peer-to-peer connections using UDP hole-punching and a   publicly accessible signaling server.    <p>Unlike popular in-memory data stores (Redis, Memcached, etc.), ProxyStore endpoints can operate as peers even from behind different NATs without the need to open ports or SSH tunnels. To achieve direct data transfer between peers, endpoints use the WebRTC standard to determine how the peers can connect.</p> <p>As shown in Fig. 1, endpoints use a commonly accessible signaling server to facilitate peer connections. When an endpoint is started, the Endpoint registers with the signaling server. Then, when an endpoint needs to make a request from a peer, (1) the endpoint creates an offer and asks the signaling server to forward the offer to the peer endpoint. The signaling server forwards the offer (2) and the peer endpoint creates an answer to the received offer. The peer endpoint returns the answer to the original endpoint via the signaling server (3, 4).</p> <p>The offer and answer contain information about the local and remote sessions of the endpoints which can be used to complete the peer-to-peer connection (5). (Note: this is a great simplification and more details can be found at https://webrtc.org/getting-started/peer-connections.) The peers will then keep a data channel open between themselves for the remainder of their lifetime.</p> <p>Clients interacting with an endpoint via the REST API and typical object store operations (get, set, etc.) specify a key and an endpoint UUID. Endpoints that receive a request with a different endpoint UUID will attempt a peer connection to the endpoint if one does not exist already and forward the request along and facilitate returning the response back to the client.</p>"},{"location":"guides/endpoints/#endpoint-cli","title":"Endpoint CLI","text":"<p>Endpoints can be configure and started with the <code>proxystore-endpoint</code> command.</p> <pre><code>$ proxystore-endpoint configure my-endpoint --port 9732 --server remote-server.com:3574\nConfigured endpoint my-endpoint &lt;12b8f3b6-6c0e-4141-b851-870895e3eb3c&gt;.\n\nTo start the endpoint:\n   $ proxystore-endpoint start my-endpoint\n</code></pre> <p>Endpoint configurations are stored to <code>$PROXYSTORE_HOME/{endpoint-name}</code> or <code>$XDG_DATA_HOME/proxystore/{endpoint-name}</code> (see <code>home_dir()</code>) and contain the name, UUID, host address, port, and singaling server address.</p> <ol> <li>Name: readable name of the endpoint. Used for management in the CLI and    to improve log readability.</li> <li>UUID: primary identifier of the endpoint. The signaling server will    use this UUID to keep track of endpoints.</li> <li>Host address: host address of the Quart app for the endpoint.    Defaults to the IP address of host the endpoint is configured on.    Note: this address is only used by clients within the local network and    can be set to localhost if the client and endpoints are on the same    host.</li> <li>Port: port the Quart app for the endpoint will listening on. Defaults to    9753.</li> <li>Signaling server address: address of signaling server to use for peer    connections. All endpoints that may peer with each other must use the same    signaling server. Signaling servers are optional, and if unspecified, the    endpoint will operate without peering functionalities.</li> </ol> <p>Starting the endpoint will load the configuration from the ProxyStore home directory, initialize the endpoint, and start a Quart app using the host and port.</p> <pre><code>$ proxystore-endpoint start my-endpoint\n</code></pre>"},{"location":"guides/endpoints/#endpointstore","title":"EndpointStore","text":"<p>The primary interface to endpoints is the <code>EndpointStore</code>.</p> <p>Note</p> <p>This section assumes familiarity with proxies and the <code>Store</code> interface. See the Get Started guide before getting started with endpoints.</p> <pre><code>from proxystore.store.endpoint import EndpointStore\nstore = EndpointStore(\nname='default',\nendpoints=[\n'5349ffce-edeb-4a8b-94a6-ab16ade1c1a1',\n'd62910f6-0d29-452e-80b7-e0cd601949db',\n...\n],\n)\np = store.proxy(my_object)\n</code></pre> <p>The <code>EndpointStore</code> takes a list of endpoint UUIDs. This list represents any endpoint that proxies created by this store may interact with to resolve themselves. The <code>EndpointStore</code> will use this list to find its home endpoint, the endpoint that will be used to issue operations to. To find the home endpoint, the ProxyStore home directory will be scanned for any endpoint configurations matching the one of the UUIDs. If a match is found, the <code>EndpointStore</code> will attempt to connect to the endpoint using the host and port in the configuration. This process is repeated until a reachable endpoint is found. While the user could specify the home endpoint directly, the home endpoint may change when a proxy travels to a different machine.</p>"},{"location":"guides/endpoints/#proxy-lifecycle","title":"Proxy Lifecycle","text":"Figure 2: Flow of data when transferring objects via proxies and   endpoints.    <p>In distributed systems, proxies created from an <code>EndpointStore</code> can be used to facilitate simple and fast data communication. The flow of data and their associated proxies are shown in Fig. 2.</p> <ol> <li>Host A creates a proxy of the target object. The serialized target    is placed in Host A's home/local endpoint (Endpoint 1).    The proxy contains the key referencing the target, the endpoint UUID with    the target data (Endpoint 1's UUID), and the list of    all endpoint UUIDs configured with the    <code>EndpointStore</code>    (the UUIDs of Endpoints 1 and 2).</li> <li>Host A communicates the proxy object to Host B. This communication is    cheap because the proxy is just a thin reference to the object.</li> <li>Host B receives the proxy and attempts to use the proxy initiating the    proxy resolve process. The proxy requests the data from Host B's    home endpoint (Endpoint 2).</li> <li>Endpoint 2 sees that the proxy is requesting data from a different endpoint    (Endpoint 1) so Endpoint 2 initiates a peer connection to Endpoint 1 and    requests the data.</li> <li>Endpoint 1 sends the data to Endpoint 2.</li> <li>Endpoint 2 replies to Host B's request for the data with the data received    from Endpoint 2. Host B deserializes the target object and the proxy    is resolved.</li> </ol>"},{"location":"guides/endpoints/#hosting-a-signaling-server","title":"Hosting a Signaling Server","text":"<p>Currently, ProxyStore does not provided any publicly host signaling servers, though we hope to in the future! Hosting your own signaling server is simple if you have a host accessible from the internet (e.g., a compute instance from a cloud provider or a machine behind a NAT with an open port) and the ProxyStore package installed.</p> <pre><code>$ signaling-server --port 3579\n</code></pre>"},{"location":"guides/performance/","title":"Performance Tracking","text":"<p>The ProxyStore <code>Store</code> interface provides low-level performance tracking on store operations (e.g., <code>get</code> and <code>set</code>). Performance tracking is disable by default and can be enabled by passing <code>stats=True</code> to a <code>Store</code> constructor.</p> <pre><code>from proxystore.store.file import FileStore\nstore = FileStore(\nname=\"default\",\nstore_dir=\"/tmp/proxystore-dump\",\nstats=True,\n)\n</code></pre> <p>Performance statistics are aggregated on a per-key level and can be accessed via the <code>Store.stats()</code> method. <code>Store.stats()</code> takes a key (string) or <code>Proxy</code> and returns a dictionary mapping <code>Store</code> operations to <code>TimeStats</code> objects containing the aggregated statistics for the operation.</p> <p>Warning</p> <p>Performance statistics are local to each <code>Store</code> instance. In multi-process applications or applications that instantiate multiple <code>Store</code> instances, the statistics returned by <code>Store.stats()</code> will only represent a partial view of the overall performance.</p> <p>Warning</p> <p>Attempting to query <code>Store.stats()</code> without initializing the store to track stats will raise a <code>ValueError</code>.</p> <p>Continuing with the above <code>store</code> object, an instance of <code>FileStore</code> configured to track performance statistics, we can perform operations on <code>store</code> and inspect the statistics. In the following block, we add an object to the store and see that there are now performance statistics on the <code>FileStore.set()</code> and <code>FileStore.set_bytes()</code> operations.</p> <pre><code>target = list(range(0, 100))\nkey = store.set(target)\nstats = store.stats(key)\nstats.keys()\n# &gt;&gt;&gt; dict_keys(['set_bytes', 'set'])\nstats['set']\n# &gt;&gt;&gt; TimeStats(\n# &gt;&gt;&gt;     calls=1,\n# &gt;&gt;&gt;     avg_time_ms=0.0686,\n# &gt;&gt;&gt;     min_time_ms=0.0686,\n# &gt;&gt;&gt;     max_time_ms=0.0686,\n# &gt;&gt;&gt;     size_bytes=None,\n# &gt;&gt;&gt; )\nstats['set_bytes']\n# &gt;&gt;&gt; TimeStats(\n# &gt;&gt;&gt;     calls=1,\n# &gt;&gt;&gt;     avg_time_ms=0.0339,\n# &gt;&gt;&gt;     min_time_ms=0.0339,\n# &gt;&gt;&gt;     max_time_ms=0.0339,\n# &gt;&gt;&gt;     size_bytes=219,\n# &gt;&gt;&gt; )\n</code></pre> <p>Operations that work directly on bytes (i.e., <code>get_bytes()</code> and <code>set_bytes()</code>) will also note the size of the byte array used in the operation in the <code>TimeStats.size_bytes</code> attribute. As more operations are performed on the store, more statistics will be accumulated.</p> <pre><code>target = store.get(key)\nstats = store.stats(key)\nstats.keys()\n# &gt;&gt;&gt; dict_keys(\n# &gt;&gt;&gt;     ['set_bytes', 'set', 'is_cached', 'get_bytes', 'exists', 'get']\n# &gt;&gt;&gt; )\n# Attributes of `TimeStats` can be accessed directly\nstats['get'].calls\n# &gt;&gt;&gt; 1\nstats['get'].avg_time_ms\n# &gt;&gt;&gt; 0.0625\n# Check that the avg time of `get` decreases due to caching\n# when called twice in a row.\ntarget = store.get(key)\nstats = store.stats(key)\nstats['get'].calls\n# &gt;&gt;&gt; 2\nstats['get'].avg_time_ms\n# &gt;&gt;&gt; 0.0376\n</code></pre> <p>Performance statistics can also be accessed with a proxy.</p> <pre><code>target_proxy = store.proxy(target)\nstats = store.stats(target_proxy)\nstats.keys()\n# &gt;&gt;&gt; dict_keys(['set_bytes', 'set', 'proxy'])\nstats['proxy'].avg_time_ms\n# &gt;&gt;&gt; 0.0691\n</code></pre> <p>Proxies produced by a store with performance tracking enabled will also track statistics on time taken to resolve itself. When <code>Store.stats()</code> is passed a proxy, the method will inspect the proxy for any performance statistics and include any statistics in the result.</p> <pre><code># Access the proxy to force it to resolve.\ntarget_proxy[0:5]\n# &gt;&gt;&gt; [0, 1, 2, 3, 4]\nstats = store.stats(target_proxy)\nstats.keys()\n# &gt;&gt;&gt; dict_keys(\n# &gt;&gt;&gt;     ['resolve', 'set_bytes', 'set', 'proxy',\n# &gt;&gt;&gt;      'is_cached', 'get_bytes', 'exists', 'get']\n# &gt;&gt;&gt; )\nstats['resolve'].avg_time_ms\n# &gt;&gt;&gt; 0.0587\n</code></pre> <p>Python code used to generate the above examples can be found at https://github.com/proxystore/proxystore/blob/main/examples/store_stats.py.</p>"},{"location":"reference/","title":"proxystore","text":"<p>ProxyStore is a library for decoupling object communication from code.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>proxystore<ul> <li>proxystore.endpoint<ul> <li>proxystore.endpoint.cli</li> <li>proxystore.endpoint.commands</li> <li>proxystore.endpoint.config</li> <li>proxystore.endpoint.constants</li> <li>proxystore.endpoint.endpoint</li> <li>proxystore.endpoint.exceptions</li> <li>proxystore.endpoint.messages</li> <li>proxystore.endpoint.serve</li> <li>proxystore.endpoint.storage</li> </ul> </li> <li>proxystore.factory</li> <li>proxystore.globus</li> <li>proxystore.p2p<ul> <li>proxystore.p2p.chunks</li> <li>proxystore.p2p.client</li> <li>proxystore.p2p.connection</li> <li>proxystore.p2p.counter</li> <li>proxystore.p2p.exceptions</li> <li>proxystore.p2p.manager</li> <li>proxystore.p2p.messages</li> <li>proxystore.p2p.server</li> <li>proxystore.p2p.task</li> </ul> </li> <li>proxystore.proxy</li> <li>proxystore.serialize</li> <li>proxystore.store<ul> <li>proxystore.store.base</li> <li>proxystore.store.cache</li> <li>proxystore.store.dim<ul> <li>proxystore.store.dim.margo</li> <li>proxystore.store.dim.ucx</li> <li>proxystore.store.dim.utils</li> <li>proxystore.store.dim.websockets</li> <li>proxystore.store.dim.zmq</li> </ul> </li> <li>proxystore.store.endpoint</li> <li>proxystore.store.exceptions</li> <li>proxystore.store.file</li> <li>proxystore.store.globus</li> <li>proxystore.store.local</li> <li>proxystore.store.multi</li> <li>proxystore.store.redis</li> <li>proxystore.store.stats</li> <li>proxystore.store.utils</li> </ul> </li> <li>proxystore.utils</li> <li>proxystore.warnings</li> </ul> </li> </ul>"},{"location":"reference/factory/","title":"proxystore.factory","text":"<p>Factory implementations.</p> <p>Factories are callable classes that wrap up the functionality needed to resolve a proxy, where resolving is the process of retrieving the object from wherever it is stored such that the proxy can act as the object.</p>"},{"location":"reference/factory/#proxystore.factory.Factory","title":"Factory","text":"<pre><code>Factory() -&gt; None\n</code></pre> <p>         Bases: <code>Generic[T]</code></p> <p>Abstract Factory Class.</p> <p>A factory is a callable object that when called, returns an object. The <code>Proxy</code> constructor takes an instance of a factory and calls the factory when the proxy does its just-in-time resolution.</p> Note <p>If a custom factory is not-pickleable, <code>__getnewargs_ex__</code> may need to be implemented. Writing custom pickling functions is also beneifical to ensure that a pickled factory does not contain the object itself, just what is needed to resolve the object to keep the final pickled factory as small as possible.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def __init__(self) -&gt; None:\nraise NotImplementedError\n</code></pre>"},{"location":"reference/factory/#proxystore.factory.Factory.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; T\n</code></pre> <p>Alias <code>Factory.resolve()</code>.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def __call__(self) -&gt; T:\n\"\"\"Alias [`Factory.resolve()`][proxystore.factory.Factory.resolve].\"\"\"\nreturn self.resolve()\n</code></pre>"},{"location":"reference/factory/#proxystore.factory.Factory.resolve","title":"resolve","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Resolve and return object.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Resolve and return object.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/factory/#proxystore.factory.SimpleFactory","title":"SimpleFactory","text":"<pre><code>SimpleFactory(obj: T) -&gt; None\n</code></pre> <p>         Bases: <code>Factory[T]</code></p> <p>Simple Factory that stores object as class attribute.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T</code>)         \u2013 <p>Object to produce when factory is called.</p> </li> </ul> Source code in <code>proxystore/factory.py</code> <pre><code>def __init__(self, obj: T) -&gt; None:\nself._obj = obj\n</code></pre>"},{"location":"reference/factory/#proxystore.factory.SimpleFactory.resolve","title":"resolve","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Return the object.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Return the object.\"\"\"\nreturn self._obj\n</code></pre>"},{"location":"reference/factory/#proxystore.factory.LambdaFactory","title":"LambdaFactory","text":"<pre><code>LambdaFactory(\ntarget: Callable[..., T], *args: Any, **kwargs: Any\n) -&gt; None\n</code></pre> <p>         Bases: <code>Factory[T]</code></p> <p>Factory that takes any callable object.</p> <p>Parameters:</p> <ul> <li> target             (<code>Callable[..., T]</code>)         \u2013 <p>Callable object (function, class, lambda) to be invoked when the factory is resolved.</p> </li> <li> args             (<code>Any</code>)         \u2013 <p>Argument tuple for target invocation.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Dictionary of keyword arguments for target invocation.</p> </li> </ul> Source code in <code>proxystore/factory.py</code> <pre><code>def __init__(\nself,\ntarget: Callable[..., T],\n*args: Any,\n**kwargs: Any,\n) -&gt; None:\nself._target = target\nself._args = args\nself._kwargs = kwargs\n</code></pre>"},{"location":"reference/factory/#proxystore.factory.LambdaFactory.resolve","title":"resolve","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Return the target object.</p> Source code in <code>proxystore/factory.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Return the target object.\"\"\"\nreturn self._target(*self._args, **self._kwargs)\n</code></pre>"},{"location":"reference/globus/","title":"proxystore.globus","text":"<p>Globus OAuth tools.</p> <p>ProxyStore provides the <code>proxystore-globus-auth</code> CLI tool to give consent to the ProxyStore Globus Application.</p> <pre><code># basic authentication\nproxystore-globus-auth\n# delete old tokens\nproxystore-globus-auth --delete\n# give consent for specific collections\nproxystore-globus-auth --collections COLLECTION_UUID COLLECTION_UUID ...\n# specify additional scopes\nproxystore-globus-auth --scopes SCOPE SCOPE ...\n</code></pre> <p>Based on Parsl's implementation and the Globus examples.</p>"},{"location":"reference/globus/#proxystore.globus.GlobusAuthFileError","title":"GlobusAuthFileError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised if the Globus Auth token file cannot be read.</p>"},{"location":"reference/globus/#proxystore.globus.load_tokens_from_file","title":"load_tokens_from_file","text":"<pre><code>load_tokens_from_file(\nfilepath: str,\n) -&gt; dict[str, dict[str, Any]]\n</code></pre> <p>Load a set of saved tokens.</p> Source code in <code>proxystore/globus.py</code> <pre><code>def load_tokens_from_file(filepath: str) -&gt; dict[str, dict[str, Any]]:\n\"\"\"Load a set of saved tokens.\"\"\"\nwith open(filepath) as f:\ntokens = json.load(f)\nreturn tokens\n</code></pre>"},{"location":"reference/globus/#proxystore.globus.save_tokens_to_file","title":"save_tokens_to_file","text":"<pre><code>save_tokens_to_file(\nfilepath: str, tokens: globus_sdk.OAuthTokenResponse\n) -&gt; None\n</code></pre> <p>Save a set of tokens for later use.</p> Source code in <code>proxystore/globus.py</code> <pre><code>def save_tokens_to_file(\nfilepath: str,\ntokens: globus_sdk.OAuthTokenResponse,\n) -&gt; None:\n\"\"\"Save a set of tokens for later use.\"\"\"\nwith open(filepath, 'w') as f:\njson.dump(tokens.by_resource_server, f, indent=4)\n</code></pre>"},{"location":"reference/globus/#proxystore.globus.authenticate","title":"authenticate","text":"<pre><code>authenticate(\nclient_id: str,\nredirect_uri: str,\nrequested_scopes: Iterable[str] | None = None,\n) -&gt; globus_sdk.OAuthTokenResponse\n</code></pre> <p>Perform Native App auth flow.</p> Source code in <code>proxystore/globus.py</code> <pre><code>def authenticate(\nclient_id: str,\nredirect_uri: str,\nrequested_scopes: Iterable[str] | None = None,\n) -&gt; globus_sdk.OAuthTokenResponse:\n\"\"\"Perform Native App auth flow.\"\"\"\nclient = globus_sdk.NativeAppAuthClient(client_id=client_id)\nclient.oauth2_start_flow(\nredirect_uri=redirect_uri,\nrefresh_tokens=True,\nrequested_scopes=requested_scopes,\n)\nurl = client.oauth2_get_authorize_url()\nprint(f'Please visit the following url to authenticate:\\n{url}')\nauth_code = input('Enter the auth code: ').strip()\nreturn client.oauth2_exchange_code_for_tokens(auth_code)\n</code></pre>"},{"location":"reference/globus/#proxystore.globus.get_authorizer","title":"get_authorizer","text":"<pre><code>get_authorizer(\nclient_id: str, tokens_file: str, redirect_uri: str\n) -&gt; globus_sdk.RefreshTokenAuthorizer\n</code></pre> <p>Get an authorizer for the Globus SDK.</p> <p>Raises:</p> <ul> <li> <code>GlobusAuthFileError</code>           \u2013         <p>If <code>tokens_file</code> cannot be parsed.</p> </li> </ul> Source code in <code>proxystore/globus.py</code> <pre><code>def get_authorizer(\nclient_id: str,\ntokens_file: str,\nredirect_uri: str,\n) -&gt; globus_sdk.RefreshTokenAuthorizer:\n\"\"\"Get an authorizer for the Globus SDK.\n    Raises:\n        GlobusAuthFileError: If `tokens_file` cannot be parsed.\n    \"\"\"\ntry:\ntokens = load_tokens_from_file(tokens_file)\nexcept OSError as e:\nraise GlobusAuthFileError(\nf'Error loading tokens from {tokens_file}: {e}.',\n) from e\ntransfer_tokens = tokens['transfer.api.globus.org']\nauth_client = globus_sdk.NativeAppAuthClient(client_id=client_id)\nreturn globus_sdk.RefreshTokenAuthorizer(\ntransfer_tokens['refresh_token'],\nauth_client,\naccess_token=transfer_tokens['access_token'],\nexpires_at=transfer_tokens['expires_at_seconds'],\non_refresh=functools.partial(save_tokens_to_file, tokens_file),\n)\n</code></pre>"},{"location":"reference/globus/#proxystore.globus.proxystore_authenticate","title":"proxystore_authenticate","text":"<pre><code>proxystore_authenticate(\nproxystore_dir: str | None = None,\ncollections: list[str] | None = None,\nadditional_scopes: list[str] | None = None,\n) -&gt; None\n</code></pre> <p>Perform auth flow for ProxyStore native app.</p> Source code in <code>proxystore/globus.py</code> <pre><code>def proxystore_authenticate(\nproxystore_dir: str | None = None,\ncollections: list[str] | None = None,\nadditional_scopes: list[str] | None = None,\n) -&gt; None:\n\"\"\"Perform auth flow for ProxyStore native app.\"\"\"\nproxystore_dir = home_dir() if proxystore_dir is None else proxystore_dir\ntokens_file = os.path.join(proxystore_dir, _TOKENS_FILE)\nos.makedirs(proxystore_dir, exist_ok=True)\nscopes = _get_proxystore_scopes(collections, additional_scopes)\ntokens = authenticate(\nclient_id=_APPLICATION_ID,\nredirect_uri=_REDIRECT_URI,\nrequested_scopes=scopes,\n)\nsave_tokens_to_file(tokens_file, tokens)\n</code></pre>"},{"location":"reference/globus/#proxystore.globus.get_proxystore_authorizer","title":"get_proxystore_authorizer","text":"<pre><code>get_proxystore_authorizer(\nproxystore_dir: str | None = None,\n) -&gt; globus_sdk.RefreshTokenAuthorizer\n</code></pre> <p>Get an authorizer for the ProxyStore native app.</p> Source code in <code>proxystore/globus.py</code> <pre><code>def get_proxystore_authorizer(\nproxystore_dir: str | None = None,\n) -&gt; globus_sdk.RefreshTokenAuthorizer:\n\"\"\"Get an authorizer for the ProxyStore native app.\"\"\"\nproxystore_dir = home_dir() if proxystore_dir is None else proxystore_dir\ntokens_file = os.path.join(proxystore_dir, _TOKENS_FILE)\nreturn get_authorizer(\nclient_id=_APPLICATION_ID,\ntokens_file=tokens_file,\nredirect_uri=_REDIRECT_URI,\n)\n</code></pre>"},{"location":"reference/globus/#proxystore.globus.main","title":"main","text":"<pre><code>main(argv: Sequence[str] | None = None) -&gt; int\n</code></pre> <p>Perform Globus authentication.</p> <p>This function is the entrypoint for the <code>proxystore-globus-auth</code> CLI tool.</p> Source code in <code>proxystore/globus.py</code> <pre><code>def main(argv: Sequence[str] | None = None) -&gt; int:\n\"\"\"Perform Globus authentication.\n    This function is the entrypoint for the `proxystore-globus-auth` CLI tool.\n    \"\"\"\nparser = argparse.ArgumentParser(\n'ProxyStore Globus Auth Tool',\nformatter_class=argparse.ArgumentDefaultsHelpFormatter,\n)\nparser.add_argument(\n'--collections',\nnargs='+',\nhelp='Collection UUIDs to request scopes for.',\n)\nparser.add_argument(\n'--scopes',\nnargs='+',\nhelp='Additional scopes to request.',\n)\nparser.add_argument(\n'--delete',\naction='store_true',\nhelp='Delete existing authentication tokens.',\n)\nargs = parser.parse_args(argv)\nif args.delete:\ntokens_file = os.path.join(home_dir(), _TOKENS_FILE)\nif os.path.exists(tokens_file):\nos.remove(tokens_file)\nprint('Deleted tokens file.')\nreturn 0\nelse:\nprint('No tokens file found.')\nreturn 1\ntry:\nget_proxystore_authorizer()\nexcept GlobusAuthFileError:\nprint(\n'Performing authentication for the ProxyStore Globus Native app.',\n)\nproxystore_authenticate(\ncollections=args.collections,\nadditional_scopes=args.scopes,\n)\nget_proxystore_authorizer()\nprint('Globus authorization complete.')\nreturn 0\nelse:\nprint(\n'Globus authorization is already completed. To re-authenticate, '\n'delete your tokens (proxystore-globus-auth --delete) and try '\n'again.',\n)\nreturn 1\n</code></pre>"},{"location":"reference/proxy/","title":"proxystore.proxy","text":"<p>Proxy implementation and helpers.</p>"},{"location":"reference/proxy/#proxystore.proxy.Proxy","title":"Proxy","text":"<pre><code>Proxy(factory: FactoryType[T]) -&gt; None\n</code></pre> <p>         Bases: <code>slots.Proxy</code>, <code>Generic[T]</code></p> <p>Lazy Object Proxy.</p> <p>An extension of the Proxy from lazy-object-proxy with modified pickling behavior.</p> <p>An object proxy acts as a thin wrapper around a Python object, i.e. the proxy behaves identically to the underlying object. The proxy is initialized with a callable factory object. The factory returns the underlying object when called, i.e. 'resolves' the proxy. The does just-in-time resolution, i.e., the proxy does not call the factory until the first access to the proxy (hence, the lazy aspect of the proxy).</p> <p>The factory contains the mechanisms to appropriately resolve the object, e.g., which in the case for ProxyStore means requesting the correct object from the backend store.</p> <pre><code>x = np.array([1, 2, 3])\nf = ps.factory.SimpleFactory(x)\np = ps.proxy.Proxy(f)\nassert isinstance(p, np.ndarray)\nassert np.array_equal(p, [1, 2, 3])\n</code></pre> Note <p>The <code>factory</code>, by default, is only ever called once during the lifetime of a proxy instance.</p> Note <p>When a proxy instance is pickled, only the <code>factory</code> is pickled, not the wrapped object. Thus, proxy instances can be pickled and passed around cheaply, and once the proxy is unpickled and used, the <code>factory</code> will be called again to resolve the object.</p> Warning <p>Python bindings to other languages (e.g., C, C++) may throw type errors when receiving a <code>Proxy</code> instance. Casting the proxy or extracting the target object may be needed.</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; from proxystore.proxy import Proxy\n&gt;&gt;&gt; s = 'mystring'\n&gt;&gt;&gt; p = Proxy(lambda: s)\n&gt;&gt;&gt; io.StringIO(p)\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: initial_value must be str or None, not Proxy\n&gt;&gt;&gt; io.StringIO(str(p))  # succeeds\n</code></pre> <p>Parameters:</p> <ul> <li> factory             (<code>FactoryType[T]</code>)         \u2013 <p>Callable object that returns the underlying object when called.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If <code>factory</code> is not callable.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def __init__(self, factory: FactoryType[T]) -&gt; None:\nif not callable(factory):\nraise TypeError('factory must be callable')\nsuper().__init__(factory)\n</code></pre>"},{"location":"reference/proxy/#proxystore.proxy.ProxyLocker","title":"ProxyLocker","text":"<pre><code>ProxyLocker(proxy: Proxy[T]) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[T]</code></p> <p>Proxy locker that prevents resolution of wrapped proxies.</p> <p>The class prevents unintended access to a wrapped proxy to ensure a proxy is not resolved. The wrapped proxy can be retrieved with <code>proxy = ProxyLocker(proxy).unlock()</code>.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>Proxy[T]</code>)         \u2013 <p>Proxy to lock.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def __init__(self, proxy: Proxy[T]) -&gt; None:\nself._proxy = proxy\n</code></pre>"},{"location":"reference/proxy/#proxystore.proxy.ProxyLocker.unlock","title":"unlock","text":"<pre><code>unlock() -&gt; Proxy[T]\n</code></pre> <p>Retrieve the locked proxy.</p> <p>Returns:</p> <ul> <li> <code>Proxy[T]</code>         \u2013 <p>Proxy object.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def unlock(self) -&gt; Proxy[T]:\n\"\"\"Retrieve the locked proxy.\n    Returns:\n        Proxy object.\n    \"\"\"\nreturn super().__getattribute__('_proxy')\n</code></pre>"},{"location":"reference/proxy/#proxystore.proxy.extract","title":"extract","text":"<pre><code>extract(proxy: proxystore.proxy.Proxy[T]) -&gt; T\n</code></pre> <p>Return object wrapped by proxy.</p> <p>If the proxy has not been resolved yet, this will force the proxy to be resolved prior.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>proxystore.proxy.Proxy[T]</code>)         \u2013 <p>Proxy instance to extract from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code>         \u2013 <p>Object wrapped by proxy.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def extract(proxy: proxystore.proxy.Proxy[T]) -&gt; T:\n\"\"\"Return object wrapped by proxy.\n    If the proxy has not been resolved yet, this will force\n    the proxy to be resolved prior.\n    Args:\n        proxy: Proxy instance to extract from.\n    Returns:\n        Object wrapped by proxy.\n    \"\"\"\nreturn proxy.__wrapped__\n</code></pre>"},{"location":"reference/proxy/#proxystore.proxy.is_resolved","title":"is_resolved","text":"<pre><code>is_resolved(proxy: proxystore.proxy.Proxy[T]) -&gt; bool\n</code></pre> <p>Check if a proxy is resolved.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>proxystore.proxy.Proxy[T]</code>)         \u2013 <p>Proxy instance to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p><code>True</code> if <code>proxy</code> is resolved (i.e., the <code>factory</code> has been called)         and <code>False</code> otherwise.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def is_resolved(proxy: proxystore.proxy.Proxy[T]) -&gt; bool:\n\"\"\"Check if a proxy is resolved.\n    Args:\n        proxy: Proxy instance to check.\n    Returns:\n        `True` if `proxy` is resolved (i.e., the `factory` has been called) \\\n        and `False` otherwise.\n    \"\"\"\nreturn proxy.__resolved__\n</code></pre>"},{"location":"reference/proxy/#proxystore.proxy.resolve","title":"resolve","text":"<pre><code>resolve(proxy: proxystore.proxy.Proxy[T]) -&gt; None\n</code></pre> <p>Force a proxy to resolve itself.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>proxystore.proxy.Proxy[T]</code>)         \u2013 <p>Proxy instance to force resolve.</p> </li> </ul> Source code in <code>proxystore/proxy.py</code> <pre><code>def resolve(proxy: proxystore.proxy.Proxy[T]) -&gt; None:\n\"\"\"Force a proxy to resolve itself.\n    Args:\n        proxy: Proxy instance to force resolve.\n    \"\"\"\nproxy.__wrapped__\n</code></pre>"},{"location":"reference/serialize/","title":"proxystore.serialize","text":"<p>Serialization functions.</p>"},{"location":"reference/serialize/#proxystore.serialize.SerializationError","title":"SerializationError","text":"<p>         Bases: <code>Exception</code></p> <p>Base Serialization Exception.</p>"},{"location":"reference/serialize/#proxystore.serialize.serialize","title":"serialize","text":"<pre><code>serialize(obj: Any) -&gt; bytes\n</code></pre> <p>Serialize object.</p> <p>Objects are serialized using pickle (protocol 4) except for bytes or str objects. If pickle fails, cloudpickle is used as a fallback.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>Object to serialize.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>         \u2013 <p>Bytes that can be passed to         <code>deserialize()</code>.</p> </li> </ul> Source code in <code>proxystore/serialize.py</code> <pre><code>def serialize(obj: Any) -&gt; bytes:\n\"\"\"Serialize object.\n    Objects are serialized using\n    [pickle](https://docs.python.org/3/library/pickle.html) (protocol 4)\n    except for [bytes][] or [str][] objects.\n    If pickle fails, [cloudpickle](https://github.com/cloudpipe/cloudpickle)\n    is used as a fallback.\n    Args:\n        obj: Object to serialize.\n    Returns:\n        Bytes that can be passed to \\\n        [`deserialize()`][proxystore.serialize.deserialize].\n    \"\"\"\nif isinstance(obj, bytes):\nidentifier = b'01\\n'\nelif isinstance(obj, str):\nidentifier = b'02\\n'\nobj = obj.encode()\nelse:\n# Use cloudpickle if pickle fails\ntry:\nidentifier = b'03\\n'\n# Pickle protocol 4 is available in Python 3.7 and later but not\n# the default in Python 3.7 so manually specify it.\nobj = pickle.dumps(obj, protocol=4)\nexcept Exception:\nidentifier = b'04\\n'\nobj = cloudpickle.dumps(obj)\nassert isinstance(identifier, bytes)\nassert isinstance(obj, bytes)\nreturn identifier + obj\n</code></pre>"},{"location":"reference/serialize/#proxystore.serialize.deserialize","title":"deserialize","text":"<pre><code>deserialize(data: bytes) -&gt; Any\n</code></pre> <p>Deserialize object.</p> <p>Parameters:</p> <ul> <li> data             (<code>bytes</code>)         \u2013 <p>Bytes produced by <code>serialize()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>         \u2013 <p>The deserialized object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>data</code> is not of type <code>bytes</code>.</p> </li> <li> <code>SerializationError</code>           \u2013         <p>If the identifier of <code>data</code> is missing or invalid. The identifier is prepended to the string in <code>serialize()</code> to indicate which serialization method was used (e.g., no serialization, pickle, etc.).</p> </li> </ul> Source code in <code>proxystore/serialize.py</code> <pre><code>def deserialize(data: bytes) -&gt; Any:\n\"\"\"Deserialize object.\n    Args:\n        data: Bytes produced by\n            [`serialize()`][proxystore.serialize.serialize].\n    Returns:\n        The deserialized object.\n    Raises:\n        ValueError: If `data` is not of type `bytes`.\n        SerializationError: If the identifier of `data` is missing or\n            invalid. The identifier is prepended to the string in\n            [`serialize()`][proxystore.serialize.serialize] to indicate which\n            serialization method was used (e.g., no serialization, pickle,\n            etc.).\n    \"\"\"\nif not isinstance(data, bytes):\nraise ValueError(\nf'Expected data to be of type bytes, not {type(data)}.',\n)\nidentifier, separator, data = data.partition(b'\\n')\nif separator == b'' or len(identifier) != len(b'00'):\nraise SerializationError(\n'Data does not have required identifier for deserialization.',\n)\nif identifier == b'01':\nreturn data\nelif identifier == b'02':\nreturn data.decode()\nelif identifier == b'03':\nreturn pickle.loads(data)\nelif identifier == b'04':\nreturn cloudpickle.loads(data)\nelse:\nraise SerializationError(\nf'Unknown identifier {identifier!r} for deserialization,',\n)\n</code></pre>"},{"location":"reference/utils/","title":"proxystore.utils","text":"<p>General purpose utility functions.</p>"},{"location":"reference/utils/#proxystore.utils.chunk_bytes","title":"chunk_bytes","text":"<pre><code>chunk_bytes(\ndata: bytes, chunk_size: int\n) -&gt; Generator[bytes, None, None]\n</code></pre> <p>Yield chunks of binary data.</p> <p>Parameters:</p> <ul> <li> data             (<code>bytes</code>)         \u2013 <p>Data to be chunked.</p> </li> <li> chunk_size             (<code>int</code>)         \u2013 <p>Chunk size in bytes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Generator[bytes, None, None]</code>         \u2013 <p>Generator that yields chunks of bytes.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def chunk_bytes(\ndata: bytes,\nchunk_size: int,\n) -&gt; Generator[bytes, None, None]:\n\"\"\"Yield chunks of binary data.\n    Args:\n        data: Data to be chunked.\n        chunk_size: Chunk size in bytes.\n    Returns:\n        Generator that yields chunks of bytes.\n    \"\"\"\nlength = len(data)\nfor index in range(0, length, chunk_size):\nyield data[index : min(index + chunk_size, length)]\n</code></pre>"},{"location":"reference/utils/#proxystore.utils.create_key","title":"create_key","text":"<pre><code>create_key(obj: Any) -&gt; str\n</code></pre> <p>Generate key for the object.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>Object to create key for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>A random 128 bit string.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def create_key(obj: Any) -&gt; str:\n\"\"\"Generate key for the object.\n    Args:\n        obj: Object to create key for.\n    Returns:\n        A random 128 bit string.\n    \"\"\"\nreturn str(random.getrandbits(128))\n</code></pre>"},{"location":"reference/utils/#proxystore.utils.fullname","title":"fullname","text":"<pre><code>fullname(obj: Any) -&gt; str\n</code></pre> <p>Return full name of object.</p> Source code in <code>proxystore/utils.py</code> <pre><code>def fullname(obj: Any) -&gt; str:\n\"\"\"Return full name of object.\"\"\"\nif hasattr(obj, '__module__'):\nmodule = obj.__module__\nelse:\nmodule = obj.__class__.__module__\nif hasattr(obj, '__name__'):\nname = obj.__name__\nelse:\nname = obj.__class__.__name__\nif module is None or module == str.__module__:\nreturn name\nreturn f'{module}.{name}'\n</code></pre>"},{"location":"reference/utils/#proxystore.utils.home_dir","title":"home_dir","text":"<pre><code>home_dir() -&gt; str\n</code></pre> <p>Return the absolute path to the proxystore home directory.</p> <p>If set, <code>$PROXYSTORE_HOME</code> is preferred. Otherwise, <code>$XDG_DATA_HOME/proxystore</code> is returned where <code>$XDG_DATA_HOME</code> defaults to <code>$HOME/.local/share</code> if unset.</p> Source code in <code>proxystore/utils.py</code> <pre><code>def home_dir() -&gt; str:\n\"\"\"Return the absolute path to the proxystore home directory.\n    If set, ``$PROXYSTORE_HOME`` is preferred. Otherwise,\n    ``$XDG_DATA_HOME/proxystore`` is returned where ``$XDG_DATA_HOME`` defaults\n    to ``$HOME/.local/share`` if unset.\n    \"\"\"\npath = os.environ.get('PROXYSTORE_HOME')\nif path is None:\nprefix = os.environ.get('XDG_DATA_HOME') or os.path.expanduser(\n'~/.local/share',\n)\npath = os.path.join(prefix, 'proxystore')\nreturn os.path.abspath(path)\n</code></pre>"},{"location":"reference/utils/#proxystore.utils.hostname","title":"hostname","text":"<pre><code>hostname() -&gt; str\n</code></pre> <p>Return current hostname.</p> Source code in <code>proxystore/utils.py</code> <pre><code>def hostname() -&gt; str:\n\"\"\"Return current hostname.\"\"\"\nreturn socket.gethostname()\n</code></pre>"},{"location":"reference/utils/#proxystore.utils.bytes_to_readable","title":"bytes_to_readable","text":"<pre><code>bytes_to_readable(size: int, precision: int = 3) -&gt; str\n</code></pre> <p>Convert bytes to human readable value.</p> Note <p>This method uses base-10 values for KB, MB, GB, etc. instead of base-2 values (i.e., KiB, MiB, GiB, etc.).</p> <p>Parameters:</p> <ul> <li> size             (<code>int</code>)         \u2013 <p>Byte value to make readable.</p> </li> <li> precision             (<code>int</code>)         \u2013 <p>Number of decimal places.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>String with human readable number of bytes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If size is negative.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def bytes_to_readable(size: int, precision: int = 3) -&gt; str:\n\"\"\"Convert bytes to human readable value.\n    Note:\n        This method uses base-10 values for KB, MB, GB, etc. instead of\n        base-2 values (i.e., KiB, MiB, GiB, etc.).\n    Args:\n        size: Byte value to make readable.\n        precision: Number of decimal places.\n    Returns:\n        String with human readable number of bytes.\n    Raises:\n        ValueError: If size is negative.\n    \"\"\"\nkb = int(1e3)\nmb = int(1e6)\ngb = int(1e9)\ntb = int(1e12)\nsize_ = float(size)\nif 0 &lt;= size &lt; kb:\nsuffix = 'B'\nelif kb &lt;= size &lt; mb:\nsuffix = 'KB'\nsize_ /= kb\nelif mb &lt;= size &lt; gb:\nsuffix = 'MB'\nsize_ /= mb\nelif gb &lt;= size &lt; tb:\nsuffix = 'GB'\nsize_ /= gb\nelif tb &lt;= size:\nsuffix = 'TB'\nsize_ /= tb\nelse:\nraise ValueError(f'Size ({size}) cannot be negative.')\nvalue = str(round(size_, precision))\nvalue = value.rstrip('0').rstrip('.')\nreturn f'{value} {suffix}'\n</code></pre>"},{"location":"reference/utils/#proxystore.utils.readable_to_bytes","title":"readable_to_bytes","text":"<pre><code>readable_to_bytes(size: str) -&gt; int\n</code></pre> <p>Convert string with bytes units to the integer value of bytes.</p> Example <pre><code>&gt;&gt;&gt; readable_to_bytes('1.2 KB')\n1200\n&gt;&gt;&gt; readable_to_bytes('0.6 MiB')\n629146\n</code></pre> <p>Parameters:</p> <ul> <li> size             (<code>str</code>)         \u2013 <p>String to parse for bytes size.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Integer number of bytes parsed from the string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the input string contains more than two parts (i.e., a value and a unit).</p> </li> <li> <code>ValueError</code>           \u2013         <p>If the unit is not one of KB, MB, GB, TB, KiB, MiB, GiB, or TiB.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If the value cannot be cast to a float.</p> </li> </ul> Source code in <code>proxystore/utils.py</code> <pre><code>def readable_to_bytes(size: str) -&gt; int:\n\"\"\"Convert string with bytes units to the integer value of bytes.\n    Example:\n        ```python\n        &gt;&gt;&gt; readable_to_bytes('1.2 KB')\n        1200\n        &gt;&gt;&gt; readable_to_bytes('0.6 MiB')\n        629146\n        ```\n    Args:\n        size: String to parse for bytes size.\n    Returns:\n        Integer number of bytes parsed from the string.\n    Raises:\n        ValueError: If the input string contains more than two parts (i.e., a\n            value and a unit).\n        ValueError: If the unit is not one of KB, MB, GB, TB, KiB, MiB, GiB,\n            or TiB.\n        ValueError: If the value cannot be cast to a float.\n    \"\"\"\nunits_to_bytes = {\n'b': 1,\n'kb': int(1e3),\n'mb': int(1e6),\n'gb': int(1e9),\n'tb': int(1e12),\n'kib': int(2**10),\n'mib': int(2**20),\n'gib': int(2**30),\n'tib': int(2**40),\n}\n# Try casting size to value (will only work if no units)\ntry:\nreturn int(float(size))\nexcept ValueError:\npass\n# Ensure space between value and unit\nsize = re.sub(r'([a-zA-Z]+)', r' \\1', size.strip())\nparts = [s.strip() for s in size.split()]\nif len(parts) != 2:\nraise ValueError(\n'Input string \"{size}\" must contain only a value and a unit.',\n)\nvalue, unit = parts\ntry:\nvalue_size = decimal.Decimal(value)\nexcept decimal.InvalidOperation as e:\nraise ValueError(f'Unable to interpret \"{value}\" as a float.') from e\ntry:\nunit_size = units_to_bytes[unit.lower()]\nexcept KeyError as e:\nraise ValueError(f'Unknown unit type {unit}.') from e\nreturn int(value_size * unit_size)\n</code></pre>"},{"location":"reference/warnings/","title":"proxystore.warnings","text":"<p>Warning types.</p>"},{"location":"reference/warnings/#proxystore.warnings.ExperimentalWarning","title":"ExperimentalWarning","text":"<p>         Bases: <code>Warning</code></p> <p>ProxyStore experimental feature warning.</p>"},{"location":"reference/endpoint/","title":"proxystore.endpoint","text":"<p>Endpoints for direct, cross-site communication.</p> Note <p>Please refer to the Endpoints Guide for an introduction to endpoints in ProxyStore.</p> <p><code>Endponts</code> are in-memory object stores with peering capabilities. Endpoints enable data transfer between multiple sites using NAT traversal.</p>"},{"location":"reference/endpoint/cli/","title":"proxystore.endpoint.cli","text":"<p><code>proxystore-endpoint</code> command-line interface.</p>"},{"location":"reference/endpoint/cli/#proxystore.endpoint.cli.main","title":"main","text":"<pre><code>main(argv: Sequence[str] | None = None) -&gt; int\n</code></pre> <p>CLI for managing endpoints on the local system.</p> <p>Usage</p> <pre><code>$ proxystore-endpoint [command] {options}\n$ proxystore-endpoint --help\n</code></pre> Source code in <code>proxystore/endpoint/cli.py</code> <pre><code>def main(argv: Sequence[str] | None = None) -&gt; int:\n\"\"\"CLI for managing endpoints on the local system.\n    !!! note \"Usage\"\n        ```bash\n        $ proxystore-endpoint [command] {options}\n        $ proxystore-endpoint --help\n        ```\n    \"\"\"\nargv = argv if argv is not None else sys.argv[1:]\nparser = argparse.ArgumentParser(\nprog='proxystore-endpoint',\nformatter_class=argparse.ArgumentDefaultsHelpFormatter,\n)\n# https://stackoverflow.com/a/8521644/812183\nparser.add_argument(\n'-V',\n'--version',\naction='version',\nversion=f'%(prog)s {proxystore.__version__}',\n)\nparser.add_argument(\n'--log-level',\nchoices=['ERROR', 'WARNING', 'INFO', 'DEBUG'],\ndefault='INFO',\nhelp='logging level for CLI and any subprocesses',\n)\nsubparsers = parser.add_subparsers(dest='command')\n# Command: configure\nparser_configure = subparsers.add_parser(\n'configure',\nhelp='configure a new endpoint',\nformatter_class=argparse.ArgumentDefaultsHelpFormatter,\n)\nparser_configure.add_argument('name', help='name of endpoint')\nparser_configure.add_argument(\n'--port',\ntype=int,\ndefault=9753,\nhelp='port the endpoint should listen on',\n)\nparser_configure.add_argument(\n'--server',\ndefault=None,\nhelp='signaling server address for P2P connections',\n)\nparser_configure.add_argument(\n'--max-memory',\ndefault=None,\ntype=int,\nrequired='--dump-dir' in sys.argv,\nhelp='optional maximum number of bytes to store in memory',\n)\nparser_configure.add_argument(\n'--dump-dir',\ndefault=None,\nrequired='--max-memory' in sys.argv,\nhelp='optional directory to dump objects to if max_memory reached',\n)\nparser_configure.add_argument(\n'--peer-channels',\ndefault=1,\ntype=int,\nhelp='datachannels per peer connection',\n)\n# Command: list\nsubparsers.add_parser(\n'list',\nhelp='list all user endpoints',\nformatter_class=argparse.ArgumentDefaultsHelpFormatter,\n)\n# Command: remove\nparser_remove = subparsers.add_parser(\n'remove',\nhelp='remove an endpoint',\nformatter_class=argparse.ArgumentDefaultsHelpFormatter,\n)\nparser_remove.add_argument('name', help='name of endpoint')\n# Command: start\nparser_start = subparsers.add_parser(\n'start',\nhelp='start an endpoint',\nformatter_class=argparse.ArgumentDefaultsHelpFormatter,\n)\nparser_start.add_argument('name', help='name of endpoint')\nparser_start.add_argument(\n'--no-detach',\naction='store_true',\nhelp='do not detach the endpoint process',\n)\n# Command: stop\nparser_stop = subparsers.add_parser(\n'stop',\nhelp='stop an endpoint',\nformatter_class=argparse.ArgumentDefaultsHelpFormatter,\n)\nparser_stop.add_argument('name', help='name of endpoint')\n# Source: https://github.com/pre-commit/pre-commit\nparser_help = subparsers.add_parser(\n'help',\nhelp='show help for a specific command',\n)\nparser_help.add_argument(\n'help_command',\nnargs='?',\nhelp='command to show help for',\n)\nif len(argv) == 0:\nargv = ['--help']\n# https://stackoverflow.com/questions/46962065\nknown, unknown = parser.parse_known_args(argv)\nargs = parser.parse_args(unknown, namespace=known)\nif args.command == 'help' and args.help_command is not None:\nparser.parse_args([args.help_command, '--help'])\nelif args.command == 'help':\nparser.parse_args(['--help'])\nhandler = logging.StreamHandler(sys.stdout)\nhandler.setFormatter(_CLIFormatter())\nlogging.basicConfig(level=args.log_level, handlers=[handler])\nif args.command == 'configure':\nreturn configure_endpoint(\nargs.name,\nport=args.port,\nserver=args.server,\nmax_memory=args.max_memory,\ndump_dir=args.dump_dir,\npeer_channels=args.peer_channels,\n)\nelif args.command == 'list':\nreturn list_endpoints()\nelif args.command == 'remove':\nreturn remove_endpoint(args.name)\nelif args.command == 'start':\nreturn start_endpoint(\nargs.name,\ndetach=not args.no_detach,\nlog_level=args.log_level,\n)\nelif args.command == 'stop':\nreturn stop_endpoint(args.name)\nelse:\nraise NotImplementedError(\nf'{args.command} is not a supported command. '\n'Use --help for list of commands.',\n)\nraise AssertionError(f'{args.command} failed to exit with a return code.')\n</code></pre>"},{"location":"reference/endpoint/commands/","title":"proxystore.endpoint.commands","text":"<p>Endpoint management commands.</p> <p>These are the implementations of the commands available via the <code>proxystore-endpoint</code> command. Subsequently, all commands log errors and results and return status codes (rather than raising errors and returning results).</p>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus","title":"EndpointStatus","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Endpoint status.</p>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.RUNNING","title":"RUNNING  <code>class-attribute</code>","text":"<pre><code>RUNNING = enum.auto()\n</code></pre> <p>Endpoint is running on this host.</p>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.STOPPED","title":"STOPPED  <code>class-attribute</code>","text":"<pre><code>STOPPED = enum.auto()\n</code></pre> <p>Endpoint is stopped.</p>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code>","text":"<pre><code>UNKNOWN = enum.auto()\n</code></pre> <p>Endpoint cannot be found (missing/corrupted directory).</p>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.EndpointStatus.HANGING","title":"HANGING  <code>class-attribute</code>","text":"<pre><code>HANGING = enum.auto()\n</code></pre> <p>Endpoint PID file exists but process is not active.</p> <p>This is either because the process died unexpectedly or the endpoint is running on another host.</p>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.get_status","title":"get_status","text":"<pre><code>get_status(\nname: str, proxystore_dir: str | None = None\n) -&gt; EndpointStatus\n</code></pre> <p>Check status of endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to check.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EndpointStatus</code>         \u2013 <p><code>EndpointStatus.RUNNING</code> if the endpoint has a valid directory and         the PID file points to a running process.         <code>EndpointStatus.STOPPED</code> if the endpoint has a valid directory and no         PID file.         <code>EndpointStatus.UNKNOWN</code> if the endpoint directory is missing or the         config file is missing/unreadable.         <code>EndpointStatus.HANGING</code> if the endpoint has a valid directory but         the PID file does not point to a running process. This can be due to         the endpoint process dying unexpectedly or the endpoint process is on         a different host.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def get_status(name: str, proxystore_dir: str | None = None) -&gt; EndpointStatus:\n\"\"\"Check status of endpoint.\n    Args:\n        name: Name of endpoint to check.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        `EndpointStatus.RUNNING` if the endpoint has a valid directory and \\\n        the PID file points to a running process. \\\n        `EndpointStatus.STOPPED` if the endpoint has a valid directory and no \\\n        PID file. \\\n        `EndpointStatus.UNKNOWN` if the endpoint directory is missing or the \\\n        config file is missing/unreadable. \\\n        `EndpointStatus.HANGING` if the endpoint has a valid directory but \\\n        the PID file does not point to a running process. This can be due to \\\n        the endpoint process dying unexpectedly or the endpoint process is on \\\n        a different host.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\nif not os.path.isdir(endpoint_dir):\nreturn EndpointStatus.UNKNOWN\ntry:\nread_config(endpoint_dir)\nexcept (FileNotFoundError, ValueError) as e:\nlogger.error(e)\nreturn EndpointStatus.UNKNOWN\npid_file = get_pid_filepath(endpoint_dir)\nif not os.path.isfile(pid_file):\nreturn EndpointStatus.STOPPED\npid = int(open(pid_file).read().strip())\nif psutil.pid_exists(pid):\nreturn EndpointStatus.RUNNING\nelse:\nreturn EndpointStatus.HANGING\n</code></pre>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.configure_endpoint","title":"configure_endpoint","text":"<pre><code>configure_endpoint(\nname: str,\n*,\nport: int,\nserver: str | None,\nproxystore_dir: str | None = None,\nmax_memory: int | None = None,\ndump_dir: str | None = None,\npeer_channels: int = 1\n) -&gt; int\n</code></pre> <p>Configure a new endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port for endpoint to listen on.</p> </li> <li> server             (<code>str | None</code>)         \u2013 <p>Optional address of signaling server for P2P endpoint connections.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> <li> max_memory             (<code>int | None</code>)         \u2013 <p>Optional max memory in bytes to use for storing objects. If exceeded, LRU objects will be dumped to <code>dump_dir</code>.</p> </li> <li> dump_dir             (<code>str | None</code>)         \u2013 <p>Optional directory to dump objects to if the memory limit is exceeded.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>Number of datachannels per peer connection to another endpoint to communicate over.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def configure_endpoint(\nname: str,\n*,\nport: int,\nserver: str | None,\nproxystore_dir: str | None = None,\nmax_memory: int | None = None,\ndump_dir: str | None = None,\npeer_channels: int = 1,\n) -&gt; int:\n\"\"\"Configure a new endpoint.\n    Args:\n        name: Name of endpoint.\n        port: Port for endpoint to listen on.\n        server: Optional address of signaling server for P2P endpoint\n            connections.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n        max_memory: Optional max memory in bytes to use for storing\n            objects. If exceeded, LRU objects will be dumped to `dump_dir`.\n        dump_dir: Optional directory to dump objects to if the\n            memory limit is exceeded.\n        peer_channels: Number of datachannels per peer connection\n            to another endpoint to communicate over.\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\ntry:\ncfg = EndpointConfig(\nname=name,\nuuid=uuid.uuid4(),\nhost=None,\nport=port,\nserver=server,\nmax_memory=max_memory,\ndump_dir=dump_dir,\npeer_channels=peer_channels,\n)\nexcept ValueError as e:\nlogger.error(str(e))\nreturn 1\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\nif os.path.exists(endpoint_dir):\nlogger.error(f'An endpoint named {name} already exists.')\nlogger.info('To reconfigure the endpoint, remove and try again.')\nreturn 1\nwrite_config(cfg, endpoint_dir)\nlogger.info(f'Configured endpoint {cfg.name} &lt;{cfg.uuid}&gt;. Start with:')\nlogger.info(f'  $ proxystore-endpoint start {cfg.name}')\nreturn 0\n</code></pre>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.list_endpoints","title":"list_endpoints","text":"<pre><code>list_endpoints(*, proxystore_dir: str | None = None) -&gt; int\n</code></pre> <p>List available endpoints.</p> <p>Parameters:</p> <ul> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def list_endpoints(\n*,\nproxystore_dir: str | None = None,\n) -&gt; int:\n\"\"\"List available endpoints.\n    Args:\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoints = get_configs(proxystore_dir)\nif len(endpoints) == 0:\nlogger.info(f'No valid endpoint configurations in {proxystore_dir}.')\nelse:\neps = [(e.name, str(e.uuid)) for e in endpoints]\neps = sorted(eps, key=lambda x: x[0])\nlogger.info(f'{\"NAME\":&lt;18} {\"STATUS\":&lt;8} UUID', extra={'simple': True})\nlogger.info('=' * (19 + 9 + len(eps[0][1])), extra={'simple': True})\nfor name, uuid_ in eps:\nstatus = get_status(name, proxystore_dir)\nlogger.info(\nf'{name:18.18} {status.name:&lt;8.8} {uuid_}',\nextra={'simple': True},\n)\nreturn 0\n</code></pre>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.remove_endpoint","title":"remove_endpoint","text":"<pre><code>remove_endpoint(\nname: str, *, proxystore_dir: str | None = None\n) -&gt; int\n</code></pre> <p>Remove endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to remove.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def remove_endpoint(\nname: str,\n*,\nproxystore_dir: str | None = None,\n) -&gt; int:\n\"\"\"Remove endpoint.\n    Args:\n        name: Name of endpoint to remove.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nendpoint_dir = os.path.join(proxystore_dir, name)\nif not os.path.exists(endpoint_dir):\nlogger.error(f'An endpoint named {name} does not exist.')\nreturn 1\nstatus = get_status(name, proxystore_dir)\nif status in (EndpointStatus.RUNNING, EndpointStatus.HANGING):\nlogger.error('Endpoint must be stopped before removing.')\nlogger.error(f'  $ proxystore-endpoint stop {name}')\nreturn 1\nshutil.rmtree(endpoint_dir)\nlogger.info(f'Removed endpoint named {name}.')\nreturn 0\n</code></pre>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.start_endpoint","title":"start_endpoint","text":"<pre><code>start_endpoint(\nname: str,\n*,\ndetach: bool = False,\nlog_level: str = \"INFO\",\nproxystore_dir: str | None = None\n) -&gt; int\n</code></pre> <p>Start endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to start.</p> </li> <li> detach             (<code>bool</code>)         \u2013 <p>Start the endpoint as a daemon process.</p> </li> <li> log_level             (<code>str</code>)         \u2013 <p>Logging level of the endpoint.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def start_endpoint(\nname: str,\n*,\ndetach: bool = False,\nlog_level: str = 'INFO',\nproxystore_dir: str | None = None,\n) -&gt; int:\n\"\"\"Start endpoint.\n    Args:\n        name: Name of endpoint to start.\n        detach: Start the endpoint as a daemon process.\n        log_level: Logging level of the endpoint.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nstatus = get_status(name, proxystore_dir)\nif status == EndpointStatus.RUNNING:\nlogger.error(f'Endpoint {name} is already running.')\nreturn 1\nelif status == EndpointStatus.UNKNOWN:\nlogger.error(f'A valid endpoint named {name} does not exist.')\nlogger.error('Use `list` to see available endpoints.')\nreturn 1\nendpoint_dir = os.path.join(proxystore_dir, name)\ncfg = read_config(endpoint_dir)\n# Use IP address here which is generally more reliable\nhostname = socket.gethostbyname(utils.hostname())\npid_file = get_pid_filepath(endpoint_dir)\nif (\nstatus == EndpointStatus.HANGING\nand cfg.host is not None\nand hostname != cfg.host\n):\nlogger.error(\n'A PID file exists for the endpoint, but the config indicates the '\nf'endpoint is running on a host named {cfg.host}. Try stopping '\nf'the endpoint on {cfg.host}. Otherwise, delete the PID file at '\nf'{pid_file} and try again.',\n)\nreturn 1\nelif status == EndpointStatus.HANGING:\nlogger.debug(f'Removing invalid PID file ({pid_file}).')\nos.remove(pid_file)\n# Write out new config with host so clients can see the current host\ncfg.host = hostname\nwrite_config(cfg, endpoint_dir)\nlog_file = get_log_filepath(endpoint_dir)\nif detach:\nlogger.info('Starting endpoint process as daemon.')\nlogger.info(f'Logs will be written to {log_file}')\ncontext = daemon.DaemonContext(\nworking_directory=endpoint_dir,\numask=0o002,\npidfile=daemon.pidfile.PIDLockFile(pid_file),\ndetach_process=True,\n# Note: stdin, stdout, stderr left as None which binds to /dev/null\n)\nelse:\ncontext = _attached_pid_manager(pid_file)\n# TODO: handle sigterm/sigkill exit codes/graceful shutdown.\nwith context:\nserve(cfg, log_level=log_level, log_file=log_file)\nreturn 0\n</code></pre>"},{"location":"reference/endpoint/commands/#proxystore.endpoint.commands.stop_endpoint","title":"stop_endpoint","text":"<pre><code>stop_endpoint(\nname: str, *, proxystore_dir: str | None = None\n) -&gt; int\n</code></pre> <p>Stop endpoint.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of endpoint to start.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to <code>home_dir()</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Exit code where 0 is success and 1 is failure. Failure messages         are logged to the default logger.</p> </li> </ul> Source code in <code>proxystore/endpoint/commands.py</code> <pre><code>def stop_endpoint(name: str, *, proxystore_dir: str | None = None) -&gt; int:\n\"\"\"Stop endpoint.\n    Args:\n        name: Name of endpoint to start.\n        proxystore_dir: Optionally specify the proxystore home directory.\n            Defaults to [`home_dir()`][proxystore.utils.home_dir].\n    Returns:\n        Exit code where 0 is success and 1 is failure. Failure messages \\\n        are logged to the default logger.\n    \"\"\"\nif proxystore_dir is None:\nproxystore_dir = home_dir()\nstatus = get_status(name, proxystore_dir)\nif status == EndpointStatus.UNKNOWN:\nlogger.error(f'A valid endpoint named {name} does not exist.')\nlogger.error('Use `list` to see available endpoints.')\nreturn 1\nelif status == EndpointStatus.STOPPED:\nlogger.info(f'Endpoint {name} is not running.')\nreturn 0\nendpoint_dir = os.path.join(proxystore_dir, name)\ncfg = read_config(endpoint_dir)\nhostname = utils.hostname()\npid_file = get_pid_filepath(endpoint_dir)\nif (\nstatus == EndpointStatus.HANGING\nand cfg.host is not None\nand hostname != cfg.host\n):\nlogger.error(\n'A PID file exists for the endpoint, but the config indicates the '\nf'endpoint is running on a host named {cfg.host}. Try stopping '\nf'the endpoint on {cfg.host}. Otherwise, delete the PID file at '\nf'{pid_file} and try again.',\n)\nreturn 1\nelif status == EndpointStatus.HANGING:\nlogger.debug(f'Removing invalid PID file ({pid_file}).')\nos.remove(pid_file)\nlogger.info(f'Endpoint {name} is not running.')\nreturn 0\nassert status == EndpointStatus.RUNNING\nwith open(pid_file) as f:\npid = int(f.read().strip())\nlogger.debug(f'Terminating endpoint process (PID: {pid}).')\n# Source: https://github.com/funcx-faas/funcX/blob/facf37348f9a9eb4e1a0572793d7b6819be5754d/funcx_endpoint/funcx_endpoint/endpoint/endpoint.py#L360  # noqa: E501\nparent = psutil.Process(pid)\nprocesses = parent.children(recursive=True)\nprocesses.append(parent)\nfor p in processes:\np.send_signal(signal.SIGTERM)\nterminated, alive = psutil.wait_procs(processes, timeout=1)\nfor p in alive:  # pragma: no cover\ntry:\np.send_signal(signal.SIGKILL)\nexcept psutil.NoSuchProcess:\npass\nif os.path.isfile(pid_file):  # pragma: no branch\nlogger.debug(f'Cleaning up PID file ({pid_file}).')\nos.remove(pid_file)\nlogger.info(f'Endpoint {name} has been stopped.')\nreturn 0\n</code></pre>"},{"location":"reference/endpoint/config/","title":"proxystore.endpoint.config","text":"<p>Endpoint configuration.</p>"},{"location":"reference/endpoint/config/#proxystore.endpoint.config.EndpointConfig","title":"EndpointConfig  <code>dataclass</code>","text":"<p>Endpoint configuration.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Endpoint name.</p> </li> <li> uuid             (<code>uuid.UUID</code>)         \u2013 <p>Endpoint UUID.</p> </li> <li> host             (<code>str | None</code>)         \u2013 <p>Host endpoint is running on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port endpoint is running on.</p> </li> <li> server             (<code>str | None</code>)         \u2013 <p>Optional signaling server the endpoint should register with.</p> </li> <li> max_memory             (<code>int | None</code>)         \u2013 <p>Optional memory limit before demoting objects to disk.</p> </li> <li> max_object_size             (<code>int | None</code>)         \u2013 <p>Optional maximum object size.</p> </li> <li> dump_dir             (<code>str | None</code>)         \u2013 <p>Optional directory to put objects in when <code>max_memory</code> is exceeded.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>Number of peer channels to multiplex communications over.</p> </li> <li> verify_certificates             (<code>int</code>)         \u2013 <p>Validate the SSL certificates of <code>server</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the name does not contain only alphanumeric, dash, or underscore characters, if the UUID cannot be parsed, or if the port is not in the range [1, 65535].</p> </li> </ul>"},{"location":"reference/endpoint/config/#proxystore.endpoint.config.get_configs","title":"get_configs","text":"<pre><code>get_configs(proxystore_dir: str) -&gt; list[EndpointConfig]\n</code></pre> <p>Get all valid endpoint configurations in parent directory.</p> <p>Parameters:</p> <ul> <li> proxystore_dir             (<code>str</code>)         \u2013 <p>Parent directory containing possible endpoint configurations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[EndpointConfig]</code>         \u2013 <p>List of found configs.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def get_configs(proxystore_dir: str) -&gt; list[EndpointConfig]:\n\"\"\"Get all valid endpoint configurations in parent directory.\n    Args:\n        proxystore_dir: Parent directory containing possible endpoint\n            configurations.\n    Returns:\n        List of found configs.\n    \"\"\"\nendpoints: list[EndpointConfig] = []\nif not os.path.isdir(proxystore_dir):\nreturn endpoints\nfor dirpath, _, _ in os.walk(proxystore_dir):\nif os.path.samefile(proxystore_dir, dirpath):\ncontinue\ntry:\ncfg = read_config(dirpath)\nexcept FileNotFoundError:\ncontinue\nexcept ValueError:\ncontinue\nelse:\nendpoints.append(cfg)\nreturn endpoints\n</code></pre>"},{"location":"reference/endpoint/config/#proxystore.endpoint.config.get_log_filepath","title":"get_log_filepath","text":"<pre><code>get_log_filepath(endpoint_dir: str) -&gt; str\n</code></pre> <p>Return path to log file for endpoint.</p> <p>Parameters:</p> <ul> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory for the endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Path to log file.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def get_log_filepath(endpoint_dir: str) -&gt; str:\n\"\"\"Return path to log file for endpoint.\n    Args:\n        endpoint_dir: Directory for the endpoint.\n    Returns:\n        Path to log file.\n    \"\"\"\nreturn os.path.join(endpoint_dir, _ENDPOINT_LOG_FILE)\n</code></pre>"},{"location":"reference/endpoint/config/#proxystore.endpoint.config.get_pid_filepath","title":"get_pid_filepath","text":"<pre><code>get_pid_filepath(endpoint_dir: str) -&gt; str\n</code></pre> <p>Return path to PID file for endpoint.</p> <p>Parameters:</p> <ul> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory for the endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Path to PID file.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def get_pid_filepath(endpoint_dir: str) -&gt; str:\n\"\"\"Return path to PID file for endpoint.\n    Args:\n        endpoint_dir: Directory for the endpoint.\n    Returns:\n        Path to PID file.\n    \"\"\"\nreturn os.path.join(endpoint_dir, _ENDPOINT_PID_FILE)\n</code></pre>"},{"location":"reference/endpoint/config/#proxystore.endpoint.config.read_config","title":"read_config","text":"<pre><code>read_config(endpoint_dir: str) -&gt; EndpointConfig\n</code></pre> <p>Read endpoint config file.</p> <p>Parameters:</p> <ul> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory containing endpoint configuration file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EndpointConfig</code>         \u2013 <p>Config found in <code>endpoint_dir</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>           \u2013         <p>If a config files does not exist in the directory.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If config contains an invalid value or cannot be parsed.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def read_config(endpoint_dir: str) -&gt; EndpointConfig:\n\"\"\"Read endpoint config file.\n    Args:\n        endpoint_dir: Directory containing endpoint configuration file.\n    Returns:\n        Config found in `endpoint_dir`.\n    Raises:\n        FileNotFoundError: If a config files does not exist in the directory.\n        ValueError: If config contains an invalid value or cannot be parsed.\n    \"\"\"\npath = os.path.join(endpoint_dir, _ENDPOINT_CONFIG_FILE)\nif os.path.exists(path):\nwith open(path) as f:\ntry:\ncfg_json = json.load(f)\nexcept json.decoder.JSONDecodeError as e:\nraise ValueError(\nf'Unable to parse ({path}): {str(e)}.',\n) from None\ntry:\ncfg = EndpointConfig(**cfg_json)\nexcept TypeError as e:\nraise ValueError(\nf'Keys in config ({path}) do not match expected: {str(e)}.',\n) from None\nreturn cfg\nelse:\nraise FileNotFoundError(\nf'Endpoint directory {endpoint_dir} does not contain a valid '\n'configuration.',\n)\n</code></pre>"},{"location":"reference/endpoint/config/#proxystore.endpoint.config.validate_name","title":"validate_name","text":"<pre><code>validate_name(name: str) -&gt; bool\n</code></pre> <p>Validate name only contains alphanumeric or dash/underscore chars.</p> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def validate_name(name: str) -&gt; bool:\n\"\"\"Validate name only contains alphanumeric or dash/underscore chars.\"\"\"\nreturn len(re.findall(r'[^A-Za-z0-9_\\-]', name)) == 0 and len(name) &gt; 0\n</code></pre>"},{"location":"reference/endpoint/config/#proxystore.endpoint.config.write_config","title":"write_config","text":"<pre><code>write_config(\ncfg: EndpointConfig, endpoint_dir: str\n) -&gt; None\n</code></pre> <p>Write config to endpoint directory.</p> <p>Parameters:</p> <ul> <li> cfg             (<code>EndpointConfig</code>)         \u2013 <p>Configuration to write.</p> </li> <li> endpoint_dir             (<code>str</code>)         \u2013 <p>Directory to write config to.</p> </li> </ul> Source code in <code>proxystore/endpoint/config.py</code> <pre><code>def write_config(cfg: EndpointConfig, endpoint_dir: str) -&gt; None:\n\"\"\"Write config to endpoint directory.\n    Args:\n        cfg: Configuration to write.\n        endpoint_dir: Directory to write config to.\n    \"\"\"\nos.makedirs(endpoint_dir, exist_ok=True)\npath = os.path.join(endpoint_dir, _ENDPOINT_CONFIG_FILE)\nwith open(path, 'w') as f:\ndata = dataclasses.asdict(cfg)\ndata['uuid'] = str(data['uuid'])\njson.dump(data, f, indent=4)\n# Add newline so cat on the file looks better\nf.write('\\n')\n</code></pre>"},{"location":"reference/endpoint/constants/","title":"proxystore.endpoint.constants","text":"<p>Endpoint constants.</p>"},{"location":"reference/endpoint/constants/#proxystore.endpoint.constants.MAX_CHUNK_LENGTH","title":"MAX_CHUNK_LENGTH  <code>module-attribute</code>","text":"<pre><code>MAX_CHUNK_LENGTH = 16 * 1000 * 1000\n</code></pre> <p>Maximum chunk length (bytes) for GET/SET requests to/from the endpoint.</p>"},{"location":"reference/endpoint/constants/#proxystore.endpoint.constants.MAX_OBJECT_SIZE_DEFAULT","title":"MAX_OBJECT_SIZE_DEFAULT  <code>module-attribute</code>","text":"<pre><code>MAX_OBJECT_SIZE_DEFAULT = int(1000000000.0)\n</code></pre> <p>Default maximum endpoint object size in bytes.</p>"},{"location":"reference/endpoint/endpoint/","title":"proxystore.endpoint.endpoint","text":"<p>Endpoint implementation.</p>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.EndpointMode","title":"EndpointMode","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Endpoint mode.</p>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.EndpointMode.PEERING","title":"PEERING  <code>class-attribute</code>","text":"<pre><code>PEERING = 1\n</code></pre> <p>Endpoint will establish peer connections with other endpoints.</p>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.EndpointMode.SOLO","title":"SOLO  <code>class-attribute</code>","text":"<pre><code>SOLO = 2\n</code></pre> <p>Endpoint is operating in isolation and will ignore peer requests.</p>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint","title":"Endpoint","text":"<pre><code>Endpoint(\nname: str,\nuuid: UUID,\nsignaling_server: str | None = None,\npeer_timeout: int = 30,\nmax_memory: int | None = None,\nmax_object_size: int | None = MAX_OBJECT_SIZE_DEFAULT,\ndump_dir: str | None = None,\npeer_channels: int = 1,\nverify_certificate: bool = True,\n) -&gt; None\n</code></pre> <p>ProxyStore Endpoint.</p> <p>An endpoint is an object store with <code>get</code>/<code>set</code> functionality.</p> <p>By default, an endpoint operates in <code>EndpointMode.SOLO</code> mode where the endpoint acts just as an isolated object store. Endpoints can also be configured in <code>EndpointMode.PEERING</code> mode by initializing the endpoint with a signaling server address. The signaling server is used to establish peer-to-peer connections with other endpoints after which endpoints can forward operations between each other. Peering is available even when endpoints are being separate NATs. See the proxystore.p2p module to learn more about peering.</p> Warning <p>Requests made to remote endpoints will only invoke the request on the remote and return the result. I.e., invoking GET on a remote will return the value but will not store it on the local endpoint.</p> Example <p>Solo Mode Usage</p> <pre><code>async with Endpoint('ep1', uuid.uuid4()) as endpoint:\nserialized_data = b'data string'\nendpoint.set('key', serialized_data)\nassert endpoint.get('key') == serialized_data\nendpoint.evict('key')\nassert not endpoint.exists('key')\n</code></pre> Example <p>Peering Mode Usage</p> <pre><code>ep1 = await Endpoint('ep1', uuid.uuid4(), signaling_server)\nep2 = await Endpoint('ep1', uuid.uuid4(), signaling_server)\nserialized_data = b'data string'\nep1.set('key', serialized_data)\nassert ep2.get('key', endpoint=ep1.uuid) == serialized_data\nassert ep1.exists('key')\nassert not ep1.exists('key', endpoint=ep2.uuid)\nep1.close()\nep2.close()\n</code></pre> Note <p>Endpoints can be configured and started via the <code>proxystore-endpoint</code> command-line interface.</p> Note <p>If the endpoint is being used in peering mode, the endpoint should be used as a context manager or initialized with await. This will ensure <code>Endpoint.async_init()</code> is executed which connects to the signaling server and established a listener for incoming messages.</p> <pre><code>endpoint = await Endpoint(...)\nendpoint.close()\n</code></pre> <pre><code>async with Endpoint(...) as endpoint:\n...\n</code></pre> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Readable name of endpoint.</p> </li> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of the endpoint.</p> </li> <li> signaling_server             (<code>str | None</code>)         \u2013 <p>Address of signaling server used for peer-to-peer connections between endpoints. If None, endpoint will not be able to communicate with other endpoints.</p> </li> <li> peer_timeout             (<code>int</code>)         \u2013 <p>Timeout for establishing p2p connection with another endpoint.</p> </li> <li> max_memory             (<code>int | None</code>)         \u2013 <p>Optional max memory in bytes to use for storing objects. If exceeded, LRU objects will be dumped to <code>dump_dir</code>.</p> </li> <li> max_object_size             (<code>int | None</code>)         \u2013 <p>Optional max size in bytes for any single object stored by the endpoint. If exceeded, an error is raised.</p> </li> <li> dump_dir             (<code>str | None</code>)         \u2013 <p>Optional directory to dump objects to if the memory limit is exceeded.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>Number of datachannels per peer connection to another endpoint to communicate over.</p> </li> <li> verify_certificate             (<code>bool</code>)         \u2013 <p>Verify the signaling server's SSL certificate. This should almost never be disabled except for testing with self-signed certificates.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>def __init__(\nself,\nname: str,\nuuid: UUID,\nsignaling_server: str | None = None,\npeer_timeout: int = 30,\nmax_memory: int | None = None,\nmax_object_size: int | None = MAX_OBJECT_SIZE_DEFAULT,\ndump_dir: str | None = None,\npeer_channels: int = 1,\nverify_certificate: bool = True,\n) -&gt; None:\n# TODO(gpauloski): need to consider semantics of operations\n#   - can all ops be triggered on remote?\n#   - or just get? do we move data permanently on get? etc...\nself._name = name\nself._uuid = uuid\nself._signaling_server = signaling_server\nself._peer_timeout = peer_timeout\nself._peer_channels = peer_channels\nself._verify_certificate = verify_certificate\nself._mode = (\nEndpointMode.SOLO\nif signaling_server is None\nelse EndpointMode.PEERING\n)\nself._peer_manager: PeerManager | None = None\nself._data = EndpointStorage(\nmax_size=max_memory,\nmax_object_size=max_object_size,\ndump_dir=dump_dir,\n)\nself._pending_requests: dict[\nstr,\nasyncio.Future[EndpointRequest],\n] = {}\nself._async_init_done = False\nself._peer_handler_task: asyncio.Task[None] | None = None\nlogger.info(\nf'{self._log_prefix}: initialized endpoint operating '\nf'in {self._mode.name} mode',\n)\n</code></pre>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: UUID\n</code></pre> <p>UUID of this endpoint.</p>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of this endpoint.</p>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.async_init","title":"async_init  <code>async</code>","text":"<pre><code>async_init() -&gt; None\n</code></pre> <p>Initialize connections and tasks necessary for peering.</p> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def async_init(self) -&gt; None:\n\"\"\"Initialize connections and tasks necessary for peering.\"\"\"\nif self._signaling_server is not None and not self._async_init_done:\nself._peer_manager = await PeerManager(\nuuid=self.uuid,\nsignaling_server=self._signaling_server,\nname=self.name,\ntimeout=self._peer_timeout,\npeer_channels=self._peer_channels,\nverify_certificate=self._verify_certificate,\n)\nself._peer_handler_task = spawn_guarded_background_task(\nself._handle_peer_requests,\n)\nlogger.info(f'{self._log_prefix}: initialized peer manager')\nself._async_init_done = True\n</code></pre>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.evict","title":"evict  <code>async</code>","text":"<pre><code>evict(key: str, endpoint: UUID | None = None) -&gt; None\n</code></pre> <p>Evict key from endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to evict.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def evict(self, key: str, endpoint: UUID | None = None) -&gt; None:\n\"\"\"Evict key from endpoint.\n    Args:\n        key: Key to evict.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Raises:\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: EVICT key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='evict',\nuuid=str(uuid4()),\nkey=key,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nawait request_future\nelse:\nif key in self._data:\ndel self._data[key]\n</code></pre>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(key: str, endpoint: UUID | None = None) -&gt; bool\n</code></pre> <p>Check if key exists on endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to check.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the key exists.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def exists(self, key: str, endpoint: UUID | None = None) -&gt; bool:\n\"\"\"Check if key exists on endpoint.\n    Args:\n        key: Key to check.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Returns:\n        If the key exists.\n    Raises:\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: EXISTS key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='exists',\nuuid=str(uuid4()),\nkey=key,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nresponse = await request_future\nassert isinstance(response.exists, bool)\nreturn response.exists\nelse:\nreturn key in self._data\n</code></pre>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.get","title":"get  <code>async</code>","text":"<pre><code>get(key: str, endpoint: UUID | None = None) -&gt; bytes | None\n</code></pre> <p>Get value associated with key on endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to get value for.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Value associated with key.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def get(\nself,\nkey: str,\nendpoint: UUID | None = None,\n) -&gt; bytes | None:\n\"\"\"Get value associated with key on endpoint.\n    Args:\n        key: Key to get value for.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Returns:\n        Value associated with key.\n    Raises:\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: GET key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='get',\nuuid=str(uuid4()),\nkey=key,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nresponse = await request_future\nreturn response.data\nelse:\nif key in self._data:\nreturn self._data[key]\nelse:\nreturn None\n</code></pre>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.set","title":"set  <code>async</code>","text":"<pre><code>set(\nkey: str, data: bytes, endpoint: UUID | None = None\n) -&gt; None\n</code></pre> <p>Set key with data on endpoint.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key to associate with value.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Value to associate with key.</p> </li> <li> endpoint             (<code>UUID | None</code>)         \u2013 <p>Endpoint to perform operation on. If unspecified or if the endpoint is on solo mode, the operation will be performed on the local endpoint.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ObjectSizeExceededError</code>           \u2013         <p>If the max object size is configured and the data exceeds that size.</p> </li> <li> <code>PeerRequestError</code>           \u2013         <p>If request to a peer endpoint fails.</p> </li> </ul> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def set(\nself,\nkey: str,\ndata: bytes,\nendpoint: UUID | None = None,\n) -&gt; None:\n\"\"\"Set key with data on endpoint.\n    Args:\n        key: Key to associate with value.\n        data: Value to associate with key.\n        endpoint: Endpoint to perform operation on. If\n            unspecified or if the endpoint is on solo mode, the operation\n            will be performed on the local endpoint.\n    Raises:\n        ObjectSizeExceededError: If the max object size is configured and\n            the data exceeds that size.\n        PeerRequestError: If request to a peer endpoint fails.\n    \"\"\"\nlogger.debug(\nf'{self._log_prefix}: SET key={key} on endpoint={endpoint}',\n)\nif self._is_peer_request(endpoint):\nassert endpoint is not None\nrequest = EndpointRequest(\nkind='request',\nop='set',\nuuid=str(uuid4()),\nkey=key,\ndata=data,\n)\nrequest_future = await self._request_from_peer(endpoint, request)\nawait request_future\nelse:\nself._data[key] = data\n</code></pre>"},{"location":"reference/endpoint/endpoint/#proxystore.endpoint.endpoint.Endpoint.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the endpoint and any open connections safely.</p> Source code in <code>proxystore/endpoint/endpoint.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the endpoint and any open connections safely.\"\"\"\nif self._peer_handler_task is not None:\nself._peer_handler_task.cancel()\ntry:\nawait self._peer_handler_task\nexcept asyncio.CancelledError:\npass\nif self._peer_manager is not None:\nawait self._peer_manager.close()\nself._data.cleanup()\nlogger.info(f'{self._log_prefix}: endpoint close')\n</code></pre>"},{"location":"reference/endpoint/exceptions/","title":"proxystore.endpoint.exceptions","text":"<p>Endpoint exceptions.</p>"},{"location":"reference/endpoint/exceptions/#proxystore.endpoint.exceptions.FileDumpNotAvailableError","title":"FileDumpNotAvailableError","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when dumping objects to file is not available.</p>"},{"location":"reference/endpoint/exceptions/#proxystore.endpoint.exceptions.ObjectSizeExceededError","title":"ObjectSizeExceededError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when an object exceeds the max allowable size.</p>"},{"location":"reference/endpoint/exceptions/#proxystore.endpoint.exceptions.PeeringNotAvailableError","title":"PeeringNotAvailableError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception when a peer request is made but peering is not available.</p>"},{"location":"reference/endpoint/exceptions/#proxystore.endpoint.exceptions.PeerRequestError","title":"PeerRequestError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when a request to a peer fails.</p>"},{"location":"reference/endpoint/messages/","title":"proxystore.endpoint.messages","text":"<p>Endpoint to endpoint messages.</p>"},{"location":"reference/endpoint/messages/#proxystore.endpoint.messages.EndpointRequest","title":"EndpointRequest  <code>dataclass</code>","text":"<p>Message type for requests between endpoints.</p> <p>Attributes:</p> <ul> <li> kind             (<code>Literal[request, response]</code>)         \u2013 <p>One of <code>'request'</code> or <code>'response'</code>.</p> </li> <li> op             (<code>Literal[evict, exists, get, set]</code>)         \u2013 <p>One of <code>'evict'</code>, <code>'exists'</code>, <code>'get'</code>, or <code>'set'</code>.</p> </li> <li> uuid             (<code>str</code>)         \u2013 <p>UUID of sender.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>Key to operate on.</p> </li> <li> data             (<code>bytes | None</code>)         \u2013 <p>Optional data to operate on.</p> </li> <li> exists             (<code>bool | None</code>)         \u2013 <p>Result of <code>exists</code> operation.</p> </li> <li> error             (<code>Exception | None</code>)         \u2013 <p>Error raised by operation.</p> </li> </ul>"},{"location":"reference/endpoint/serve/","title":"proxystore.endpoint.serve","text":"<p>Endpoint serving.</p>"},{"location":"reference/endpoint/serve/#proxystore.endpoint.serve.create_app","title":"create_app","text":"<pre><code>create_app(\nendpoint: Endpoint,\nmax_content_length: int | None = None,\nbody_timeout: int = 300,\n) -&gt; quart.Quart\n</code></pre> <p>Create quart app for endpoint and registers routes.</p> <p>Parameters:</p> <ul> <li> endpoint             (<code>Endpoint</code>)         \u2013 <p>Initialized endpoint to forward quart routes to.</p> </li> <li> max_content_length             (<code>int | None</code>)         \u2013 <p>Max request body size in bytes.</p> </li> <li> body_timeout             (<code>int</code>)         \u2013 <p>Number of seconds to wait for the body to be completely received.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>quart.Quart</code>         \u2013 <p>Quart app.</p> </li> </ul> Source code in <code>proxystore/endpoint/serve.py</code> <pre><code>def create_app(\nendpoint: Endpoint,\nmax_content_length: int | None = None,\nbody_timeout: int = 300,\n) -&gt; quart.Quart:\n\"\"\"Create quart app for endpoint and registers routes.\n    Args:\n        endpoint: Initialized endpoint to forward quart routes to.\n        max_content_length: Max request body size in bytes.\n        body_timeout: Number of seconds to wait for the body to be\n            completely received.\n    Returns:\n        Quart app.\n    \"\"\"\napp = quart.Quart(__name__)\napp.config['endpoint'] = endpoint\napp.register_blueprint(routes_blueprint, url_prefix='')\nlogger.info(\n'quart routes registered to endpoint '\nf'{endpoint.uuid} ({endpoint.name})',\n)\napp.config['MAX_CONTENT_LENGTH'] = max_content_length\napp.config['BODY_TIMEOUT'] = body_timeout\nreturn app\n</code></pre>"},{"location":"reference/endpoint/serve/#proxystore.endpoint.serve.serve","title":"serve","text":"<pre><code>serve(\nconfig: EndpointConfig,\n*,\nlog_level: int | str = logging.INFO,\nlog_file: str | None = None,\nuse_uvloop: bool = True\n) -&gt; None\n</code></pre> <p>Initialize endpoint and serve Quart app.</p> Warning <p>This function does not return until the Quart app is terminated.</p> <p>Parameters:</p> <ul> <li> config             (<code>EndpointConfig</code>)         \u2013 <p>Configuration object.</p> </li> <li> log_level             (<code>int | str</code>)         \u2013 <p>Logging level of endpoint.</p> </li> <li> log_file             (<code>str | None</code>)         \u2013 <p>Optional file path to append log to.</p> </li> <li> use_uvloop             (<code>bool</code>)         \u2013 <p>Install uvloop as the default event loop implementation.</p> </li> </ul> Source code in <code>proxystore/endpoint/serve.py</code> <pre><code>def serve(\nconfig: EndpointConfig,\n*,\nlog_level: int | str = logging.INFO,\nlog_file: str | None = None,\nuse_uvloop: bool = True,\n) -&gt; None:\n\"\"\"Initialize endpoint and serve Quart app.\n    Warning:\n        This function does not return until the Quart app is terminated.\n    Args:\n        config: Configuration object.\n        log_level: Logging level of endpoint.\n        log_file: Optional file path to append log to.\n        use_uvloop: Install uvloop as the default event loop implementation.\n    \"\"\"\nif config.host is None:\nraise ValueError('EndpointConfig has NoneType as host.')\nif log_file is not None:\nparent_dir = os.path.dirname(log_file)\nif not os.path.isdir(parent_dir):\nos.makedirs(parent_dir, exist_ok=True)\nlogging.getLogger().handlers.append(logging.FileHandler(log_file))\nfor handler in logging.getLogger().handlers:\nhandler.setFormatter(\nlogging.Formatter(\n'[%(asctime)s.%(msecs)03d] %(levelname)-5s (%(name)s) :: '\n'%(message)s',\ndatefmt='%Y-%m-%d %H:%M:%S',\n),\n)\nlogging.getLogger().setLevel(log_level)\nkwargs = dataclasses.asdict(config)\n# These are the only two EndpointConfig attributes not passed to the\n# Endpoint constructor\nkwargs.pop('host', None)\nkwargs.pop('port', None)\n# Backwards compatibility hack because EndpointConfig and Endpoint call\n# the signaling server fields differently\nkwargs['signaling_server'] = kwargs.pop('server')\nendpoint = Endpoint(**kwargs)\napp = create_app(endpoint)\nserve_config = hypercorn.config.Config()\nserve_config.bind = [f'{config.host}:{config.port}']\nserve_config.accesslog = logging.getLogger('hypercorn.access')\nserve_config.errorlog = logging.getLogger('hypercorn.error')\nif use_uvloop:  # pragma: no cover\nlogger.debug('installing uvloop as default event loop')\nuvloop.install()\nlogger.info(\nf'serving endpoint {endpoint.uuid} ({endpoint.name}) on '\nf'{config.host}:{config.port}',\n)\nlogger.info(f'config: {config}')\nasyncio.run(hypercorn.asyncio.serve(app, serve_config))\n</code></pre>"},{"location":"reference/endpoint/storage/","title":"proxystore.endpoint.storage","text":"<p>Storage interface for blobs.</p>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.BlobLocation","title":"BlobLocation","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Location of Blob.</p>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.BlobLocation.MEMORY","title":"MEMORY  <code>class-attribute</code>","text":"<pre><code>MEMORY = 1\n</code></pre> <p>Blob is loaded in memory.</p>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.BlobLocation.FILE","title":"FILE  <code>class-attribute</code>","text":"<pre><code>FILE = 2\n</code></pre> <p>Blob is stored on disk.</p>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.Blob","title":"Blob","text":"<pre><code>Blob(\nkey: str, value: bytes, filepath: str | None = None\n) -&gt; None\n</code></pre> <p>Representation of entry in <code>EndpointStorage</code>.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Key associated with the blob.</p> </li> <li> value             (<code>bytes</code>)         \u2013 <p>The blob being stored.</p> </li> <li> filepath             (<code>str | None</code>)         \u2013 <p>Optional filepath for dumping the blob.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __init__(\nself,\nkey: str,\nvalue: bytes,\nfilepath: str | None = None,\n) -&gt; None:\nself.key = key\nself.size = len(value)\nself._value: bytes | None = value\nself.filepath = filepath\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.Blob.location","title":"location  <code>property</code>","text":"<pre><code>location: BlobLocation\n</code></pre> <p>Location of the blob.</p>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.Blob.value","title":"value  <code>property</code>","text":"<pre><code>value: bytes\n</code></pre> <p>Blob bytes.</p>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.Blob.delete_file","title":"delete_file","text":"<pre><code>delete_file() -&gt; None\n</code></pre> <p>Delete the file dump of the blob if it exists.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def delete_file(self) -&gt; None:\n\"\"\"Delete the file dump of the blob if it exists.\"\"\"\nif self.filepath is not None and os.path.isfile(self.filepath):\nos.remove(self.filepath)\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.Blob.dump","title":"dump","text":"<pre><code>dump() -&gt; None\n</code></pre> <p>Dump the blob to disk.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def dump(self) -&gt; None:\n\"\"\"Dump the blob to disk.\"\"\"\nif self.filepath is None:\nraise FileDumpNotAvailableError(\n'The blob was not initialized with a filepath '\n'to dump data to.',\n)\nassert self._value is not None\nwith open(self.filepath, 'wb') as f:\nf.write(self._value)\nself._value = None\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.Blob.load","title":"load","text":"<pre><code>load() -&gt; None\n</code></pre> <p>Load the blob from disk.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def load(self) -&gt; None:\n\"\"\"Load the blob from disk.\"\"\"\nif self._value is not None:\nreturn\nassert self.filepath is not None\nwith open(self.filepath, 'rb') as f:\nself._value = f.read()\nself.delete_file()\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage","title":"EndpointStorage","text":"<pre><code>EndpointStorage(\nmax_size: int | None = None,\nmax_object_size: int | None = None,\ndump_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>         Bases: <code>MutableMapping[str, bytes]</code></p> <p>Endpoint in-memory blob storage with filesystem fallback.</p> <p>Provides a dict-like storage of key-bytes pairs. Optionally, a maximum in-memory size for the data structure can be specified and least-recently used key-bytes pairs will be dumped to a file in a specified directory.</p> <p>Parameters:</p> <ul> <li> max_size             (<code>int | None</code>)         \u2013 <p>Optional maximum size in bytes for in-memory storage of blobs. If the memory limit is exceeded, least recently used blobs will be dumped to disk (if configured).</p> </li> <li> max_object_size             (<code>int | None</code>)         \u2013 <p>Optional maximum size in bytes for any single blob.</p> </li> <li> dump_dir             (<code>str | None</code>)         \u2013 <p>Optional directory to dump blobs to when <code>max_object_size</code> is reached.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __init__(\nself,\nmax_size: int | None = None,\nmax_object_size: int | None = None,\ndump_dir: str | None = None,\n) -&gt; None:\nif (max_size is not None or dump_dir is not None) and (\nmax_size is None or dump_dir is None\n):\nraise ValueError(\n'Either both of max_size and dump_dir should be specified '\n'or neither.',\n)\nself.max_size = max_size\nself.max_object_size = max_object_size\nself.dump_dir = dump_dir\nif self.dump_dir is not None:\nos.makedirs(self.dump_dir, exist_ok=True)\nself._in_memory_size = 0\nself._blobs: dict[str, Blob] = {}\n# Only in-memory objects should be in this.\n# Recently used keys are appended to right side, LRU keys are\n# popped from left side.\nself._lru_queue: Deque[str] = collections.deque()\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str) -&gt; bytes\n</code></pre> <p>Get bytes associated with key.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __getitem__(self, key: str) -&gt; bytes:\n\"\"\"Get bytes associated with key.\"\"\"\nif key not in self._blobs:\nraise KeyError(key)\nblob = self._blobs[key]\nif blob.location == BlobLocation.MEMORY:\n# Move to right side because recently used\nself._lru_queue.remove(key)\nself._lru_queue.append(key)\nreturn blob.value\nself._make_space(blob.size)\nself._in_memory_size += blob.size\nblob.load()\n# Add to queue because it is back in memory\nself._lru_queue.append(key)\nreturn blob.value\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key: str, value: bytes) -&gt; None\n</code></pre> <p>Set key to value.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>value</code> is larger than <code>max_size</code>.</p> </li> </ul> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __setitem__(self, key: str, value: bytes) -&gt; None:\n\"\"\"Set key to value.\n    Raises:\n        ValueError: If `value` is larger than `max_size`.\n    \"\"\"\nif (\nself.max_object_size is not None\nand len(value) &gt; self.max_object_size\n):\nraise ObjectSizeExceededError(\nf'Bytes value has size {bytes_to_readable(len(value))} which '\nf'exceeds the {bytes_to_readable(self.max_object_size)} '\n'object limit.',\n)\nif self.max_size is not None and len(value) &gt; self.max_size:\nraise ObjectSizeExceededError(\nf'Bytes value has size {bytes_to_readable(len(value))} which '\nf'exceeds the {bytes_to_readable(self.max_size)} '\n'memory limit.',\n)\nfilepath = (\nNone if self.dump_dir is None else os.path.join(self.dump_dir, key)\n)\nblob = Blob(key, value, filepath)\nself._make_space(blob.size)\nself._blobs[key] = blob\nself._in_memory_size += blob.size\nself._lru_queue.append(key)\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str) -&gt; None\n</code></pre> <p>Remove a key from the storage.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __delitem__(self, key: str) -&gt; None:\n\"\"\"Remove a key from the storage.\"\"\"\nif key not in self._blobs:\nraise KeyError(key)\nblob = self._blobs.pop(key)\nassert blob is not None\nif blob.location == BlobLocation.MEMORY:\nself._in_memory_size -= blob.size\nself._lru_queue.remove(key)\nblob.delete_file()\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[str]\n</code></pre> <p>Iterate over keys in the storage.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str]:\n\"\"\"Iterate over keys in the storage.\"\"\"\nyield from self._blobs\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return number of keys in the storage.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Return number of keys in the storage.\"\"\"\nreturn len(self._blobs)\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.__contains__","title":"__contains__","text":"<pre><code>__contains__(key: object) -&gt; bool\n</code></pre> <p>Check if storage contains a key.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def __contains__(self, key: object) -&gt; bool:\n\"\"\"Check if storage contains a key.\"\"\"\nreturn key in self._blobs\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear all keys in the storage.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def clear(self) -&gt; None:\n\"\"\"Clear all keys in the storage.\"\"\"\nkeys = list(self._blobs.keys())\nfor key in keys:\ndel self._blobs[key]\nself._lru_queue.clear()\n</code></pre>"},{"location":"reference/endpoint/storage/#proxystore.endpoint.storage.EndpointStorage.cleanup","title":"cleanup","text":"<pre><code>cleanup() -&gt; None\n</code></pre> <p>Clear all keys in the storage and remove the data dump.</p> Source code in <code>proxystore/endpoint/storage.py</code> <pre><code>def cleanup(self) -&gt; None:\n\"\"\"Clear all keys in the storage and remove the data dump.\"\"\"\nif self.dump_dir is not None:\nshutil.rmtree(self.dump_dir)\nself._blobs.clear()\n</code></pre>"},{"location":"reference/p2p/","title":"proxystore.p2p","text":"<p>Peer-to-peer communication and signaling.</p> <p>This module provides two main functionalities: the <code>PeerManager</code> and <code>SignalingServer</code>.</p> <ul> <li>The <code>PeerManager</code> enables   easy communication between arbitrary peers even if peers are behind separate   NATs. Peer connections are established using   aiortc, an asyncio WebRTC implementation.</li> <li>The <code>SignalingServer</code> is a   commonly accessible server by peers that is used to facilitate WebRTC peer   connections.</li> </ul>"},{"location":"reference/p2p/chunks/","title":"proxystore.p2p.chunks","text":"<p>Message chunking utilities.</p>"},{"location":"reference/p2p/chunks/#proxystore.p2p.chunks.ChunkDType","title":"ChunkDType","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Data type contained in a Chunk.</p>"},{"location":"reference/p2p/chunks/#proxystore.p2p.chunks.ChunkDType.BYTES","title":"BYTES  <code>class-attribute</code>","text":"<pre><code>BYTES = 1\n</code></pre> <p>Data is bytes.</p>"},{"location":"reference/p2p/chunks/#proxystore.p2p.chunks.ChunkDType.STRING","title":"STRING  <code>class-attribute</code>","text":"<pre><code>STRING = 2\n</code></pre> <p>Data is a string.</p>"},{"location":"reference/p2p/chunks/#proxystore.p2p.chunks.Chunk","title":"Chunk","text":"<pre><code>Chunk(\nstream_id: int,\nseq_id: int,\nseq_len: int,\ndata: bytes | str,\ndtype: ChunkDType | None = None,\n) -&gt; None\n</code></pre> <p>Representation of a chunk of a message.</p> <p>Parameters:</p> <ul> <li> stream_id             (<code>int</code>)         \u2013 <p>Unique ID for the stream of chunks.</p> </li> <li> seq_id             (<code>int</code>)         \u2013 <p>Sequence number for this chunk in the stream.</p> </li> <li> seq_len             (<code>int</code>)         \u2013 <p>Length of the stream.</p> </li> <li> data             (<code>bytes | str</code>)         \u2013 <p>Data for this chunk.</p> </li> <li> dtype             (<code>ChunkDType | None</code>)         \u2013 <p>Optionally specify data type otherwise inferred from data.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>if the sequence ID is not less than the sequence length.</p> </li> </ul> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def __init__(\nself,\nstream_id: int,\nseq_id: int,\nseq_len: int,\ndata: bytes | str,\ndtype: ChunkDType | None = None,\n) -&gt; None:\nif seq_len &lt;= seq_id:\nraise ValueError(\nf'seq_id ({seq_id}) must be less than seq_len ({seq_len}).',\n)\nself.stream_id = stream_id\nself.seq_id = seq_id\nself.seq_len = seq_len\nself.data = data\nif dtype is None:\nself.dtype = (\nChunkDType.BYTES\nif isinstance(data, bytes)\nelse ChunkDType.STRING\n)\nelse:\nself.dtype = dtype\n</code></pre>"},{"location":"reference/p2p/chunks/#proxystore.p2p.chunks.Chunk.__bytes__","title":"__bytes__","text":"<pre><code>__bytes__() -&gt; bytes\n</code></pre> <p>Pack the chunk into bytes.</p> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def __bytes__(self) -&gt; bytes:\n\"\"\"Pack the chunk into bytes.\"\"\"\nlength = CHUNK_HEADER_LENGTH + len(self.data)\nheader = pack(\nCHUNK_HEADER_FORMAT,\nself.dtype.value,\nlength,\nself.stream_id,\nself.seq_id,\nself.seq_len,\n)\ndata = (\nself.data.encode('utf8')\nif isinstance(self.data, str)\nelse self.data\n)\nchunk = header + data\ndata += b'\\x00' * (len(chunk) % 4)\nreturn chunk\n</code></pre>"},{"location":"reference/p2p/chunks/#proxystore.p2p.chunks.Chunk.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(chunk: bytes) -&gt; Chunk\n</code></pre> <p>Decode bytes into a Chunk.</p> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>@classmethod\ndef from_bytes(cls, chunk: bytes) -&gt; Chunk:\n\"\"\"Decode bytes into a Chunk.\"\"\"\n(dtype_value, length, stream_id, seq_id, seq_len) = unpack_from(\nCHUNK_HEADER_FORMAT,\nchunk,\n)\ndtype = ChunkDType(dtype_value)\nchunk_data = chunk[CHUNK_HEADER_LENGTH:length]\ndata: bytes | str\nif dtype is ChunkDType.STRING:\ndata = chunk_data.decode('utf8')\nelse:\ndata = chunk_data\nreturn cls(\nstream_id=stream_id,\nseq_id=seq_id,\nseq_len=seq_len,\ndata=data,\ndtype=dtype,\n)\n</code></pre>"},{"location":"reference/p2p/chunks/#proxystore.p2p.chunks.chunkify","title":"chunkify","text":"<pre><code>chunkify(\ndata: bytes | str, size: int, stream_id: int\n) -&gt; Generator[Chunk, None, None]\n</code></pre> <p>Generate chunks from data.</p> <p>Parameters:</p> <ul> <li> data             (<code>bytes | str</code>)         \u2013 <p>Data to chunk.</p> </li> <li> size             (<code>int</code>)         \u2013 <p>Size of each chunk.</p> </li> <li> stream_id             (<code>int</code>)         \u2013 <p>Unique ID for the stream of chunks.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Generator[Chunk, None, None]</code>         \u2013 <p>Chunks of data.</p> </li> </ul> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def chunkify(\ndata: bytes | str,\nsize: int,\nstream_id: int,\n) -&gt; Generator[Chunk, None, None]:\n\"\"\"Generate chunks from data.\n    Args:\n        data: Data to chunk.\n        size: Size of each chunk.\n        stream_id: Unique ID for the stream of chunks.\n    Yields:\n        Chunks of data.\n    \"\"\"\nseq_len = math.ceil(len(data) / size)\nfor i, x in enumerate(range(0, len(data), size)):\nchunk_data = data[x : min(x + size, len(data))]\nyield Chunk(\nstream_id=stream_id,\nseq_id=i,\nseq_len=seq_len,\ndata=chunk_data,\n)\n</code></pre>"},{"location":"reference/p2p/chunks/#proxystore.p2p.chunks.reconstruct","title":"reconstruct","text":"<pre><code>reconstruct(chunks: list[Chunk]) -&gt; bytes | str\n</code></pre> <p>Reconstructs data from list of chunks.</p> <p>Parameters:</p> <ul> <li> chunks             (<code>list[Chunk]</code>)         \u2013 <p>List of chunks to order and join.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | str</code>         \u2013 <p>Reconstructed bytes or string.</p> </li> </ul> Source code in <code>proxystore/p2p/chunks.py</code> <pre><code>def reconstruct(chunks: list[Chunk]) -&gt; bytes | str:\n\"\"\"Reconstructs data from list of chunks.\n    Args:\n        chunks: List of chunks to order and join.\n    Returns:\n        Reconstructed bytes or string.\n    \"\"\"\nif len(chunks) == 0:\nraise ValueError('Chunks list cannot be empty.')\nseq_len = chunks[0].seq_len\nif len(chunks) != seq_len:\nraise ValueError(f'Got {len(chunks)} but expected {seq_len}.')\nchunks = sorted(chunks, key=lambda c: c.seq_id)\nif isinstance(chunks[0].data, bytes):\nreturn b''.join(c.data for c in chunks)  # type: ignore\nelif isinstance(chunks[0].data, str):\nreturn ''.join(c.data for c in chunks)  # type: ignore\nelse:\nraise AssertionError('Unreachable.')\n</code></pre>"},{"location":"reference/p2p/client/","title":"proxystore.p2p.client","text":"<p>Functions for connecting to the Signaling Server.</p>"},{"location":"reference/p2p/client/#proxystore.p2p.client.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(\naddress: str,\nuuid: UUID | None = None,\nname: str | None = None,\ntimeout: float = 10,\nssl: ssl.SSLContext | None = None,\n) -&gt; tuple[UUID, str, WebSocketClientProtocol]\n</code></pre> <p>Establish client connection to a Signaling Server.</p> <p>Parameters:</p> <ul> <li> address             (<code>str</code>)         \u2013 <p>Address of the Signaling Server. Should start with ws:// or wss://.</p> </li> <li> uuid             (<code>UUID | None</code>)         \u2013 <p>Optional uuid of client to use when registering with signaling server.</p> </li> <li> name             (<code>str | None</code>)         \u2013 <p>Readable name of the client to use when registering with the signaling server. By default the hostname will be used.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Time to wait in seconds on server connections.</p> </li> <li> ssl             (<code>ssl.SSLContext | None</code>)         \u2013 <p>When None, the correct value to pass to :code:<code>websockets.connect</code> is inferred from <code>address</code>. If <code>address</code> starts with \"wss://\" the value is True, otherwise is False. Optionally provide a custom SSLContext (useful if the server uses self-signed certificates).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[UUID, str, WebSocketClientProtocol]</code>         \u2013 <p>Tuple of the UUID of this client returned by the signaling server,         the name used to register the client, and the websocket connection to         the signaling server.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EndpointRegistrationError</code>           \u2013         <p>If the connection to the signaling server is closed, does not reply to the registration request within the timeout, or replies with an error.</p> </li> <li> <code>ValueError</code>           \u2013         <p>If address does not start with \"ws://\" or \"wss://\".</p> </li> </ul> Source code in <code>proxystore/p2p/client.py</code> <pre><code>async def connect(\naddress: str,\nuuid: UUID | None = None,\nname: str | None = None,\ntimeout: float = 10,\nssl: ssl.SSLContext | None = None,\n) -&gt; tuple[UUID, str, WebSocketClientProtocol]:\n\"\"\"Establish client connection to a Signaling Server.\n    Args:\n        address: Address of the Signaling Server. Should start with ws:// or\n            wss://.\n        uuid: Optional uuid of client to use when registering with signaling\n            server.\n        name: Readable name of the client to use when registering with the\n            signaling server. By default the hostname will be used.\n        timeout: Time to wait in seconds on server connections.\n        ssl: When None, the correct value to pass to :code:`websockets.connect`\n            is inferred from `address`. If `address` starts with \"wss://\" the\n            value is True, otherwise is False. Optionally provide a custom\n            SSLContext (useful if the server uses self-signed certificates).\n    Returns:\n        Tuple of the UUID of this client returned by the signaling server, \\\n        the name used to register the client, and the websocket connection to \\\n        the signaling server.\n    Raises:\n        EndpointRegistrationError: If the connection to the signaling server\n            is closed, does not reply to the registration request within the\n            timeout, or replies with an error.\n        ValueError: If address does not start with \"ws://\" or \"wss://\".\n    \"\"\"\nif name is None:\nname = gethostname()\nif uuid is None:\nuuid = uuid4()\nif not (address.startswith('ws://') or address.startswith('wss://')):\nraise ValueError(\n'Signaling server address must start with ws:// or wss://.'\nf'Got {address}.',\n)\nssl_default = True if address.startswith('wss://') else None\nwebsocket = await websockets.client.connect(\naddress,\nopen_timeout=timeout,\nssl=ssl_default if ssl is None else ssl,\n)\nawait websocket.send(\nmessages.encode(messages.ServerRegistration(uuid=uuid, name=name)),\n)\ntry:\nmessage_str = await asyncio.wait_for(websocket.recv(), timeout)\nif isinstance(message_str, str):\nmessage = messages.decode(message_str)\nelse:\nraise AssertionError('Received non-bytes type on websocket.')\nexcept websockets.exceptions.ConnectionClosed as e:\nraise PeerRegistrationError(\n'Connection to signaling server closed before peer '\n'registration completed.',\n) from e\nexcept messages.MessageDecodeError as e:\nraise PeerRegistrationError(\n'Unable to decode response message from signaling server.',\n) from e\nexcept asyncio.TimeoutError as e:\nraise PeerRegistrationError(\n'Signaling server did not reply to registration within timeout.',\n) from e\nif isinstance(message, messages.ServerResponse):\nif message.success:\nlogger.info(\n'established client connection to signaling server at '\nf'{address} with uuid={uuid} and name={name}',\n)\nreturn uuid, name, websocket\nelse:\nraise PeerRegistrationError(\n'Failed to register as peer with signaling server. '\nf'Got exception: {message.message}',\n)\nelse:\nraise PeerRegistrationError(\n'Signaling server replied with unknown message type: '\nf'{type(message).__name__}.',\n)\n</code></pre>"},{"location":"reference/p2p/connection/","title":"proxystore.p2p.connection","text":"<p>Representation of peer-to-peer connection.</p>"},{"location":"reference/p2p/connection/#proxystore.p2p.connection.PeerConnection","title":"PeerConnection","text":"<pre><code>PeerConnection(\nuuid: UUID,\nname: str,\nwebsocket: WebSocketClientProtocol,\n*,\nchannels: int = 1\n) -&gt; None\n</code></pre> <p>Peer-to-peer connection.</p> <p>Interface for establishing a peer-to-peer connection via WebRTC aiortc and sending/receiving messages between the two peers. The peer-to-peer connection is established using a central and publicly accessible signaling server.</p> Warning <p>Applications should prefer using the <code>PeerManager</code> rather than using the <code>PeerConnection</code> class.</p> Example <pre><code>from proxystore.p2p.connection import PeerConnection\nfrom proxystore.p2p.messages import decode\nfrom proxystore.p2p.server import connect\nuuid1, name1, websocket1 = await connect(signaling_server_address)\nconnection1 = PeerConnection(uuid1, name1, websocket1)\nuuid2, name2, websocket2 = await connect(signaling_server_address)\nconnection2 = PeerConnection(uuid2, name2, websocket2)\nawait connection1.send_offer(uuid2)\noffer = decode(await websocket2.recv())\nawait connection2.handle_server_message(offer)\nanswer = decode(await websocket1.recv())\nawait connection1.handle_server_message(answer)\nawait connection1.ready()\nawait connection2.ready()\nawait connection1.send('hello')\nassert await connection2.recv() == 'hello'\nawait connection2.send('hello hello')\nassert await connection1.recv() == 'hello hello'\nawait websocket1.close()\nawait websocket2.close()\nawait connection1.close()\nawait connection2.close()\n</code></pre> <p>Parameters:</p> <ul> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of this client.</p> </li> <li> name             (<code>str</code>)         \u2013 <p>Readable name of this client for logging.</p> </li> <li> websocket             (<code>WebSocketClientProtocol</code>)         \u2013 <p>Websocket connection to the signaling server.</p> </li> <li> channels             (<code>int</code>)         \u2013 <p>Number of datachannels to open with peer.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>def __init__(\nself,\nuuid: UUID,\nname: str,\nwebsocket: WebSocketClientProtocol,\n*,\nchannels: int = 1,\n) -&gt; None:\nself._uuid = uuid\nself._name = name\nself._websocket = websocket\nself._max_channels = channels\nself._handshake_success: asyncio.Future[\nbool\n] = asyncio.get_running_loop().create_future()\nself._pc = RTCPeerConnection()\nself._incoming_queue: asyncio.Queue[bytes | str] = asyncio.Queue()\nself._incoming_chunks: dict[int, list[Chunk]] = defaultdict(list)\n# Max size of unsigned long (4 bytes) is 2^32 - 1\nself._message_counter = AtomicCounter(size=2**32 - 1)\n# Used by offerer to count how many of the channels it opened are ready\nself._ready = 0\nself._channels: dict[str, RTCDataChannel] = {}\nself._channel_buffer_low: dict[str, asyncio.Event] = {}\nself._peer_uuid: UUID | None = None\nself._peer_name: str | None = None\n</code></pre>"},{"location":"reference/p2p/connection/#proxystore.p2p.connection.PeerConnection.state","title":"state  <code>property</code>","text":"<pre><code>state: str\n</code></pre> <p>Get the current connection state.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>One of 'connected', 'connecting', 'closed', 'failed', or 'new'.</p> </li> </ul>"},{"location":"reference/p2p/connection/#proxystore.p2p.connection.PeerConnection.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Terminate the peer connection.</p> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Terminate the peer connection.\"\"\"\nlogger.info(f'{self._log_prefix}: closing connection')\n# Flush send buffers before close\n# https://github.com/aiortc/aiortc/issues/547\nfor channel in self._channels.values():\ntransport = channel._RTCDataChannel__transport\nawait transport._data_channel_flush()\nawait transport._transmit()\nawait self._pc.close()\n</code></pre>"},{"location":"reference/p2p/connection/#proxystore.p2p.connection.PeerConnection.send","title":"send  <code>async</code>","text":"<pre><code>send(message: bytes | str, timeout: float = 30) -&gt; None\n</code></pre> <p>Send message to peer.</p> <p>Parameters:</p> <ul> <li> message             (<code>bytes | str</code>)         \u2013 <p>Message to send to peer.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Timeout to wait on peer connection to be ready.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerConnectionTimeoutError</code>           \u2013         <p>If the peer connection is not established within the timeout.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def send(self, message: bytes | str, timeout: float = 30) -&gt; None:\n\"\"\"Send message to peer.\n    Args:\n        message: Message to send to peer.\n        timeout: Timeout to wait on peer connection to be ready.\n    Raises:\n        PeerConnectionTimeoutError: If the peer connection is not\n            established within the timeout.\n    \"\"\"\nawait self.ready(timeout)\nchunk_size = (\nMAX_CHUNK_SIZE_STRING\nif isinstance(message, str)\nelse MAX_CHUNK_SIZE_BYTES\n)\nmessage_id = self._message_counter.increment()\nchannel_names = list(self._channels.keys())\nfor i, chunk in enumerate(chunkify(message, chunk_size, message_id)):\nchannel_name = channel_names[i % len(channel_names)]\nchannel = self._channels[channel_name]\nbuffer_low = self._channel_buffer_low[channel_name]\nif channel.bufferedAmount &gt; channel.bufferedAmountLowThreshold:\nawait buffer_low.wait()\nbuffer_low.clear()\nchannel.send(bytes(chunk))\nlogger.debug(f'{self._log_prefix}: sending message to peer')\n</code></pre>"},{"location":"reference/p2p/connection/#proxystore.p2p.connection.PeerConnection.recv","title":"recv  <code>async</code>","text":"<pre><code>recv() -&gt; bytes | str\n</code></pre> <p>Receive next message from peer.</p> <p>Returns:</p> <ul> <li> <code>bytes | str</code>         \u2013 <p>Message received from peer.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def recv(self) -&gt; bytes | str:\n\"\"\"Receive next message from peer.\n    Returns:\n        Message received from peer.\n    \"\"\"\nreturn await self._incoming_queue.get()\n</code></pre>"},{"location":"reference/p2p/connection/#proxystore.p2p.connection.PeerConnection.send_offer","title":"send_offer  <code>async</code>","text":"<pre><code>send_offer(peer_uuid: UUID) -&gt; None\n</code></pre> <p>Send offer for peering via signaling server.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer client to establish connection with.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def send_offer(self, peer_uuid: UUID) -&gt; None:\n\"\"\"Send offer for peering via signaling server.\n    Args:\n        peer_uuid: UUID of peer client to establish connection with.\n    \"\"\"\nfor i in range(self._max_channels):\nlabel = f'p2p-{i}-{self._max_channels}'\nchannel = self._pc.createDataChannel(label, ordered=False)\nbuffer_low = asyncio.Event()\nchannel.on('open', self._on_open)\nchannel.on('bufferedamountlow', buffer_low.set)\nchannel.on('message', self._on_message)\nself._channels[label] = channel\nself._channel_buffer_low[label] = buffer_low\nawait self._pc.setLocalDescription(await self._pc.createOffer())\nmessage = messages.PeerConnection(\nsource_uuid=self._uuid,\nsource_name=self._name,\npeer_uuid=peer_uuid,\ndescription_type='offer',\ndescription=object_to_string(self._pc.localDescription),\n)\nmessage_str = messages.encode(message)\nlogger.info(f'{self._log_prefix}: sending offer to {peer_uuid}')\nawait self._websocket.send(message_str)\n</code></pre>"},{"location":"reference/p2p/connection/#proxystore.p2p.connection.PeerConnection.send_answer","title":"send_answer  <code>async</code>","text":"<pre><code>send_answer(peer_uuid: UUID) -&gt; None\n</code></pre> <p>Send answer to peering request via signaling server.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer client that sent the initial offer.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def send_answer(self, peer_uuid: UUID) -&gt; None:\n\"\"\"Send answer to peering request via signaling server.\n    Args:\n        peer_uuid: UUID of peer client that sent the initial offer.\n    \"\"\"\n@self._pc.on('datachannel')\ndef on_datachannel(channel: RTCDataChannel) -&gt; None:\nlogger.info(f'{self._log_prefix}: peer channel established')\n# TODO: note this is first channel opened\nmatch = re.search(r'(\\d+)-(\\d+)$', channel.label)\nif match is None:\nraise AssertionError(\nf'Got mislabled datachannel {channel.label}',\n)\ntotal = int(match.group(2))\nbuffer_low = asyncio.Event()\nself._channels[channel.label] = channel\nself._channel_buffer_low[channel.label] = buffer_low\nchannel.on('bufferedamountlow', buffer_low.set)\nchannel.on('message', self._on_message)\nif len(self._channels) &gt;= total:\nself._handshake_success.set_result(True)\nawait self._pc.setLocalDescription(await self._pc.createAnswer())\nmessage = messages.PeerConnection(\nsource_uuid=self._uuid,\nsource_name=self._name,\npeer_uuid=peer_uuid,\ndescription_type='answer',\ndescription=object_to_string(self._pc.localDescription),\n)\nmessage_str = messages.encode(message)\nlogger.info(f'{self._log_prefix}: sending answer to {peer_uuid}')\nawait self._websocket.send(message_str)\n</code></pre>"},{"location":"reference/p2p/connection/#proxystore.p2p.connection.PeerConnection.handle_server_message","title":"handle_server_message  <code>async</code>","text":"<pre><code>handle_server_message(\nmessage: messages.PeerConnection,\n) -&gt; None\n</code></pre> <p>Handle message from the signaling server.</p> <p>Parameters:</p> <ul> <li> message             (<code>messages.PeerConnection</code>)         \u2013 <p>Message received from the signaling server.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def handle_server_message(\nself,\nmessage: messages.PeerConnection,\n) -&gt; None:\n\"\"\"Handle message from the signaling server.\n    Args:\n        message: Message received from the signaling server.\n    \"\"\"\nif message.error is not None:\nself._handshake_success.set_exception(\nPeerConnectionError(\n'Received error message from signaling server: '\nf'{str(message.error)}',\n),\n)\nreturn\nif message.description_type == 'offer':\nlogger.info(\nf'{self._log_prefix}: received offer from '\nf'{message.source_uuid} ({message.source_name})',\n)\nobj = object_from_string(message.description)\nelif message.description_type == 'answer':\nlogger.info(\nf'{self._log_prefix}: received answer from '\nf'{message.source_uuid} ({message.source_name})',\n)\nobj = object_from_string(message.description)\nelse:\nraise AssertionError(\n'P2P connection message does not contain either an offer or '\n'an answer',\n)\nif isinstance(obj, RTCSessionDescription):\nawait self._pc.setRemoteDescription(obj)\nself._peer_uuid = message.source_uuid\nself._peer_name = message.source_name\nif obj.type == 'offer':\nawait self.send_answer(message.source_uuid)\nelif isinstance(obj, RTCIceCandidate):  # pragma: no cover\n# We should not receive an RTCIceCandidate message via the\n# signaling server but this is here following the aiortc example.\n# https://github.com/aiortc/aiortc/blob/713fb644b95328f8ec1ac2cbb54def0424cc6645/examples/datachannel-cli/cli.py#L30  # noqa: E501\nawait self._pc.addIceCandidate(obj)\nelif obj is BYE:  # pragma: no cover\nraise AssertionError('received BYE message')\nelse:\nraise AssertionError('received unknown message')\n</code></pre>"},{"location":"reference/p2p/connection/#proxystore.p2p.connection.PeerConnection.ready","title":"ready  <code>async</code>","text":"<pre><code>ready(timeout: float | None = None) -&gt; None\n</code></pre> <p>Wait for connection to be ready.</p> <p>Parameters:</p> <ul> <li> timeout             (<code>float | None</code>)         \u2013 <p>The maximum time in seconds to wait for the peer connection to establish. If None, block until the connection is established.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerConnectionTimeoutError</code>           \u2013         <p>If the connection is not ready within the timeout.</p> </li> <li> <code>PeerConnectionError</code>           \u2013         <p>If there is an error establishing the peer connection.</p> </li> </ul> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>async def ready(self, timeout: float | None = None) -&gt; None:\n\"\"\"Wait for connection to be ready.\n    Args:\n        timeout: The maximum time in seconds to wait for\n            the peer connection to establish. If None, block until\n            the connection is established.\n    Raises:\n        PeerConnectionTimeoutError: If the connection is not ready within\n            the timeout.\n        PeerConnectionError: If there is an error establishing the peer\n            connection.\n    \"\"\"\ntry:\nawait asyncio.wait_for(self._handshake_success, timeout)\nexcept asyncio.TimeoutError as e:\nraise PeerConnectionTimeoutError(\n'Timeout waiting for peer to peer connection to establish '\nf'in {self._log_prefix}.',\n) from e\n</code></pre>"},{"location":"reference/p2p/connection/#proxystore.p2p.connection.log_name","title":"log_name","text":"<pre><code>log_name(uuid: UUID, name: str) -&gt; str\n</code></pre> <p>Return string formatted as <code>'name(uuid-prefix)'</code>.</p> Source code in <code>proxystore/p2p/connection.py</code> <pre><code>def log_name(uuid: UUID, name: str) -&gt; str:\n\"\"\"Return string formatted as `#!python 'name(uuid-prefix)'`.\"\"\"\nuuid_ = str(uuid)\nreturn f'{name}({uuid_[:min(8,len(uuid_))]})'\n</code></pre>"},{"location":"reference/p2p/counter/","title":"proxystore.p2p.counter","text":"<p>Atomic counting utilities.</p>"},{"location":"reference/p2p/counter/#proxystore.p2p.counter.AtomicCounter","title":"AtomicCounter","text":"<pre><code>AtomicCounter(size: int | None = None) -&gt; None\n</code></pre> <p>Thread-safe counter.</p> <p>Parameters:</p> <ul> <li> size             (<code>int | None</code>)         \u2013 <p>Optional max count upon which an exception will be raised.</p> </li> </ul> Source code in <code>proxystore/p2p/counter.py</code> <pre><code>def __init__(self, size: int | None = None) -&gt; None:\nself._size = size\nself._value = 0\nself._lock = threading.Lock()\n</code></pre>"},{"location":"reference/p2p/counter/#proxystore.p2p.counter.AtomicCounter.increment","title":"increment","text":"<pre><code>increment() -&gt; int\n</code></pre> <p>Get current count and increment value.</p> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>Current count.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If current count is equal to or greater than size.</p> </li> </ul> Source code in <code>proxystore/p2p/counter.py</code> <pre><code>def increment(self) -&gt; int:\n\"\"\"Get current count and increment value.\n    Returns:\n        Current count.\n    Raises:\n        ValueError: If current count is equal to or greater than size.\n    \"\"\"\nwith self._lock:\nvalue = self._value\nif self._size is not None and value &gt;= self._size:\nraise ValueError(f'Max counter size exceeded ({self._size}).')\nself._value += 1\nreturn value\n</code></pre>"},{"location":"reference/p2p/exceptions/","title":"proxystore.p2p.exceptions","text":"<p>Exception types for the Signaling Server.</p>"},{"location":"reference/p2p/exceptions/#proxystore.p2p.exceptions.PeerConnectionError","title":"PeerConnectionError","text":"<p>         Bases: <code>Exception</code></p> <p>Error connecting to peer.</p>"},{"location":"reference/p2p/exceptions/#proxystore.p2p.exceptions.PeerConnectionTimeoutError","title":"PeerConnectionTimeoutError","text":"<p>         Bases: <code>PeerConnectionError</code></p> <p>Timeout waiting on peer to peer connection to establish.</p>"},{"location":"reference/p2p/exceptions/#proxystore.p2p.exceptions.PeerRegistrationError","title":"PeerRegistrationError","text":"<p>         Bases: <code>Exception</code></p> <p>Error when establishing peer connection.</p>"},{"location":"reference/p2p/manager/","title":"proxystore.p2p.manager","text":"<p>Manager of many peer-to-peer connections.</p>"},{"location":"reference/p2p/manager/#proxystore.p2p.manager.PeerManager","title":"PeerManager","text":"<pre><code>PeerManager(\nuuid: UUID,\nsignaling_server: str,\nname: str | None = None,\n*,\ntimeout: int = 30,\npeer_channels: int = 1,\nverify_certificate: bool = True\n) -&gt; None\n</code></pre> <p>Peer Connections Manager.</p> <p>Handles establishing peer connections via aiortc, responding to requests for new peer connections from the signaling server, and sending and receiving data to/from existing peer connections.</p> Example <pre><code>from proxystore.p2p.manager import PeerManager\npm1 = await PeerManager(uuid.uuid4(), signaling_server_address)\npm2 = await PeerManager(uuid.uuid4(), signaling_server_address)\nawait pm1.send(pm2.uuid, 'hello hello')\nsource_uuid, message = await pm2.recv()\nassert source_uuid == pm1.uuid\nassert message == 'hello hello'\npm1.close()\npm2.close()\n</code></pre> Note <p>The class can also be used as a context manager.</p> <pre><code>async with PeerManager(..) as manager:\n...\n</code></pre> Warning <p>The class must be initialized with await or inside an async with statement to correctly configure all async tasks and connections.</p> <pre><code>manager = await PeerManager(...)\nmanager.close()\n</code></pre> <pre><code>async with PeerManager(...) as manager:\n...\n</code></pre> <p>Parameters:</p> <ul> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of the client.</p> </li> <li> signaling_server             (<code>str</code>)         \u2013 <p>Address of signaling server to use for establishing peer-to-peer connections.</p> </li> <li> name             (<code>str | None</code>)         \u2013 <p>Readable name of the client to use in logging. If unspecified, the hostname will be used.</p> </li> <li> timeout             (<code>int</code>)         \u2013 <p>Timeout in seconds when waiting for a peer or signaling server connection to be established.</p> </li> <li> peer_channels             (<code>int</code>)         \u2013 <p>number of datachannels to split message sending over between each peer.</p> </li> <li> verify_certificate             (<code>bool</code>)         \u2013 <p>Verify the signaling server's SSL certificate,</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the signaling server address does not start with \"ws://\" or \"wss://\".</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>def __init__(\nself,\nuuid: UUID,\nsignaling_server: str,\nname: str | None = None,\n*,\ntimeout: int = 30,\npeer_channels: int = 1,\nverify_certificate: bool = True,\n) -&gt; None:\nif not (\nsignaling_server.startswith('ws://')\nor signaling_server.startswith('wss://')\n):\nraise ValueError(\n'Signaling server address must start with ws:// or wss://'\nf'Got {signaling_server}.',\n)\nself._uuid = uuid\nself._signaling_server = signaling_server\nself._name = name if name is not None else utils.hostname()\nself._timeout = timeout\nself._peer_channels = peer_channels\nself._verify_certificate = verify_certificate\nself._peers_lock = asyncio.Lock()\nself._peers: dict[frozenset[UUID], PeerConnection] = {}\nself._message_queue: asyncio.Queue[\ntuple[UUID, bytes | str]\n] = asyncio.Queue()\nself._server_task: asyncio.Task[None] | None = None\nself._tasks: dict[frozenset[UUID], asyncio.Task[None]] = {}\nself._websocket_or_none: WebSocketClientProtocol | None = None\n</code></pre>"},{"location":"reference/p2p/manager/#proxystore.p2p.manager.PeerManager.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: UUID\n</code></pre> <p>UUID of the peer manager.</p>"},{"location":"reference/p2p/manager/#proxystore.p2p.manager.PeerManager.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the peer manager.</p>"},{"location":"reference/p2p/manager/#proxystore.p2p.manager.PeerManager.async_init","title":"async_init  <code>async</code>","text":"<pre><code>async_init() -&gt; None\n</code></pre> <p>Connect to signaling server.</p> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def async_init(self) -&gt; None:\n\"\"\"Connect to signaling server.\"\"\"\nif self._websocket_or_none is None:\nssl_context = ssl.create_default_context()\nif not self._verify_certificate:\nssl_context.check_hostname = False\nssl_context.verify_mode = ssl.CERT_NONE\nuuid, _, socket = await connect(\naddress=self._signaling_server,\nuuid=self._uuid,\nname=self._name,\ntimeout=self._timeout,\nssl=ssl_context\nif self._signaling_server.startswith('wss://')\nelse None,\n)\nif uuid != self._uuid:\nraise PeerRegistrationError(\n'Signaling server responded to registration request '\nf'with non-matching UUID. Received {uuid} but expected '\nf'{self._uuid}.',\n)\nself._websocket_or_none = socket\nlogger.info(\nf'{self._log_prefix}: registered as peer with signaling '\nf'server at {self._signaling_server}',\n)\nif self._server_task is None:\nself._server_task = spawn_guarded_background_task(\nself._handle_server_messages,\n)\n</code></pre>"},{"location":"reference/p2p/manager/#proxystore.p2p.manager.PeerManager.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the connection manager.</p> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the connection manager.\"\"\"\nif self._server_task is not None:\nself._server_task.cancel()\ntry:\nawait self._server_task\nexcept (asyncio.CancelledError, SafeTaskExitError):\npass\nfor task in self._tasks.values():\ntask.cancel()\ntry:\nawait task\nexcept (asyncio.CancelledError, SafeTaskExitError):\npass\nasync with self._peers_lock:\nfor connection in self._peers.values():\nawait connection.close()\nif self._websocket_or_none is not None:\nawait self._websocket_or_none.close()\nlogger.info(f'{self._log_prefix}: peer manager closed')\n</code></pre>"},{"location":"reference/p2p/manager/#proxystore.p2p.manager.PeerManager.recv","title":"recv  <code>async</code>","text":"<pre><code>recv() -&gt; tuple[UUID, bytes | str]\n</code></pre> <p>Receive next message from a peer.</p> <p>Returns:</p> <ul> <li> <code>UUID</code>         \u2013 <p>Tuple containing the UUID of the peer that sent the message</p> </li> <li> <code>bytes | str</code>         \u2013 <p>and the message itself.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def recv(self) -&gt; tuple[UUID, bytes | str]:\n\"\"\"Receive next message from a peer.\n    Returns:\n        Tuple containing the UUID of the peer that sent the message\n        and the message itself.\n    \"\"\"\nreturn await self._message_queue.get()\n</code></pre>"},{"location":"reference/p2p/manager/#proxystore.p2p.manager.PeerManager.send","title":"send  <code>async</code>","text":"<pre><code>send(\npeer_uuid: UUID,\nmessage: bytes | str,\ntimeout: float = 30,\n) -&gt; None\n</code></pre> <p>Send message to peer.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer to send message to.</p> </li> <li> message             (<code>bytes | str</code>)         \u2013 <p>Message to send to peer.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>Timeout to wait on peer connection to be ready.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PeerConnectionTimeoutError</code>           \u2013         <p>If the peer connection is not established within the timeout.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def send(\nself,\npeer_uuid: UUID,\nmessage: bytes | str,\ntimeout: float = 30,\n) -&gt; None:\n\"\"\"Send message to peer.\n    Args:\n        peer_uuid: UUID of peer to send message to.\n        message: Message to send to peer.\n        timeout: Timeout to wait on peer connection to be ready.\n    Raises:\n        PeerConnectionTimeoutError: If the peer connection is not\n            established within the timeout.\n    \"\"\"\nconnection = await self.get_connection(peer_uuid)\nawait connection.send(message, timeout)\n</code></pre>"},{"location":"reference/p2p/manager/#proxystore.p2p.manager.PeerManager.get_connection","title":"get_connection  <code>async</code>","text":"<pre><code>get_connection(peer_uuid: UUID) -&gt; PeerConnection\n</code></pre> <p>Get connection to the peer.</p> <p>Parameters:</p> <ul> <li> peer_uuid             (<code>UUID</code>)         \u2013 <p>UUID of peer to make connection with.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PeerConnection</code>         \u2013 <p>The peer connection object.</p> </li> </ul> Source code in <code>proxystore/p2p/manager.py</code> <pre><code>async def get_connection(self, peer_uuid: UUID) -&gt; PeerConnection:\n\"\"\"Get connection to the peer.\n    Args:\n        peer_uuid: UUID of peer to make connection with.\n    Returns:\n        The peer connection object.\n    \"\"\"\npeers = frozenset({self._uuid, peer_uuid})\nasync with self._peers_lock:\nif peers in self._peers:\nreturn self._peers[peers]\nconnection = PeerConnection(\nself._uuid,\nself._name,\nself._websocket,\nchannels=self._peer_channels,\n)\nself._peers[peers] = connection\nlogger.info(\nf'{self._log_prefix}: opening peer connection with '\nf'{peer_uuid}',\n)\nawait connection.send_offer(peer_uuid)\nself._tasks[peers] = spawn_guarded_background_task(\nself._handle_peer_messages,\npeer_uuid,\nconnection,\n)\nreturn connection\n</code></pre>"},{"location":"reference/p2p/messages/","title":"proxystore.p2p.messages","text":"<p>Message types for peer-to-peer communication.</p>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.MessageType","title":"MessageType","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Types of messages supported.</p>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.MessageType.server_response","title":"server_response  <code>class-attribute</code>","text":"<pre><code>server_response = 'ServerResponse'\n</code></pre> <p>Server response message.</p>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.MessageType.server_registration","title":"server_registration  <code>class-attribute</code>","text":"<pre><code>server_registration = 'ServerRegistration'\n</code></pre> <p>Server registration message.</p>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.MessageType.peer_connection","title":"peer_connection  <code>class-attribute</code>","text":"<pre><code>peer_connection = 'PeerConnection'\n</code></pre> <p>Peer connection message.</p>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.Message","title":"Message  <code>dataclass</code>","text":"<p>Base message.</p>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.ServerRegistration","title":"ServerRegistration  <code>dataclass</code>","text":"<p>         Bases: <code>Message</code></p> <p>Register with signaling server as peer.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of peer requesting to register.</p> </li> <li> uuid             (<code>uuid.UUID</code>)         \u2013 <p>UUID of peer requesting to register.</p> </li> </ul>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.ServerResponse","title":"ServerResponse  <code>dataclass</code>","text":"<p>         Bases: <code>Message</code></p> <p>Message returned by signaling server on success or error.</p> <p>Attributes:</p> <ul> <li> success             (<code>bool</code>)         \u2013 <p>If the registration was successful.</p> </li> <li> message             (<code>str | None</code>)         \u2013 <p>Message from server.</p> </li> <li> error             (<code>bool</code>)         \u2013 <p>If <code>message</code> is an error message.</p> </li> </ul>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.PeerConnection","title":"PeerConnection  <code>dataclass</code>","text":"<p>         Bases: <code>Message</code></p> <p>Message used in establishing a peer-to-peer connection.</p> <p>Attributes:</p> <ul> <li> source_uuid             (<code>uuid.UUID</code>)         \u2013 <p>UUID of sending peer.</p> </li> <li> source_name             (<code>str</code>)         \u2013 <p>Name of sending peer.</p> </li> <li> peer_uuid             (<code>uuid.UUID</code>)         \u2013 <p>UUID of destination peer.</p> </li> <li> description_type             (<code>Literal[answer, offer]</code>)         \u2013 <p>One of <code>'answer'</code> or <code>'offer'</code> indicating the type of message being sent.</p> </li> <li> description             (<code>str</code>)         \u2013 <p>Session description protocol message.</p> </li> <li> error             (<code>str | None</code>)         \u2013 <p>Error string if a problem occurs.</p> </li> </ul>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.MessageDecodeError","title":"MessageDecodeError","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when a message cannot be decoded.</p>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.MessageEncodeError","title":"MessageEncodeError","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when an message cannot be encoded.</p>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.uuid_to_str","title":"uuid_to_str","text":"<pre><code>uuid_to_str(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Cast any UUIDs to strings.</p> <p>Scans the input dictionary for any values where the associated key contains 'uuid' and value is a UUID instance and converts it to a string for jsonification.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>Shallow copy of the input dictionary with values cast from UUID         to str if their key also contains UUID.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def uuid_to_str(data: dict[str, Any]) -&gt; dict[str, Any]:\n\"\"\"Cast any UUIDs to strings.\n    Scans the input dictionary for any values where the associated key\n    contains 'uuid' and value is a UUID instance and converts it to a\n    string for jsonification.\n    Returns:\n        Shallow copy of the input dictionary with values cast from UUID \\\n        to str if their key also contains UUID.\n    \"\"\"\ndata = data.copy()\nfor key in data:\nif 'uuid' in key.lower() and isinstance(data[key], uuid.UUID):\ndata[key] = str(data[key])\nreturn data\n</code></pre>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.str_to_uuid","title":"str_to_uuid","text":"<pre><code>str_to_uuid(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Cast any possible UUID strings to UUID objects.</p> <p>The inverse operation of uuid_to_str().</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>Shallow copy of the input dictionary with values cast from         str to UUID if the key also contains UUID.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MessageDecodeError</code>           \u2013         <p>If a key contains 'uuid' but the value cannot be cast to a UUID.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def str_to_uuid(data: dict[str, Any]) -&gt; dict[str, Any]:\n\"\"\"Cast any possible UUID strings to UUID objects.\n    The inverse operation of\n    [uuid_to_str()][proxystore.p2p.messages.uuid_to_str].\n    Returns:\n        Shallow copy of the input dictionary with values cast from \\\n        str to UUID if the key also contains UUID.\n    Raises:\n        MessageDecodeError: If a key contains 'uuid' but the value cannot be\n            cast to a UUID.\n    \"\"\"\ndata = data.copy()\nfor key in data:\nif 'uuid' in key.lower():\ntry:\ndata[key] = uuid.UUID(data[key])\nexcept (AttributeError, TypeError, ValueError) as e:\nraise MessageDecodeError(\nf'Failed to convert key {key} to UUID.',\n) from e\nreturn data\n</code></pre>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.decode","title":"decode","text":"<pre><code>decode(message: str) -&gt; Message\n</code></pre> <p>Decode JSON string into correct Message type.</p> <p>Parameters:</p> <ul> <li> message             (<code>str</code>)         \u2013 <p>JSON string to decode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>         \u2013 <p>Parsed message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MessageDecodeError</code>           \u2013         <p>If the message cannot be decoded.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def decode(message: str) -&gt; Message:\n\"\"\"Decode JSON string into correct Message type.\n    Args:\n        message: JSON string to decode.\n    Returns:\n        Parsed message.\n    Raises:\n        MessageDecodeError: If the message cannot be decoded.\n    \"\"\"\ntry:\ndata = json.loads(message)\nexcept json.JSONDecodeError as e:\nraise MessageDecodeError('Failed to load string as JSON.') from e\ntry:\nmessage_type_name = data.pop('message_type')\nexcept KeyError as e:\nraise MessageDecodeError(\n'Message does not contain a message_type key.',\n) from e\ntry:\nmessage_type = getattr(\nsys.modules[__name__],\nMessageType[message_type_name].value,\n)\nexcept (AttributeError, KeyError) as e:\nraise MessageDecodeError(\n'The message is of an unknown message type: '\nf'{message_type_name}.',\n) from e\ndata = str_to_uuid(data)\ntry:\nreturn message_type(**data)\nexcept TypeError as e:\nraise MessageDecodeError(\nf'Failed to convert message to {message_type.__name__}: {e}',\n) from e\n</code></pre>"},{"location":"reference/p2p/messages/#proxystore.p2p.messages.encode","title":"encode","text":"<pre><code>encode(message: Message) -&gt; str\n</code></pre> <p>Encode message as JSON string.</p> <p>Parameters:</p> <ul> <li> message             (<code>Message</code>)         \u2013 <p>Message to JSON encode.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MessageEncodeError</code>           \u2013         <p>If the message cannot be JSON encoded.</p> </li> </ul> Source code in <code>proxystore/p2p/messages.py</code> <pre><code>def encode(message: Message) -&gt; str:\n\"\"\"Encode message as JSON string.\n    Args:\n        message: Message to JSON encode.\n    Raises:\n        MessageEncodeError: If the message cannot be JSON encoded.\n    \"\"\"\nif not isinstance(message, Message):\nraise MessageEncodeError(\nf'Message is not an instance of {Message.__name__}. '\nf'Got {type(message).__name__}.',\n)\ndata = dataclasses.asdict(message)\ndata = uuid_to_str(data)\ntry:\nreturn json.dumps(data)\nexcept TypeError as e:\nraise MessageEncodeError('Error encoding message.') from e\n</code></pre>"},{"location":"reference/p2p/server/","title":"proxystore.p2p.server","text":"<p>Signaling server implementation for WebRTC peer connections.</p>"},{"location":"reference/p2p/server/#proxystore.p2p.server.Client","title":"Client  <code>dataclass</code>","text":"<p>Representation of client connection.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of client.</p> </li> <li> uuid             (<code>UUID</code>)         \u2013 <p>UUID of client.</p> </li> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>WebSocket connection to the client.</p> </li> </ul>"},{"location":"reference/p2p/server/#proxystore.p2p.server.SignalingServer","title":"SignalingServer","text":"<pre><code>SignalingServer() -&gt; None\n</code></pre> <p>Signaling Server implementation.</p> <p>The Signaling Server acts as a public third-party that helps two peers (endpoints) establish a peer-to-peer connection during the WebRTC peer connection initiation process. The signaling server's responsibility is just to forward session descriptions between two peers, so the server can be relatively lightweight and typically only needs to transfer two messages to establish a peer connection, after which the peers no longer need the signaling server.</p> <p>To learn more about the WebRTC peer connection process, check out https://webrtc.org/getting-started/peer-connections.</p> <p>The signaling server is built on websockets and designed to be served using <code>websockets.serve()</code>.</p> Example <pre><code>import websockets\nfrom proxystore.p2p.server import SignalingServer\nsignaling_server = SignalingServer()\nasync with websockets.serve(\nsignaling_server.handler, host='localhost', port=1234\n) as websocket_server:\n...\n</code></pre> Source code in <code>proxystore/p2p/server.py</code> <pre><code>def __init__(self) -&gt; None:\nself._websocket_to_client: dict[WebSocketServerProtocol, Client] = {}\nself._uuid_to_client: dict[UUID, Client] = {}\n</code></pre>"},{"location":"reference/p2p/server/#proxystore.p2p.server.SignalingServer.send","title":"send  <code>async</code>","text":"<pre><code>send(\nwebsocket: WebSocketServerProtocol,\nmessage: messages.Message,\n) -&gt; None\n</code></pre> <p>Send message on the socket.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket to send message on.</p> </li> <li> message             (<code>messages.Message</code>)         \u2013 <p>Message to json encode and send.</p> </li> </ul> Source code in <code>proxystore/p2p/server.py</code> <pre><code>async def send(\nself,\nwebsocket: WebSocketServerProtocol,\nmessage: messages.Message,\n) -&gt; None:\n\"\"\"Send message on the socket.\n    Args:\n        websocket: Websocket to send message on.\n        message: Message to json encode and send.\n    \"\"\"\ntry:\nmessage_str = messages.encode(message)\nexcept messages.MessageEncodeError as e:\nlogger.error(f'failed to encode message: {e}')\nreturn\ntry:\nawait websocket.send(message_str)\nexcept websockets.exceptions.ConnectionClosed:\nlogger.error('connection closed while attempting to send message')\n</code></pre>"},{"location":"reference/p2p/server/#proxystore.p2p.server.SignalingServer.register","title":"register  <code>async</code>","text":"<pre><code>register(\nwebsocket: WebSocketServerProtocol,\nrequest: messages.ServerRegistration,\n) -&gt; None\n</code></pre> <p>Register peer with Signaling Server.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket connection with client wanting to register.</p> </li> <li> request             (<code>messages.ServerRegistration</code>)         \u2013 <p>Registration request message.</p> </li> </ul> Source code in <code>proxystore/p2p/server.py</code> <pre><code>async def register(\nself,\nwebsocket: WebSocketServerProtocol,\nrequest: messages.ServerRegistration,\n) -&gt; None:\n\"\"\"Register peer with Signaling Server.\n    Args:\n        websocket: Websocket connection with client wanting to register.\n        request: Registration request message.\n    \"\"\"\nif websocket not in self._websocket_to_client:\n# Check if previous client reconnected on new socket so unregister\n# old socket. Warning: could be a client impersontating another\nif request.uuid in self._uuid_to_client:\nlogger.info(\nf'previously registered client {request.uuid} attempting '\n'to reregister so old registration will be removed',\n)\nawait self.unregister(\nself._uuid_to_client[request.uuid].websocket,\nFalse,\n)\nclient = Client(\nname=request.name,\nuuid=request.uuid,\nwebsocket=websocket,\n)\nself._websocket_to_client[websocket] = client\nself._uuid_to_client[client.uuid] = client\nlogger.info(\nf'registered {client.uuid} ({client.name} at '\nf'{websocket.remote_address})',\n)\nelse:\nclient = self._websocket_to_client[websocket]\nlogger.info(\nf'previously registered client {client.uuid} attempting to '\n'reregister so previous registration will be returned',\n)\nawait self.send(websocket, messages.ServerResponse(success=True))\n</code></pre>"},{"location":"reference/p2p/server/#proxystore.p2p.server.SignalingServer.unregister","title":"unregister  <code>async</code>","text":"<pre><code>unregister(\nwebsocket: WebSocketServerProtocol, expected: bool\n) -&gt; None\n</code></pre> <p>Unregister the endpoint.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket connection that was closed.</p> </li> <li> expected             (<code>bool</code>)         \u2013 <p>If the connection was closed intentionally or due to an error.</p> </li> </ul> Source code in <code>proxystore/p2p/server.py</code> <pre><code>async def unregister(\nself,\nwebsocket: WebSocketServerProtocol,\nexpected: bool,\n) -&gt; None:\n\"\"\"Unregister the endpoint.\n    Args:\n        websocket: Websocket connection that was closed.\n        expected: If the connection was closed intentionally or due to an\n            error.\n    \"\"\"\nclient = self._websocket_to_client.pop(websocket, None)\nif client is None:\n# Most likely websocket closed before registration was performed\nreturn\nreason = 'ok' if expected else 'unexpected'\nlogger.info(\nf'unregistering client {client.uuid} ({client.name}) '\nf'for {reason} reason',\n)\nself._uuid_to_client.pop(client.uuid, None)\nawait client.websocket.close(code=1000 if expected else 1001)\n</code></pre>"},{"location":"reference/p2p/server/#proxystore.p2p.server.SignalingServer.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(\nwebsocket: WebSocketServerProtocol,\nmessage: messages.PeerConnection,\n) -&gt; None\n</code></pre> <p>Pass peer connection messages between clients.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket connection with client that sent the peer connection message.</p> </li> <li> message             (<code>messages.PeerConnection</code>)         \u2013 <p>Message to forward to peer client.</p> </li> </ul> Source code in <code>proxystore/p2p/server.py</code> <pre><code>async def connect(\nself,\nwebsocket: WebSocketServerProtocol,\nmessage: messages.PeerConnection,\n) -&gt; None:\n\"\"\"Pass peer connection messages between clients.\n    Args:\n        websocket: Websocket connection with client that sent the peer\n            connection message.\n        message: Message to forward to peer client.\n    \"\"\"\nclient = self._websocket_to_client[websocket]\nif message.peer_uuid not in self._uuid_to_client:\nlogger.warning(\nf'client {client.uuid} ({client.name}) attempting to send '\nf'message to unknown peer {message.peer_uuid}',\n)\nmessage.error = (\n'Cannot forward peer connection message to peer '\nf'{message.peer_uuid} because this peer is unknown.'\n)\nawait self.send(websocket, message)\nelse:\npeer_client = self._uuid_to_client[message.peer_uuid]\nlogger.info(\nf'transmitting message from {client.uuid} ({client.name}) '\nf'to {message.peer_uuid}',\n)\nawait self.send(peer_client.websocket, message)\n</code></pre>"},{"location":"reference/p2p/server/#proxystore.p2p.server.SignalingServer.handler","title":"handler  <code>async</code>","text":"<pre><code>handler(\nwebsocket: WebSocketServerProtocol, uri: str\n) -&gt; None\n</code></pre> <p>Websocket server message handler.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>Websocket message was received on.</p> </li> <li> uri             (<code>str</code>)         \u2013 <p>URI message was sent to.</p> </li> </ul> Source code in <code>proxystore/p2p/server.py</code> <pre><code>async def handler(\nself,\nwebsocket: WebSocketServerProtocol,\nuri: str,\n) -&gt; None:\n\"\"\"Websocket server message handler.\n    Args:\n        websocket: Websocket message was received on.\n        uri: URI message was sent to.\n    \"\"\"\nlogger.info('signaling server listening for incoming connections')\nwhile True:\ntry:\nmessage_str = await websocket.recv()\nif isinstance(message_str, str):\nmessage = messages.decode(message_str)\nelse:\nraise AssertionError(\n'Received non-str type on websocket.',\n)\nexcept websockets.exceptions.ConnectionClosedOK:\nawait self.unregister(websocket, expected=True)\nbreak\nexcept websockets.exceptions.ConnectionClosedError:\nawait self.unregister(websocket, expected=False)\nbreak\nexcept messages.MessageDecodeError as e:\nlogger.error(\n'caught deserialization error on message received from '\nf'{websocket.remote_address}: {e} ...skipping message',\n)\ncontinue\nif isinstance(message, messages.ServerRegistration):\nawait self.register(websocket, message)\nelif isinstance(message, messages.PeerConnection):\nif websocket in self._websocket_to_client:\nawait self.connect(websocket, message)\nelse:\n# If message is not a registration request but this client\n# has not yet registered, let them know\nlogger.info(\n'returning server error to message received from '\nf'unregistered client {message.source_uuid} '\nf'({message.source_name})',\n)\nresponse = messages.ServerResponse(\nsuccess=False,\nmessage='client has not registered yet',\nerror=True,\n)\nawait self.send(websocket, response)\nelse:\nraise AssertionError('Unreachable.')\n</code></pre>"},{"location":"reference/p2p/server/#proxystore.p2p.server.serve","title":"serve  <code>async</code>","text":"<pre><code>serve(\nhost: str,\nport: int,\ncertfile: str | None = None,\nkeyfile: str | None = None,\n) -&gt; None\n</code></pre> <p>Run the signaling server.</p> <p>Initializes a <code>SignalingServer</code> and starts a websocket server listening on <code>host:port</code> for new connections and incoming messages.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>Host to listen on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Port to listen on.</p> </li> <li> certfile             (<code>str | None</code>)         \u2013 <p>Optional certificate file (PEM format) to enable TLS while serving.</p> </li> <li> keyfile             (<code>str | None</code>)         \u2013 <p>Optional private key file. If not specified, the key will be taken from the certfile.</p> </li> </ul> Source code in <code>proxystore/p2p/server.py</code> <pre><code>async def serve(\nhost: str,\nport: int,\ncertfile: str | None = None,\nkeyfile: str | None = None,\n) -&gt; None:\n\"\"\"Run the signaling server.\n    Initializes a [`SignalingServer`][proxystore.p2p.server.SignalingServer]\n    and starts a websocket server listening on `host:port` for new connections\n    and incoming messages.\n    Args:\n        host: Host to listen on.\n        port: Port to listen on.\n        certfile: Optional certificate file (PEM format) to enable TLS while\n            serving.\n        keyfile: Optional private key file. If not specified, the key will be\n            taken from the certfile.\n    \"\"\"\nserver = SignalingServer()\n# Set the stop condition when receiving SIGINT (ctrl-C) and SIGTERM.\nloop = asyncio.get_running_loop()\nstop = loop.create_future()\nloop.add_signal_handler(signal.SIGINT, stop.set_result, None)\nloop.add_signal_handler(signal.SIGTERM, stop.set_result, None)\nssl_context: ssl.SSLContext | None = None\nif certfile is not None:  # pragma: no cover\nssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\nssl_context.load_cert_chain(certfile, keyfile=keyfile)\nasync with websockets.server.serve(\nserver.handler,\nhost,\nport,\nlogger=logger,\nssl=ssl_context,\n):\nlogger.info(f'serving signaling server on {host}:{port}')\nlogger.info('use ctrl-C to stop')\nawait stop\nlogger.info('server closed')\n</code></pre>"},{"location":"reference/p2p/server/#proxystore.p2p.server.main","title":"main","text":"<pre><code>main(argv: Sequence[str] | None = None) -&gt; int\n</code></pre> <p>CLI for starting the signaling server.</p> <p>Usage</p> <pre><code>$ signaling-server {options}\n$ signaling-server --help\n</code></pre> Source code in <code>proxystore/p2p/server.py</code> <pre><code>def main(argv: Sequence[str] | None = None) -&gt; int:\n\"\"\"CLI for starting the signaling server.\n    !!! note \"Usage\"\n        ```bash\n        $ signaling-server {options}\n        $ signaling-server --help\n        ```\n    \"\"\"\nparser = argparse.ArgumentParser(\n'Websocket-based Signaling Server',\nformatter_class=argparse.ArgumentDefaultsHelpFormatter,\n)\nparser.add_argument(\n'--host',\ndefault='0.0.0.0',\nhelp='host to listen on',\n)\nparser.add_argument(\n'--port',\ndefault=8765,\ntype=int,\nhelp='port to listen on',\n)\nparser.add_argument(\n'--certfile',\ndefault=None,\nhelp='certificate file for serving with TLS',\n)\nparser.add_argument(\n'--keyfile',\ndefault=None,\nhelp='private key file associated with the certificate file',\n)\nparser.add_argument(\n'--log-dir',\ndefault=None,\nhelp='write logs named server.log.{timestamp} to this dir',\n)\nparser.add_argument(\n'--log-level',\nchoices=['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'],\ndefault='INFO',\nhelp='logging level',\n)\nargs = parser.parse_args(argv)\nhandlers: list[logging.Handler] = [logging.StreamHandler(sys.stdout)]\nif args.log_dir is not None:\nos.makedirs(args.log_dir, exist_ok=True)\nhandlers.append(\nlogging.handlers.TimedRotatingFileHandler(\nos.path.join(args.log_dir, 'server.log'),\n# Rotate logs Sunday at midnight\nwhen='W6',\natTime=datetime.time(hour=0, minute=0, second=0),\n),\n)\nlogging.basicConfig(\nformat=(\n'[%(asctime)s.%(msecs)03d] %(levelname)-5s (%(name)s) :: '\n'%(message)s'\n),\ndatefmt='%Y-%m-%d %H:%M:%S',\nlevel=args.log_level,\nhandlers=handlers,\n)\nasyncio.run(\nserve(\nargs.host,\nargs.port,\ncertfile=args.certfile,\nkeyfile=args.keyfile,\n),\n)\nreturn 0\n</code></pre>"},{"location":"reference/p2p/task/","title":"proxystore.p2p.task","text":"<p>Utilities for launching async tasks.</p>"},{"location":"reference/p2p/task/#proxystore.p2p.task.SafeTaskExitError","title":"SafeTaskExitError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception that can be raised inside a task to safely exit it.</p>"},{"location":"reference/p2p/task/#proxystore.p2p.task.exit_on_error","title":"exit_on_error","text":"<pre><code>exit_on_error(task: asyncio.Task[Any]) -&gt; None\n</code></pre> <p>Task callback that raises SystemExit on task exception.</p> Source code in <code>proxystore/p2p/task.py</code> <pre><code>def exit_on_error(task: asyncio.Task[Any]) -&gt; None:\n\"\"\"Task callback that raises SystemExit on task exception.\"\"\"\nif (\nnot task.cancelled()\nand task.exception() is not None\nand not isinstance(task.exception(), SafeTaskExitError)\n):\nlogger.error(f'Exception in background coroutine: {task.exception()}')\nraise SystemExit(1)\n</code></pre>"},{"location":"reference/p2p/task/#proxystore.p2p.task.spawn_guarded_background_task","title":"spawn_guarded_background_task","text":"<pre><code>spawn_guarded_background_task(\ncoro: Callable[..., Coroutine[Any, Any, None]],\n*args: Any,\n**kwargs: Any\n) -&gt; asyncio.Task[Any]\n</code></pre> <p>Run a coroutine safely in the background.</p> <p>Launches the coroutine as an asyncio task and sets the done callback to <code>exit_on_error()</code>. This is \"safe\" because it will ensure exceptions inside the task get logged and cause the program to exit. Otherwise, background tasks that are not awaited may not have their exceptions raised such that programs hang with no notice of the exception that caused the hang.</p> <p>Tasks can raise <code>SafeTaskExit</code> to signal the task is finished but should not cause a system exit.</p> <p>Source: https://stackoverflow.com/questions/62588076</p> <p>Parameters:</p> <ul> <li> coro             (<code>Callable[..., Coroutine[Any, Any, None]]</code>)         \u2013 <p>Coroutine to run as task.</p> </li> <li> args             (<code>Any</code>)         \u2013 <p>Positional arguments for the coroutine.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Keyword arguments for the coroutine.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>asyncio.Task[Any]</code>         \u2013 <p>Asyncio task handle.</p> </li> </ul> Source code in <code>proxystore/p2p/task.py</code> <pre><code>def spawn_guarded_background_task(\ncoro: Callable[..., Coroutine[Any, Any, None]],\n*args: Any,\n**kwargs: Any,\n) -&gt; asyncio.Task[Any]:\n\"\"\"Run a coroutine safely in the background.\n    Launches the coroutine as an asyncio task and sets the done\n    callback to [`exit_on_error()`][proxystore.p2p.task.exit_on_error].\n    This is \"safe\" because it will ensure exceptions inside the task get logged\n    and cause the program to exit. Otherwise, background tasks that are not\n    awaited may not have their exceptions raised such that programs hang with\n    no notice of the exception that caused the hang.\n    Tasks can raise [`SafeTaskExit`][proxystore.p2p.task.SafeTaskExitError] to\n    signal the task is finished but should not cause a system exit.\n    Source: https://stackoverflow.com/questions/62588076\n    Args:\n        coro: Coroutine to run as task.\n        args: Positional arguments for the coroutine.\n        kwargs: Keyword arguments for the coroutine.\n    Returns:\n        Asyncio task handle.\n    \"\"\"\ntask = asyncio.create_task(coro(*args, **kwargs))\ntask.add_done_callback(exit_on_error)\nreturn task\n</code></pre>"},{"location":"reference/store/","title":"proxystore.store","text":"<p>Module containing all <code>Store</code> implementations.</p> Type Use Case <code>LocalStore</code> In-memory object store local to the process. Useful for development. <code>RedisStore</code> Store objects in a preconfigured Redis server. <code>FileStore</code> Use a globally accessible file system for string objects. <code>GlobusStore</code> Transfer objects between two Globus endpoints. <code>EndpointStore</code> Experimental: P2P object stores for multi-site applications. <code>MargoStore</code> Experimental: Distributed in-memory storage across nodes with Margo communication. <code>UCXStore</code> Experimental: Distributed in-memory storage across nodes with UCX communication. <code>WebsocketStore</code> Experimental: Distributed in-memory storage across nodes with Websocket communication."},{"location":"reference/store/#proxystore.store.get_store","title":"get_store","text":"<pre><code>get_store(val: str | Proxy[T]) -&gt; Store[Any] | None\n</code></pre> <p>Get the backend store with name.</p> <p>Parameters:</p> <ul> <li> val             (<code>str | Proxy[T]</code>)         \u2013 <p>name of the store to get or a <code>Proxy</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Store[Any] | None</code>         \u2013 <p><code>Store</code> if a store matching the         name or belonging to the proxy exists. If the store does not exist,         returns <code>None</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ProxyStoreFactoryError</code>           \u2013         <p>If the value is a proxy but does not contain a factory of type <code>StoreFactory</code>.</p> </li> </ul> Source code in <code>proxystore/store/__init__.py</code> <pre><code>def get_store(val: str | Proxy[T]) -&gt; Store[Any] | None:\n\"\"\"Get the backend store with name.\n    Args:\n        val: name of the store to get or a [`Proxy`][proxystore.proxy.Proxy]\n            instance.\n    Returns:\n        [`Store`][proxystore.store.base.Store] if a store matching the \\\n        name or belonging to the proxy exists. If the store does not exist, \\\n        returns `None`.\n    Raises:\n        ProxyStoreFactoryError: If the value is a proxy but does not contain a\n            factory of type\n            [`StoreFactory`][proxystore.store.base.StoreFactory].\n    \"\"\"\nif isinstance(val, Proxy):\n# If the object is a proxy, get the factory that will access the store\nfactory = val.__factory__\nif isinstance(factory, StoreFactory):\nreturn factory.get_store()\nelse:\nraise ProxyStoreFactoryError(\n'The proxy must contain a factory with type '\nf'{type(StoreFactory).__name__}. {type(factory).__name__} '\n'is not supported.',\n)\nelse:\nname = val\nif name in _stores:\nreturn _stores[name]\nreturn None\n</code></pre>"},{"location":"reference/store/#proxystore.store.register_store","title":"register_store","text":"<pre><code>register_store(\nstore: Store[Any], exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Register the store instance to the global registry.</p> Note <p>Global means globally accessible within the Python process.</p> <p>Parameters:</p> <ul> <li> store             (<code>Store[Any]</code>)         \u2013 <p>Store instance to register.</p> </li> <li> exist_ok             (<code>bool</code>)         \u2013 <p>If a store with the same name exists, overwrite it.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>StoreExistsError</code>           \u2013         <p>If a store with the same name is already registered and <code>exist_ok</code> is false.</p> </li> </ul> Source code in <code>proxystore/store/__init__.py</code> <pre><code>def register_store(store: Store[Any], exist_ok: bool = False) -&gt; None:\n\"\"\"Register the store instance to the global registry.\n    Note:\n        Global means globally accessible within the Python process.\n    Args:\n        store: Store instance to register.\n        exist_ok: If a store with the same name exists, overwrite it.\n    Raises:\n        StoreExistsError: If a store with the same name is already registered\n            and `exist_ok` is false.\n    \"\"\"\nif store.name in _stores and not exist_ok:\nraise StoreExistsError(f'A store named {store.name} already exists.')\n_stores[store.name] = store\nlogger.debug(f'added {store.name} to global registry of stores')\n</code></pre>"},{"location":"reference/store/#proxystore.store.unregister_store","title":"unregister_store","text":"<pre><code>unregister_store(name: str) -&gt; None\n</code></pre> <p>Unregisters the store instance from the global registry.</p> Note <p>This function is a no-op if no store matching the name exists (i.e., no exception will be raised).</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store to unregister.</p> </li> </ul> Source code in <code>proxystore/store/__init__.py</code> <pre><code>def unregister_store(name: str) -&gt; None:\n\"\"\"Unregisters the store instance from the global registry.\n    Note:\n        This function is a no-op if no store matching the name\n        exists (i.e., no exception will be raised).\n    Args:\n        name: Name of the store to unregister.\n    \"\"\"\nif name in _stores:\ndel _stores[name]\nlogger.debug(f'removed {name} from global registry of stores')\n</code></pre>"},{"location":"reference/store/base/","title":"proxystore.store.base","text":"<p>Base Store Abstract Class.</p>"},{"location":"reference/store/base/#proxystore.store.base.SerializerT","title":"SerializerT  <code>module-attribute</code>","text":"<pre><code>SerializerT = Callable[[Any], bytes]\n</code></pre> <p>Serializer type alias.</p>"},{"location":"reference/store/base/#proxystore.store.base.DeserializerT","title":"DeserializerT  <code>module-attribute</code>","text":"<pre><code>DeserializerT = Callable[[bytes], Any]\n</code></pre> <p>Deserializer type alias.</p>"},{"location":"reference/store/base/#proxystore.store.base.StoreFactory","title":"StoreFactory","text":"<pre><code>StoreFactory(\nkey: KeyT,\nstore_type: type[Store[KeyT]],\nstore_name: str,\nstore_kwargs: dict[str, Any] | None = None,\n*,\nevict: bool = False,\ndeserializer: DeserializerT | None = None\n) -&gt; None\n</code></pre> <p>         Bases: <code>Factory[T]</code>, <code>Generic[KeyT, T]</code></p> <p>Base Factory for Stores.</p> <p>Adds support for asynchronously retrieving objects from a <code>Store</code>.</p> <p>The factory takes the <code>store_type</code> and <code>store_kwargs</code> parameters that are used to reinitialize the store if the factory is sent to a remote process where the store has not already been initialized.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>Key corresponding to object in store.</p> </li> <li> store_type             (<code>type[Store[KeyT]]</code>)         \u2013 <p>Type of store this factory will resolve an object from.</p> </li> <li> store_name             (<code>str</code>)         \u2013 <p>Name of store.</p> </li> <li> store_kwargs             (<code>dict[str, Any] | None</code>)         \u2013 <p>Optional keyword arguments used to reinitialize store.</p> </li> <li> evict             (<code>bool</code>)         \u2013 <p>If True, evict the object from the store once <code>resolve()</code> is called.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def __init__(\nself,\nkey: KeyT,\nstore_type: type[Store[KeyT]],\nstore_name: str,\nstore_kwargs: dict[str, Any] | None = None,\n*,\nevict: bool = False,\ndeserializer: DeserializerT | None = None,\n) -&gt; None:\nself.key = key\nself.store_type = store_type\nself.store_name = store_name\nself.store_kwargs = {} if store_kwargs is None else store_kwargs\nself.evict = evict\nself.deserializer = deserializer\n# The following are not included when a factory is serialized\n# because they are specific to that instance of the factory\nself._obj_future: Future[T] | None = None\nself.stats: FunctionEventStats | None = None\nif 'stats' in self.store_kwargs and self.store_kwargs['stats'] is True:\nself.stats = FunctionEventStats()\n# Monkeypatch methods with wrappers to track their stats\nsetattr(  # noqa: B010\nself,\n'resolve',\nself.stats.wrap(self.resolve, preset_key=self.key),\n)\nsetattr(  # noqa: B010\nself,\n'resolve_async',\nself.stats.wrap(self.resolve_async, preset_key=self.key),\n)\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.StoreFactory.get_store","title":"get_store","text":"<pre><code>get_store() -&gt; Store[KeyT]\n</code></pre> <p>Get store and reinitialize if necessary.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If the type of the returned store does not match the expected store type passed to the factory constructor.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def get_store(self) -&gt; Store[KeyT]:\n\"\"\"Get store and reinitialize if necessary.\n    Raises:\n        ValueError: If the type of the returned store does not match the\n            expected store type passed to the factory constructor.\n    \"\"\"\nstore = ps.store.get_store(self.store_name)\nif store is None:\nstore = self.store_type(self.store_name, **self.store_kwargs)\nps.store.register_store(store)\nif not isinstance(store, self.store_type):\nraise ValueError(\nf'store_name={self.store_name} passed to '\nf'{type(self).__name__} does not correspond to store of '\nf'type {self.store_type.__name__}',\n)\nreturn store\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.StoreFactory.resolve","title":"resolve","text":"<pre><code>resolve() -&gt; T\n</code></pre> <p>Get object associated with key from store.</p> <p>Raises:</p> <ul> <li> <code>ProxyResolveMissingKeyError</code>           \u2013         <p>If the key associated with this factory does not exist in the store.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def resolve(self) -&gt; T:\n\"\"\"Get object associated with key from store.\n    Raises:\n        ProxyResolveMissingKeyError: If the key associated with this\n            factory does not exist in the store.\n    \"\"\"\nif self._obj_future is not None:\nobj = self._obj_future.result()\nself._obj_future = None\nreturn obj\nreturn self._get_value()\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.StoreFactory.resolve_async","title":"resolve_async","text":"<pre><code>resolve_async() -&gt; None\n</code></pre> <p>Asynchronously get object associated with key from store.</p> Source code in <code>proxystore/store/base.py</code> <pre><code>def resolve_async(self) -&gt; None:\n\"\"\"Asynchronously get object associated with key from store.\"\"\"\nif self._should_resolve_async():\nself._obj_future = _default_pool.submit(self._get_value)\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store","title":"Store","text":"<pre><code>Store(\nname: str,\n*,\ncache_size: int = 16,\nstats: bool = False,\nkwargs: dict[str, Any] | None\n) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[KeyT]</code></p> <p>Key-value store interface.</p> <p>Provides base functionality for interaction with an object store including serialization and caching.</p> <p>Subclasses of <code>Store</code> must implement <code>create_key()</code>, <code>evict()</code>, <code>exists()</code>, <code>get_bytes()</code>, and <code>set_bytes()</code>. Subclasses may implement <code>close()</code> if needed.</p> <p>The <code>Store</code> handles caching and stores all objects as key-bytestring pairs, i.e., objects passed to <code>get()</code> or <code>set()</code> will be appropriately (de)serialized before being passed to <code>get_bytes()</code> or <code>set_bytes()</code>, respectively.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Collect stats on store operations.</p> </li> <li> kwargs             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional keyword arguments to return from <code>Store.kwargs</code>. I.e., the additional keyword arguments needed to reinitialize this store.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>cache_size</code> is less than zero.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\ncache_size: int = 16,\nstats: bool = False,\nkwargs: dict[str, Any] | None,\n) -&gt; None:\nif cache_size &lt; 0:\nraise ValueError(\nf'Cache size cannot be negative. Got {cache_size}.',\n)\nself.name = name\nself._cache: LRUCache[KeyT, Any] = LRUCache(cache_size)\nself._kwargs = {'stats': stats, 'cache_size': cache_size}\nif kwargs is not None:  # pragma: no branch\nself._kwargs.update(kwargs)\nself._stats: FunctionEventStats | None = None\nif stats:\nself._stats = FunctionEventStats()\n# Monkeypatch methods with wrappers to track their stats\nfor attr in dir(self):\nif (\ncallable(getattr(self, attr))\nand not attr.startswith('_')\nand attr in STORE_METHOD_KEY_IS_RESULT\n):\nmethod = getattr(self, attr)\n# For most method, the key is the first arg which wrap()\n# expects by default, but there are a couple where the\n# key is passed as a kwarg\nwrapped = self._stats.wrap(\nmethod,\nkey_is_result=STORE_METHOD_KEY_IS_RESULT[attr],\n)\nsetattr(self, attr, wrapped)\nlogger.debug(f'initialized {self}')\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.has_stats","title":"has_stats  <code>property</code>","text":"<pre><code>has_stats: bool\n</code></pre> <p>Whether the store keeps track of performance stats.</p>"},{"location":"reference/store/base/#proxystore.store.base.Store.kwargs","title":"kwargs  <code>property</code>","text":"<pre><code>kwargs: dict[str, Any]\n</code></pre> <p>Kwargs for this store instance.</p>"},{"location":"reference/store/base/#proxystore.store.base.Store.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Cleanup any objects associated with the store.</p> <p>Many <code>Store</code> types do not have any objects that requiring cleaning up so this method a no-op by default unless overridden.</p> Warning <p>This method should only be called at the end of the program when the store will no longer be used, for example once all proxies have been resolved.</p> Source code in <code>proxystore/store/base.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Cleanup any objects associated with the store.\n    Many [`Store`][proxystore.store.base.Store] types do not have any\n    objects that requiring cleaning up so this method a no-op by default\n    unless overridden.\n    Warning:\n        This method should only be called at the end of the program\n        when the store will no longer be used, for example once all\n        proxies have been resolved.\n    \"\"\"\npass\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.create_key","title":"create_key","text":"<pre><code>create_key(obj: Any) -&gt; KeyT\n</code></pre> <p>Create key for the object.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>Object to be placed in store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>KeyT</code>         \u2013 <p>A key.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def create_key(self, obj: Any) -&gt; KeyT:\n\"\"\"Create key for the object.\n    Args:\n        obj: Object to be placed in store.\n    Returns:\n        A key.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.evict","title":"evict  <code>abstractmethod</code>","text":"<pre><code>evict(key: KeyT) -&gt; None\n</code></pre> <p>Evict object associated with key.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>The key corresponding to object in store to evict.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>@abstractmethod\ndef evict(self, key: KeyT) -&gt; None:\n\"\"\"Evict object associated with key.\n    Args:\n        key: The key corresponding to object in store to evict.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.exists","title":"exists  <code>abstractmethod</code>","text":"<pre><code>exists(key: KeyT) -&gt; bool\n</code></pre> <p>Check if key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>The key to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the key exists in the store.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>@abstractmethod\ndef exists(self, key: KeyT) -&gt; bool:\n\"\"\"Check if key exists.\n    Args:\n        key: The key to check.\n    Returns:\n        If the key exists in the store.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.get","title":"get","text":"<pre><code>get(\nkey: KeyT,\n*,\ndeserializer: DeserializerT | None = None,\ndefault: object | None = None\n) -&gt; Any | None\n</code></pre> <p>Return object associated with key.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>The key corresponding to object.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> default             (<code>object | None</code>)         \u2013 <p>Optionally provide value to be returned if an object associated with the key does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any | None</code>         \u2013 <p>The object associated with key or <code>default</code> if key does not exist.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def get(\nself,\nkey: KeyT,\n*,\ndeserializer: DeserializerT | None = None,\ndefault: object | None = None,\n) -&gt; Any | None:\n\"\"\"Return object associated with key.\n    Args:\n        key: The key corresponding to object.\n        deserializer: Optional callable used to deserialize the\n            byte string. If `None`, the default deserializer\n            ([`deserialize()`][proxystore.serialize.deserialize]) will be\n            used.\n        default: Optionally provide value to be returned if an object\n            associated with the key does not exist.\n    Returns:\n        The object associated with key or `default` if key does not exist.\n    \"\"\"\nif self.is_cached(key):\nvalue = self._cache.get(key)\nlogger.debug(\nf\"GET key='{key}' FROM {self.__class__.__name__}\"\nf\"(name='{self.name}'): was_cached=True\",\n)\nreturn value\nvalue = self.get_bytes(key)\nif value is not None:\nif deserializer is not None:\nvalue = deserializer(value)\nelse:\nvalue = default_deserializer(value)\nself._cache.set(key, value)\nlogger.debug(\nf\"GET key='{key}' FROM {self.__class__.__name__}\"\nf\"(name='{self.name}'): was_cached=False\",\n)\nreturn value\nlogger.debug(\nf\"GET key='{key}' FROM {self.__class__.__name__}\"\nf\"(name='{self.name}'): key did not exist, returned default\",\n)\nreturn default\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.get_bytes","title":"get_bytes  <code>abstractmethod</code>","text":"<pre><code>get_bytes(key: KeyT) -&gt; bytes | None\n</code></pre> <p>Get serialized object from remote store.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>The key corresponding to the object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>The serialized object or <code>None</code> if it does not exist.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>@abstractmethod\ndef get_bytes(self, key: KeyT) -&gt; bytes | None:\n\"\"\"Get serialized object from remote store.\n    Args:\n        key: The key corresponding to the object.\n    Returns:\n        The serialized object or `None` if it does not exist.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.is_cached","title":"is_cached","text":"<pre><code>is_cached(key: KeyT) -&gt; bool\n</code></pre> <p>Check if object is cached locally.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>The key corresponding to the object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the object associated with the key is cached.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def is_cached(self, key: KeyT) -&gt; bool:\n\"\"\"Check if object is cached locally.\n    Args:\n        key: The key corresponding to the object.\n    Returns:\n        If the object associated with the key is cached.\n    \"\"\"\nreturn self._cache.exists(key)\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.proxy","title":"proxy","text":"<pre><code>proxy(\nobj: T,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any\n) -&gt; Proxy[T]\n</code></pre> <p>Create a proxy that will resolve to an object in the store.</p> Warning <p>If the factory requires reinstantiating the store to correctly resolve the object, the factory should reinstantiate the store with the same arguments used to instantiate the store that created the proxy/factory. I.e. the :func:<code>proxy()</code> function should pass any arguments given to :func:<code>Store.__init__()</code> along to the factory so the factory can correctly recreate the store if the factory is resolved in a different Python process.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T</code>)         \u2013 <p>The object to place in store and return proxy for.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional arguments to pass to the Factory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Proxy[T]</code>         \u2013 <p>A proxy of the object.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def proxy(\nself,\nobj: T,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any,\n) -&gt; Proxy[T]:\n\"\"\"Create a proxy that will resolve to an object in the store.\n    Warning:\n        If the factory requires reinstantiating the store to correctly\n        resolve the object, the factory should reinstantiate the store\n        with the same arguments used to instantiate the store that\n        created the proxy/factory. I.e. the :func:`proxy()` function\n        should pass any arguments given to :func:`Store.__init__()`\n        along to the factory so the factory can correctly recreate the\n        store if the factory is resolved in a different Python process.\n    Args:\n        obj: The object to place in store and return proxy for.\n        serializer: Optional callable which serializes the\n            object. If `None`, the default serializer\n            ([`serialize()`][proxystore.serialize.serialize]) will be used.\n        deserializer: Optional callable used by the factory\n            to deserialize the byte string. If `None`, the default\n            deserializer\n            ([`deserialize()`][proxystore.serialize.deserialize]) will be\n            used.\n        kwargs: Additional arguments to pass to the Factory.\n    Returns:\n        A proxy of the object.\n    \"\"\"\nkey = self.set(obj, serializer=serializer)\nlogger.debug(\nf\"PROXY key='{key}' FROM {self.__class__.__name__}\"\nf\"(name='{self.name}')\",\n)\nfactory: StoreFactory[KeyT, T] = StoreFactory(\nkey,\nstore_type=type(self),\nstore_name=self.name,\nstore_kwargs=self.kwargs,\ndeserializer=deserializer,\n**kwargs,\n)\nreturn Proxy(factory)\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.proxy_batch","title":"proxy_batch","text":"<pre><code>proxy_batch(\nobjs: Sequence[T],\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any\n) -&gt; list[Proxy[T]]\n</code></pre> <p>Create proxies for batch of objects in the store.</p> <p>See <code>Store.proxy()</code> for more details.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[T]</code>)         \u2013 <p>The objects to place in store and return proxies for.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>additional arguments to pass to the Factory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Proxy[T]]</code>         \u2013 <p>A list of proxies of the objects.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def proxy_batch(\nself,\nobjs: Sequence[T],\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any,\n) -&gt; list[Proxy[T]]:\n\"\"\"Create proxies for batch of objects in the store.\n    See [`Store.proxy()`][proxystore.store.base.Store.proxy] for more\n    details.\n    Args:\n        objs: The objects to place in store and return proxies for.\n        serializer: Optional callable which serializes the\n            object. If `None`, the default serializer\n            ([`serialize()`][proxystore.serialize.serialize]) will be used.\n        deserializer: Optional callable used by the factory\n            to deserialize the byte string. If `None`, the default\n            deserializer\n            ([`deserialize()`][proxystore.serialize.deserialize]) will be\n            used.\n        kwargs: additional arguments to pass to the Factory.\n    Returns:\n        A list of proxies of the objects.\n    \"\"\"\nkeys = self.set_batch(objs, serializer=serializer)\nreturn [\nself.proxy_from_key(key, deserializer=deserializer, **kwargs)\nfor key in keys\n]\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.proxy_from_key","title":"proxy_from_key","text":"<pre><code>proxy_from_key(\nkey: KeyT,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any\n) -&gt; Proxy[T]\n</code></pre> <p>Create a proxy to an object already in the store.</p> Note <p>This method will not verify that the key is valid so an error will not be raised until the returned proxy is resolved.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>The key corresponding to an object already in the store that will be the target object of the returned proxy.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional arguments to pass to the Factory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Proxy[T]</code>         \u2013 <p>A proxy.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def proxy_from_key(\nself,\nkey: KeyT,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any,\n) -&gt; Proxy[T]:\n\"\"\"Create a proxy to an object already in the store.\n    Note:\n        This method will not verify that the key is valid so an error\n        will not be raised until the returned proxy is resolved.\n    Args:\n        key: The key corresponding to an object already in the store\n            that will be the target object of the returned proxy.\n        deserializer: Optional callable used by the factory\n            to deserialize the byte string. If `None`, the default\n            deserializer\n            ([`deserialize()`][proxystore.serialize.deserialize]) will be\n            used.\n        kwargs: Additional arguments to pass to the Factory.\n    Returns:\n        A proxy.\n    \"\"\"\nlogger.debug(\nf\"PROXY key='{key}' FROM {self.__class__.__name__}\"\nf\"(name='{self.name}')\",\n)\nfactory: StoreFactory[KeyT, T] = StoreFactory(\nkey,\nstore_type=type(self),\nstore_name=self.name,\nstore_kwargs=self.kwargs,\ndeserializer=deserializer,\n**kwargs,\n)\nreturn Proxy(factory)\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.locked_proxy","title":"locked_proxy","text":"<pre><code>locked_proxy(\nobj: T,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any\n) -&gt; ProxyLocker[T]\n</code></pre> <p>Create a proxy locker that will prevent resolution.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T</code>)         \u2013 <p>The object to place in store and create proxy of.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional arguments to pass to the Factory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ProxyLocker[T]</code>         \u2013 <p>A proxy wrapped in a <code>ProxyLocker</code>.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def locked_proxy(\nself,\nobj: T,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\n**kwargs: Any,\n) -&gt; ProxyLocker[T]:\n\"\"\"Create a proxy locker that will prevent resolution.\n    Args:\n        obj: The object to place in store and create proxy of.\n        serializer: Optional callable which serializes the\n            object. If `None`, the default serializer\n            ([`serialize()`][proxystore.serialize.serialize]) will be used.\n        deserializer: Optional callable used by the factory\n            to deserialize the byte string. If `None`, the default\n            deserializer\n            ([`deserialize()`][proxystore.serialize.deserialize]) will be\n            used.\n        kwargs: Additional arguments to pass to the Factory.\n    Returns:\n        A proxy wrapped in a [`ProxyLocker`][proxystore.proxy.ProxyLocker].\n    \"\"\"\nreturn ProxyLocker(\nself.proxy(\nobj,\nserializer=serializer,\ndeserializer=deserializer,\n**kwargs,\n),\n)\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.set","title":"set","text":"<pre><code>set(\nobj: Any, *, serializer: SerializerT | None = None\n) -&gt; KeyT\n</code></pre> <p>Set key-object pair in store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>The object to be placed in the store.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>KeyT</code>         \u2013 <p>A key that can be used to retrieve the object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If the output of <code>serializer</code> is not bytes.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def set(\nself,\nobj: Any,\n*,\nserializer: SerializerT | None = None,\n) -&gt; KeyT:\n\"\"\"Set key-object pair in store.\n    Args:\n        obj: The object to be placed in the store.\n        serializer: Optional callable which serializes the\n            object. If `None`, the default serializer\n            ([`serialize()`][proxystore.serialize.serialize]) will be used.\n    Returns:\n        A key that can be used to retrieve the object.\n    Raises:\n        TypeError: If the output of `serializer` is not bytes.\n    \"\"\"\nif serializer is not None:\nobj = serializer(obj)\nelse:\nobj = default_serializer(obj)\nif not isinstance(obj, bytes):\nraise TypeError('Serializer must produce bytes.')\nkey = self.create_key(obj)\nself.set_bytes(key, obj)\nlogger.debug(\nf\"SET key='{key}' IN {self.__class__.__name__}\"\nf\"(name='{self.name}')\",\n)\nreturn key\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.set_batch","title":"set_batch","text":"<pre><code>set_batch(\nobjs: Sequence[Any],\n*,\nserializer: SerializerT | None = None\n) -&gt; list[KeyT]\n</code></pre> <p>Set objects in store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[Any]</code>)         \u2013 <p>Iterable of objects to be placed in the store.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[KeyT]</code>         \u2013 <p>List of keys that can be used to retrieve the objects.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If the output of <code>serializer</code> is not bytes.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def set_batch(\nself,\nobjs: Sequence[Any],\n*,\nserializer: SerializerT | None = None,\n) -&gt; list[KeyT]:\n\"\"\"Set objects in store.\n    Args:\n        objs: Iterable of objects to be placed in the store.\n        serializer: Optional callable which serializes the\n            object. If `None`, the default serializer\n            ([`serialize()`][proxystore.serialize.serialize]) will be used.\n    Returns:\n        List of keys that can be used to retrieve the objects.\n    Raises:\n        TypeError: If the output of `serializer` is not bytes.\n    \"\"\"\nreturn [self.set(obj, serializer=serializer) for obj in objs]\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.set_bytes","title":"set_bytes  <code>abstractmethod</code>","text":"<pre><code>set_bytes(key: KeyT, data: bytes) -&gt; None\n</code></pre> <p>Set serialized object in remote store with key.</p> <p>Parameters:</p> <ul> <li> key             (<code>KeyT</code>)         \u2013 <p>The key corresponding to the object.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>The serialized object.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>@abstractmethod\ndef set_bytes(self, key: KeyT, data: bytes) -&gt; None:\n\"\"\"Set serialized object in remote store with key.\n    Args:\n        key: The key corresponding to the object.\n        data: The serialized object.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/store/base/#proxystore.store.base.Store.stats","title":"stats","text":"<pre><code>stats(\nkey_or_proxy: KeyT | Proxy[T],\n) -&gt; dict[str, TimeStats]\n</code></pre> <p>Get stats on the store.</p> <p>Parameters:</p> <ul> <li> key_or_proxy             (<code>KeyT | Proxy[T]</code>)         \u2013 <p>A key to get stats for or a proxy to extract the key from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, TimeStats]</code>         \u2013 <p>A dict with keys corresponding to method names and values which             are <code>TimeStats</code> instances             with the statistics for calls to the corresponding method with             the specified key.</p> </li> </ul> Example <pre><code>{\n\"get\": TimeStats(\ncalls=32,\navg_time_ms=0.0123,\nmin_time_ms=0.0012,\nmax_time_ms=0.1234,\n),\n\"set\": TimeStats(...),\n\"evict\": TimeStats(...),\n...\n}\n</code></pre> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>self</code> was initialized with <code>stats=False</code>.</p> </li> </ul> Source code in <code>proxystore/store/base.py</code> <pre><code>def stats(self, key_or_proxy: KeyT | Proxy[T]) -&gt; dict[str, TimeStats]:\n\"\"\"Get stats on the store.\n    Args:\n        key_or_proxy: A key to get stats for or a proxy to extract the key\n            from.\n    Returns:\n        A dict with keys corresponding to method names and values which \\\n        are [`TimeStats`][proxystore.store.stats.TimeStats] instances \\\n        with the statistics for calls to the corresponding method with \\\n        the specified key.\n    Example:\n        ```python\n        {\n            \"get\": TimeStats(\n                calls=32,\n                avg_time_ms=0.0123,\n                min_time_ms=0.0012,\n                max_time_ms=0.1234,\n            ),\n            \"set\": TimeStats(...),\n            \"evict\": TimeStats(...),\n            ...\n        }\n        ```\n    Raises:\n        ValueError: If `self` was initialized with `#!python stats=False`.\n    \"\"\"\nif self._stats is None:\nraise ValueError(\n'Stats are not being tracked because this store was '\n'initialized with stats=False.',\n)\nstats = {}\nif isinstance(key_or_proxy, ps.proxy.Proxy):\nkey = get_key(key_or_proxy)\n# Merge stats from the proxy into self\nif hasattr(key_or_proxy.__factory__, 'stats'):\nproxy_stats = key_or_proxy.__factory__.stats\nif proxy_stats is not None:\nfor event in proxy_stats:\nstats[event.function] = copy.copy(proxy_stats[event])\nelse:\nkey = key_or_proxy\nfor event in self._stats:\nif event.key == key:\nstats[event.function] = copy.copy(self._stats[event])\nreturn stats\n</code></pre>"},{"location":"reference/store/cache/","title":"proxystore.store.cache","text":"<p>Simple Cache Implementation.</p>"},{"location":"reference/store/cache/#proxystore.store.cache.LRUCache","title":"LRUCache","text":"<pre><code>LRUCache(maxsize: int = 16) -&gt; None\n</code></pre> <p>         Bases: <code>Generic[KeyT, ValueT]</code></p> <p>Simple LRU Cache.</p> <p>Parameters:</p> <ul> <li> maxsize             (<code>int</code>)         \u2013 <p>Maximum number of value to cache.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>maxsize &lt;= 0</code>.</p> </li> </ul> Source code in <code>proxystore/store/cache.py</code> <pre><code>def __init__(self, maxsize: int = 16) -&gt; None:\nif maxsize &lt; 0:\nraise ValueError('Cache size must by &gt;= 0')\nself.maxsize = maxsize\nself.data: dict[KeyT, ValueT] = {}\nself.lru: list[KeyT] = []\n# Count hits/misses\nself.hits = 0\nself.misses = 0\n</code></pre>"},{"location":"reference/store/cache/#proxystore.store.cache.LRUCache.evict","title":"evict","text":"<pre><code>evict(key: KeyT) -&gt; None\n</code></pre> <p>Evict key from cache.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def evict(self, key: KeyT) -&gt; None:\n\"\"\"Evict key from cache.\"\"\"\nif key in self.data:\ndel self.data[key]\nself.lru.remove(key)\n</code></pre>"},{"location":"reference/store/cache/#proxystore.store.cache.LRUCache.exists","title":"exists","text":"<pre><code>exists(key: KeyT) -&gt; bool\n</code></pre> <p>Check if key is in cache.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def exists(self, key: KeyT) -&gt; bool:\n\"\"\"Check if key is in cache.\"\"\"\nreturn key in self.data\n</code></pre>"},{"location":"reference/store/cache/#proxystore.store.cache.LRUCache.get","title":"get","text":"<pre><code>get(\nkey: KeyT, default: ValueT | None = None\n) -&gt; ValueT | None\n</code></pre> <p>Get value for key if it exists else returns default.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def get(self, key: KeyT, default: ValueT | None = None) -&gt; ValueT | None:\n\"\"\"Get value for key if it exists else returns default.\"\"\"\nif self.exists(key):\n# Move to front b/c most recently used\nself.hits += 1\nself.lru.remove(key)\nself.lru.insert(0, key)\nreturn self.data[key]\nelse:\nself.misses += 1\nreturn default\n</code></pre>"},{"location":"reference/store/cache/#proxystore.store.cache.LRUCache.set","title":"set","text":"<pre><code>set(key: KeyT, value: ValueT) -&gt; None\n</code></pre> <p>Set key to value.</p> Source code in <code>proxystore/store/cache.py</code> <pre><code>def set(self, key: KeyT, value: ValueT) -&gt; None:\n\"\"\"Set key to value.\"\"\"\nif self.maxsize == 0:\nreturn\nif len(self.data) &gt;= self.maxsize:\nlru_key = self.lru.pop()\ndel self.data[lru_key]\nself.lru.insert(0, key)\nself.data[key] = value\n</code></pre>"},{"location":"reference/store/endpoint/","title":"proxystore.store.endpoint","text":"<p>EndpointStore Implementation.</p>"},{"location":"reference/store/endpoint/#proxystore.store.endpoint.EndpointStoreError","title":"EndpointStoreError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception resulting from request to Endpoint.</p>"},{"location":"reference/store/endpoint/#proxystore.store.endpoint.EndpointStoreKey","title":"EndpointStoreKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to object in an Endpoint.</p>"},{"location":"reference/store/endpoint/#proxystore.store.endpoint.EndpointStoreKey.object_id","title":"object_id  <code>class-attribute</code>","text":"<pre><code>object_id: str\n</code></pre> <p>Unique object ID.</p>"},{"location":"reference/store/endpoint/#proxystore.store.endpoint.EndpointStoreKey.endpoint_id","title":"endpoint_id  <code>class-attribute</code>","text":"<pre><code>endpoint_id: str | None\n</code></pre> <p>Endpoint UUID where object is stored.</p>"},{"location":"reference/store/endpoint/#proxystore.store.endpoint.EndpointStore","title":"EndpointStore","text":"<pre><code>EndpointStore(\nname: str,\n*,\nendpoints: Sequence[str | UUID],\nproxystore_dir: str | None = None,\ncache_size: int = 16,\nstats: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[EndpointStoreKey]</code></p> <p>EndpointStore backend class.</p> Warning <p>Specifying a custom <code>proxystore_dir</code> can cause problems if the <code>proxystore_dir</code> is not the same on all systems that a proxy created by this store could end up on. It is recommended to leave the <code>proxystore_dir</code> unspecified so the correct default directory will be used.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance (default: None).</p> </li> <li> endpoints             (<code>Sequence[str | UUID]</code>)         \u2013 <p>Sequence of valid and running endpoint UUIDs to use. At least one of these endpoints must be accessible by this process.</p> </li> <li> proxystore_dir             (<code>str | None</code>)         \u2013 <p>Optionally specify the proxystore home directory. Defaults to [<code>home_dir()</code>[proxystore.utils.home_dir].</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Collect stats on store operations.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If endpoints is an empty list.</p> </li> <li> <code>EndpointStoreError</code>           \u2013         <p>If unable to connect to one of the endpoints provided.</p> </li> </ul> Source code in <code>proxystore/store/endpoint.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\nendpoints: Sequence[str | UUID],\nproxystore_dir: str | None = None,\ncache_size: int = 16,\nstats: bool = False,\n) -&gt; None:\nif len(endpoints) == 0:\nraise ValueError('At least one endpoint must be specified.')\nself.endpoints: list[UUID] = [\ne if isinstance(e, UUID) else UUID(e, version=4) for e in endpoints\n]\nself.proxystore_dir = (\nhome_dir() if proxystore_dir is None else proxystore_dir\n)\n# Find the first locally accessible endpoint to use as our\n# home endpoint\navailable_endpoints = get_configs(self.proxystore_dir)\nfound_endpoint: EndpointConfig | None = None\nfor endpoint in available_endpoints:\nif endpoint.uuid in self.endpoints:\nlogger.debug(f'attempting connection to {endpoint.uuid}')\nresponse = requests.get(\nf'http://{endpoint.host}:{endpoint.port}/endpoint',\n)\nif response.status_code == 200:\nuuid = response.json()['uuid']\nif str(endpoint.uuid) == uuid:\nlogger.debug(\nf'connection to {endpoint.uuid} successful, using '\n'as home endpoint',\n)\nfound_endpoint = endpoint\nbreak\nelse:\nlogger.debug(f'{endpoint.uuid} has different UUID')\nelse:\nlogger.debug(f'connection to {endpoint.uuid} unsuccessful')\nif found_endpoint is None:\nraise EndpointStoreError(\n'Failed to find endpoint configuration matching one of the '\n'provided endpoint UUIDs.',\n)\nself.endpoint_uuid = found_endpoint.uuid\nself.endpoint_host = found_endpoint.host\nself.endpoint_port = found_endpoint.port\nself.address = f'http://{self.endpoint_host}:{self.endpoint_port}'\nsuper().__init__(\nname,\ncache_size=cache_size,\nstats=stats,\nkwargs={\n'endpoints': self.endpoints,\n# Note: don't pass self.proxystore_dir here because it may\n# change depending on the system we are on (as a proxy could\n# reinitialize this store on a different system).\n'proxystore_dir': proxystore_dir,\n},\n)\n</code></pre>"},{"location":"reference/store/endpoint/#proxystore.store.endpoint.EndpointStore.evict","title":"evict","text":"<pre><code>evict(key: EndpointStoreKey) -&gt; None\n</code></pre> <p>Evict object associated with key.</p> <p>Parameters:</p> <ul> <li> key             (<code>EndpointStoreKey</code>)         \u2013 <p>Key corresponding to object in store to evict.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EndpointStoreError</code>           \u2013         <p>If the Endpoint returns a non-200 status code.</p> </li> </ul> Source code in <code>proxystore/store/endpoint.py</code> <pre><code>def evict(self, key: EndpointStoreKey) -&gt; None:\n\"\"\"Evict object associated with key.\n    Args:\n        key: Key corresponding to object in store to evict.\n    Raises:\n        EndpointStoreError: If the Endpoint returns a non-200 status code.\n    \"\"\"\nresponse = requests.post(\nf'{self.address}/evict',\nparams={'key': key.object_id, 'endpoint': key.endpoint_id},\n)\nif response.status_code != 200:\nraise EndpointStoreError(f'EVICT returned {response}')\nself._cache.evict(key)\nlogger.debug(\nf\"EVICT key='{key}' FROM {self.__class__.__name__}\"\nf\"(name='{self.name}')\",\n)\n</code></pre>"},{"location":"reference/store/endpoint/#proxystore.store.endpoint.EndpointStore.exists","title":"exists","text":"<pre><code>exists(key: EndpointStoreKey) -&gt; bool\n</code></pre> <p>Check if key exists.</p> <p>Parameters:</p> <ul> <li> key             (<code>EndpointStoreKey</code>)         \u2013 <p>Key to check.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EndpointStoreError</code>           \u2013         <p>If the Endpoint returns a non-200 status code.</p> </li> </ul> Source code in <code>proxystore/store/endpoint.py</code> <pre><code>def exists(self, key: EndpointStoreKey) -&gt; bool:\n\"\"\"Check if key exists.\n    Args:\n        key: Key to check.\n    Raises:\n        EndpointStoreError: If the Endpoint returns a non-200 status code.\n    \"\"\"\nresponse = requests.get(\nf'{self.address}/exists',\nparams={'key': key.object_id, 'endpoint': key.endpoint_id},\n)\nif response.status_code == 200:\nreturn response.json()['exists']\nelse:\nraise EndpointStoreError(f'EXISTS returned {response}')\n</code></pre>"},{"location":"reference/store/endpoint/#proxystore.store.endpoint.EndpointStore.get_bytes","title":"get_bytes","text":"<pre><code>get_bytes(key: EndpointStoreKey) -&gt; bytes | None\n</code></pre> <p>Get serialized object from remote store.</p> <p>Parameters:</p> <ul> <li> key             (<code>EndpointStoreKey</code>)         \u2013 <p>Key corresponding to object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013 <p>Serialized object or <code>None</code> if it does not exist on the endpoint.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EndpointStoreError</code>           \u2013         <p>If the Endpoint returns a status code other than 200 (success) or 400 (missing key).</p> </li> </ul> Source code in <code>proxystore/store/endpoint.py</code> <pre><code>def get_bytes(self, key: EndpointStoreKey) -&gt; bytes | None:\n\"\"\"Get serialized object from remote store.\n    Args:\n        key: Key corresponding to object.\n    Returns:\n        Serialized object or `None` if it does not exist on the endpoint.\n    Raises:\n        EndpointStoreError: If the Endpoint returns a status code other\n            than 200 (success) or 400 (missing key).\n    \"\"\"\nresponse = requests.get(\nf'{self.address}/get',\nparams={'key': key.object_id, 'endpoint': key.endpoint_id},\nstream=True,\n)\nif response.status_code == 200:\ndata = bytearray()\nfor chunk in response.iter_content(chunk_size=None):\ndata += chunk\nreturn bytes(data)\nelif response.status_code == 400:\nreturn None\nelse:\nraise EndpointStoreError(f'GET returned {response}')\n</code></pre>"},{"location":"reference/store/endpoint/#proxystore.store.endpoint.EndpointStore.set_bytes","title":"set_bytes","text":"<pre><code>set_bytes(key: EndpointStoreKey, data: bytes) -&gt; None\n</code></pre> <p>Set serialized object in remote store with key.</p> <p>Parameters:</p> <ul> <li> key             (<code>EndpointStoreKey</code>)         \u2013 <p>Key corresponding to object.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Serialized object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EndpointStoreError</code>           \u2013         <p>If the endpoint does not return a 200 status code for success.</p> </li> </ul> Source code in <code>proxystore/store/endpoint.py</code> <pre><code>def set_bytes(self, key: EndpointStoreKey, data: bytes) -&gt; None:\n\"\"\"Set serialized object in remote store with key.\n    Args:\n        key: Key corresponding to object.\n        data: Serialized object.\n    Raises:\n        EndpointStoreError: If the endpoint does not return a 200 status\n            code for success.\n    \"\"\"\nresponse = requests.post(\nf'{self.address}/set',\nheaders={'Content-Type': 'application/octet-stream'},\nparams={'key': key.object_id, 'endpoint': key.endpoint_id},\ndata=chunk_bytes(data, MAX_CHUNK_LENGTH),\nstream=True,\n)\nif response.status_code != 200:\nraise EndpointStoreError(f'SET returned {response}')\n</code></pre>"},{"location":"reference/store/exceptions/","title":"proxystore.store.exceptions","text":"<p>Exceptions for Stores.</p>"},{"location":"reference/store/exceptions/#proxystore.store.exceptions.StoreError","title":"StoreError","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception class for store errors.</p>"},{"location":"reference/store/exceptions/#proxystore.store.exceptions.StoreExistsError","title":"StoreExistsError","text":"<p>         Bases: <code>StoreError</code></p> <p>Exception raised when a store with the same name already exists.</p>"},{"location":"reference/store/exceptions/#proxystore.store.exceptions.ProxyStoreFactoryError","title":"ProxyStoreFactoryError","text":"<p>         Bases: <code>StoreError</code></p> <p>Exception raised when a proxy was not created by a Store.</p>"},{"location":"reference/store/exceptions/#proxystore.store.exceptions.ProxyResolveMissingKeyError","title":"ProxyResolveMissingKeyError","text":"<pre><code>ProxyResolveMissingKeyError(\nkey: NamedTuple,\nstore_type: type[base.Store[base.KeyT]],\nstore_name: str,\n) -&gt; None\n</code></pre> <p>         Bases: <code>Exception</code></p> <p>Exception raised when the key associated with a proxy is missing.</p> <p>Init ProxyResolveMissingKeyError.</p> <p>Parameters:</p> <ul> <li> key             (<code>NamedTuple</code>)         \u2013 <p>Key associated with target object that could not be found in the store.</p> </li> <li> store_type             (<code>type[base.Store[base.KeyT]]</code>)         \u2013 <p>Type of store that the key could not be found in.</p> </li> <li> store_name             (<code>str</code>)         \u2013 <p>Name of store that the key could not be found in.</p> </li> </ul> Source code in <code>proxystore/store/exceptions.py</code> <pre><code>def __init__(\nself,\nkey: NamedTuple,\nstore_type: type[base.Store[base.KeyT]],\nstore_name: str,\n) -&gt; None:\n\"\"\"Init ProxyResolveMissingKeyError.\n    Args:\n        key: Key associated with target object that could not be found in\n            the store.\n        store_type: Type of store that the key could not be found in.\n        store_name: Name of store that the key could not be found in.\n    \"\"\"\nself.key = key\nself.store_type = store_type\nself.store_name = store_name\nsuper().__init__(\nf\"Proxy cannot resolve target object with key='{self.key}' \"\nf\"from {self.store_type.__name__}(name='{self.store_name}'): \"\n'store returned NoneType with key.',\n)\n</code></pre>"},{"location":"reference/store/file/","title":"proxystore.store.file","text":"<p>FileStore Implementation.</p>"},{"location":"reference/store/file/#proxystore.store.file.FileStoreKey","title":"FileStoreKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in a FileStore.</p>"},{"location":"reference/store/file/#proxystore.store.file.FileStoreKey.filename","title":"filename  <code>class-attribute</code>","text":"<pre><code>filename: str\n</code></pre> <p>Unique object filename.</p>"},{"location":"reference/store/file/#proxystore.store.file.FileStore","title":"FileStore","text":"<pre><code>FileStore(\nname: str,\n*,\nstore_dir: str,\ncache_size: int = 16,\nstats: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[FileStoreKey]</code></p> <p>File backend class.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>name of the store instance.</p> </li> <li> store_dir             (<code>str</code>)         \u2013 <p>Path to directory to store data in. Note this directory will be deleted upon closing the store.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Collect stats on store operations.</p> </li> </ul> Source code in <code>proxystore/store/file.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\nstore_dir: str,\ncache_size: int = 16,\nstats: bool = False,\n) -&gt; None:\nself.store_dir = os.path.abspath(store_dir)\nif not os.path.exists(self.store_dir):\nos.makedirs(self.store_dir, exist_ok=True)\nsuper().__init__(\nname,\ncache_size=cache_size,\nstats=stats,\nkwargs={'store_dir': self.store_dir},\n)\n</code></pre>"},{"location":"reference/store/file/#proxystore.store.file.FileStore.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Cleanup all files associated with the file system store.</p> Warning <p>Will delete the <code>store_dir</code> directory.</p> Warning <p>This method should only be called at the end of the program when the store will no longer be used, for example once all proxies have been resolved.</p> Source code in <code>proxystore/store/file.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Cleanup all files associated with the file system store.\n    Warning:\n        Will delete the `store_dir` directory.\n    Warning:\n        This method should only be called at the end of the program\n        when the store will no longer be used, for example once all\n        proxies have been resolved.\n    \"\"\"\nshutil.rmtree(self.store_dir)\n</code></pre>"},{"location":"reference/store/globus/","title":"proxystore.store.globus","text":"<p>Globus Endpoint Implementation.</p>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusEndpoint","title":"GlobusEndpoint","text":"<pre><code>GlobusEndpoint(\nuuid: str,\nendpoint_path: str,\nlocal_path: str | None,\nhost_regex: str | Pattern[str],\n) -&gt; None\n</code></pre> <p>Globus endpoint representation.</p> <p>Parameters:</p> <ul> <li> uuid             (<code>str</code>)         \u2013 <p>UUID of Globus endpoint.</p> </li> <li> endpoint_path             (<code>str</code>)         \u2013 <p>Path within endpoint to directory to use for storing objects.</p> </li> <li> local_path             (<code>str | None</code>)         \u2013 <p>Local path (as seen by the host filesystem) that corresponds to the directory specified by <code>endpoint_path</code>.</p> </li> <li> host_regex             (<code>str | Pattern[str]</code>)         \u2013 <p>String that matches the host where the Globus endpoint exists or regex pattern than can be used to match the host. The host pattern is needed so that proxies can figure out what the local endpoint is when they are resolved.</p> </li> </ul> Source code in <code>proxystore/store/globus.py</code> <pre><code>def __init__(\nself,\nuuid: str,\nendpoint_path: str,\nlocal_path: str | None,\nhost_regex: str | Pattern[str],\n) -&gt; None:\nif not isinstance(uuid, str):\nraise TypeError('uuid must be a str.')\nif not isinstance(endpoint_path, str):\nraise TypeError('endpoint_path must be a str.')\nif not isinstance(local_path, str):\nraise TypeError('local_path must be a str.')\nif not (\nisinstance(host_regex, str) or isinstance(host_regex, Pattern)\n):\nraise TypeError('host_regex must be a str or re.Pattern.')\nself.uuid = uuid\nself.endpoint_path = endpoint_path\nself.local_path = local_path\nself.host_regex = host_regex\n</code></pre>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusEndpoints","title":"GlobusEndpoints","text":"<pre><code>GlobusEndpoints(\nendpoints: Collection[GlobusEndpoint],\n) -&gt; None\n</code></pre> <p>A collection of Globus endpoints.</p> <p>Parameters:</p> <ul> <li> endpoints             (<code>Collection[GlobusEndpoint]</code>)         \u2013 <p>Iterable of <code>GlobusEndpoints</code> instances.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>endpoints</code> has length 0 or if multiple endpoints with             the same UUID are provided.</p> </li> </ul> Source code in <code>proxystore/store/globus.py</code> <pre><code>def __init__(self, endpoints: Collection[GlobusEndpoint]) -&gt; None:\nif len(endpoints) == 0:\nraise ValueError(\n'GlobusEndpoints must be passed at least one GlobusEndpoint '\n'object',\n)\nself._endpoints: dict[str, GlobusEndpoint] = {}\nfor endpoint in endpoints:\nif endpoint.uuid in self._endpoints:\nraise ValueError(\n'Cannot pass multiple GlobusEndpoint objects with the '\n'same Globus endpoint UUID.',\n)\nself._endpoints[endpoint.uuid] = endpoint\n</code></pre>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusEndpoints.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(\njson_object: dict[str, dict[str, str]]\n) -&gt; GlobusEndpoints\n</code></pre> <p>Construct an endpoints collection from a dictionary.</p> Example <pre><code>{\n\"endpoint-uuid-1\": {\n\"host_regex\": \"host1-regex\",\n\"endpoint_path\": \"/path/to/endpoint/dir\",\n\"local_path\": \"/path/to/local/dir\"\n},\n\"endpoint-uuid-2\": {\n\"host_regex\": \"host2-regex\",\n\"endpoint_path\": \"/path/to/endpoint/dir\",\n\"local_path\": \"/path/to/local/dir\"\n}\n}\n</code></pre> Source code in <code>proxystore/store/globus.py</code> <pre><code>@classmethod\ndef from_dict(\ncls: type[GlobusEndpoints],\njson_object: dict[str, dict[str, str]],\n) -&gt; GlobusEndpoints:\n\"\"\"Construct an endpoints collection from a dictionary.\n    Example:\n        ```python\n        {\n          \"endpoint-uuid-1\": {\n            \"host_regex\": \"host1-regex\",\n            \"endpoint_path\": \"/path/to/endpoint/dir\",\n            \"local_path\": \"/path/to/local/dir\"\n          },\n          \"endpoint-uuid-2\": {\n            \"host_regex\": \"host2-regex\",\n            \"endpoint_path\": \"/path/to/endpoint/dir\",\n            \"local_path\": \"/path/to/local/dir\"\n          }\n        }\n        ```\n    \"\"\"  # noqa: D412\nendpoints = []\nfor uuid, params in json_object.items():\nendpoints.append(\nGlobusEndpoint(\nuuid=uuid,\nendpoint_path=params['endpoint_path'],\nlocal_path=params['local_path'],\nhost_regex=params['host_regex'],\n),\n)\nreturn GlobusEndpoints(endpoints)\n</code></pre>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusEndpoints.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_file: str) -&gt; GlobusEndpoints\n</code></pre> <p>Construct a GlobusEndpoints object from a json file.</p> <p>The <code>dict</code> read from the JSON file will be passed to <code>from_dict()</code> and should match the format expected by <code>from_dict()</code>.</p> Source code in <code>proxystore/store/globus.py</code> <pre><code>@classmethod\ndef from_json(cls, json_file: str) -&gt; GlobusEndpoints:\n\"\"\"Construct a GlobusEndpoints object from a json file.\n    The `dict` read from the JSON file will be passed to\n    [`from_dict()`][proxystore.store.globus.GlobusEndpoints.from_dict] and\n    should match the format expected by\n    [`from_dict()`][proxystore.store.globus.GlobusEndpoints.from_dict].\n    \"\"\"\nwith open(json_file) as f:\ndata = f.read()\nreturn cls.from_dict(json.loads(data))\n</code></pre>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusEndpoints.dict","title":"dict","text":"<pre><code>dict() -&gt; dict[str, dict[str, str]]\n</code></pre> <p>Convert the GlobusEndpoints to a dict.</p> <p>Note that the <code>GlobusEndpoints</code> object can be reconstructed by passing the <code>dict</code> to. <code>from_dict()</code>.</p> Source code in <code>proxystore/store/globus.py</code> <pre><code>def dict(self) -&gt; dict[str, dict[str, str]]:\n\"\"\"Convert the GlobusEndpoints to a dict.\n    Note that the\n    [`GlobusEndpoints`][proxystore.store.globus.GlobusEndpoints]\n    object can be reconstructed by passing the `dict` to.\n    [`from_dict()`][proxystore.store.globus.GlobusEndpoints.from_dict].\n    \"\"\"\ndata = {}\nfor endpoint in self:\ndata[endpoint.uuid] = {\n'endpoint_path': endpoint.endpoint_path,\n'local_path': endpoint.local_path,\n'host_regex': endpoint.host_regex.pattern\nif isinstance(endpoint.host_regex, Pattern)\nelse endpoint.host_regex,\n}\nreturn data\n</code></pre>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusEndpoints.get_by_host","title":"get_by_host","text":"<pre><code>get_by_host(host: str) -&gt; GlobusEndpoint\n</code></pre> <p>Get endpoint by host.</p> <p>Searches the endpoints for a endpoint who's <code>host_regex</code> matches <code>host</code>.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>Host to match.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GlobusEndpoint</code>         \u2013 <p>Globus endpoint.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>If <code>host</code> does not match any of the endpoints.</p> </li> </ul> Source code in <code>proxystore/store/globus.py</code> <pre><code>def get_by_host(self, host: str) -&gt; GlobusEndpoint:\n\"\"\"Get endpoint by host.\n    Searches the endpoints for a endpoint who's `host_regex` matches\n    `host`.\n    Args:\n        host: Host to match.\n    Returns:\n        Globus endpoint.\n    Raises:\n        ValueError: If `host` does not match any of the endpoints.\n    \"\"\"\nfor endpoint in self._endpoints.values():\nif re.fullmatch(endpoint.host_regex, host) is not None:\nreturn endpoint\nraise ValueError(f'Cannot find endpoint matching host {host}')\n</code></pre>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusStoreKey","title":"GlobusStoreKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to object in a GlobusStore.</p>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusStoreKey.filename","title":"filename  <code>class-attribute</code>","text":"<pre><code>filename: str\n</code></pre> <p>Unique object filename.</p>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusStoreKey.task_id","title":"task_id  <code>class-attribute</code>","text":"<pre><code>task_id: str\n</code></pre> <p>Globus transfer task ID for the file.</p>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusStoreKey.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; bool\n</code></pre> <p>Match keys by filename only.</p> <p>This is a hack around the fact that the task_id is not created until after the filename is so there can be a state where the task_id is empty.</p> Source code in <code>proxystore/store/globus.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Match keys by filename only.\n    This is a hack around the fact that the task_id is not created until\n    after the filename is so there can be a state where the task_id\n    is empty.\n    \"\"\"\nif isinstance(other, tuple):\nreturn self[0] == other[0]\nreturn False\n</code></pre>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusStore","title":"GlobusStore","text":"<pre><code>GlobusStore(\nname: str,\n*,\nendpoints: GlobusEndpoints\n| list[GlobusEndpoint]\n| dict[str, dict[str, str]],\npolling_interval: int = 1,\nsync_level: int\n| Literal[exists, size, mtime, checksum] = \"mtime\",\ntimeout: int = 60,\ncache_size: int = 16,\nstats: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[GlobusStoreKey]</code></p> <p>Globus backend class.</p> <p>The <code>GlobusStore</code> is similar to a <code>FileStore</code> in that objects in the store are saved to disk but allows for the transfer of objects between two remote file systems. The two directories on the separate file systems are kept in sync via Globus transfers. The <code>GlobusStore</code> is useful when moving data between hosts that have a Globus endpoint but may have restrictions that prevent the use of other store backends (e.g., ports cannot be opened for using a <code>RedisStore</code>.</p> Note <p>To use Globus for data transfer, Globus authentication needs to be performed otherwise an error will be raised. Authentication can be performed on the command line with <code>proxystore-globus-auth</code>. Authentication only needs to be performed once per system.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> endpoints             (<code>GlobusEndpoints | list[GlobusEndpoint] | dict[str, dict[str, str]]</code>)         \u2013 <p>Globus endpoints to keep in sync. If passed as a <code>dict</code>, the dictionary must match the format expected by <code>GlobusEndpoints.from_dict()</code>.</p> </li> <li> polling_interval             (<code>int</code>)         \u2013 <p>Interval in seconds to check if Globus tasks have finished.</p> </li> <li> sync_level             (<code>int | Literal[exists, size, mtime, checksum]</code>)         \u2013 <p>Globus transfer sync level.</p> </li> <li> timeout             (<code>int</code>)         \u2013 <p>Timeout in seconds for waiting on Globus tasks.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Collect stats on store operations.</p> </li> </ul> Raise <p>GlobusAuthFileError: If the Globus authentication file cannot be found. ValueError: If <code>endpoints</code> is of an incorrect type. ValueError: If the :code:<code>len(endpoints) != 2</code> because this     implementation can currently only keep two endpoints in sync.</p> Source code in <code>proxystore/store/globus.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\nendpoints: GlobusEndpoints\n| list[GlobusEndpoint]\n| dict[str, dict[str, str]],\npolling_interval: int = 1,\nsync_level: int\n| Literal['exists', 'size', 'mtime', 'checksum'] = 'mtime',\ntimeout: int = 60,\ncache_size: int = 16,\nstats: bool = False,\n) -&gt; None:\nif isinstance(endpoints, GlobusEndpoints):\nself.endpoints = endpoints\nelif isinstance(endpoints, list):\nself.endpoints = GlobusEndpoints(endpoints)\nelif isinstance(endpoints, dict):\nself.endpoints = GlobusEndpoints.from_dict(endpoints)\nelse:\nraise ValueError(\n'endpoints must be of type GlobusEndpoints or a list of '\nf'GlobusEndpoint. Got {type(endpoints)}.',\n)\nif len(endpoints) != 2:\nraise ValueError(\n'ProxyStore only supports two endpoints at a time',\n)\nself.polling_interval = polling_interval\nself.sync_level = sync_level\nself.timeout = timeout\ntry:\nauthorizer = get_proxystore_authorizer()\nexcept GlobusAuthFileError as e:\nraise GlobusAuthFileError(\n'Error loading Globus auth tokens. Complete the '\n'authentication process with the proxystore-globus-auth tool.',\n) from e\nself._transfer_client = globus_sdk.TransferClient(\nauthorizer=authorizer,\n)\nsuper().__init__(\nname,\ncache_size=cache_size,\nstats=stats,\nkwargs={\n# Pass endpoints as a dict to make kwargs JSON serializable\n'endpoints': self.endpoints.dict(),\n'polling_interval': self.polling_interval,\n'sync_level': self.sync_level,\n'timeout': self.timeout,\n},\n)\n</code></pre>"},{"location":"reference/store/globus/#proxystore.store.globus.GlobusStore.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Cleanup directories used by ProxyStore in the Globus endpoints.</p> Warning <p>Will delete the directory at <code>local_path</code> on each endpoint.</p> Warning <p>This method should only be called at the end of the program when the store will no longer be used, for example once all proxies have been resolved.</p> Source code in <code>proxystore/store/globus.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Cleanup directories used by ProxyStore in the Globus endpoints.\n    Warning:\n        Will delete the directory at `local_path` on each endpoint.\n    Warning:\n        This method should only be called at the end of the program when\n        the store will no longer be used, for example once all proxies\n        have been resolved.\n    \"\"\"\nfor endpoint in self.endpoints:\ndelete_task = globus_sdk.DeleteData(\nself._transfer_client,\nendpoint=endpoint.uuid,\nrecursive=True,\n)\ndelete_task['notify_on_succeeded'] = False\ndelete_task['notify_on_failed'] = False\ndelete_task['notify_on_inactive'] = False\ndelete_task.add_item(endpoint.endpoint_path)\ntdata = _submit_transfer_action(self._transfer_client, delete_task)\nself._wait_on_tasks(tdata['task_id'])\n</code></pre>"},{"location":"reference/store/local/","title":"proxystore.store.local","text":"<p>LocalStore Implementation.</p>"},{"location":"reference/store/local/#proxystore.store.local.LocalStoreKey","title":"LocalStoreKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in a LocalStore.</p>"},{"location":"reference/store/local/#proxystore.store.local.LocalStoreKey.id","title":"id  <code>class-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique object ID.</p>"},{"location":"reference/store/local/#proxystore.store.local.LocalStore","title":"LocalStore","text":"<pre><code>LocalStore(\nname: str,\n*,\nstore_dict: dict[LocalStoreKey, bytes] | None = None,\ncache_size: int = 16,\nstats: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[LocalStoreKey]</code></p> <p>Local Memory Key-Object Store.</p> Warning <p>:class:<code>LocalStore &lt;.LocalStore&gt;</code> should typically be used for testing proxystore locally as using proxy store within the same Python process is unnecessary.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of this store instance.</p> </li> <li> store_dict             (<code>dict[LocalStoreKey, bytes] | None</code>)         \u2013 <p>Dictionary to store data in. If not specified, a new empty dict will be generated.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Collect stats on store operations.</p> </li> </ul> Source code in <code>proxystore/store/local.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\nstore_dict: dict[LocalStoreKey, bytes] | None = None,\ncache_size: int = 16,\nstats: bool = False,\n) -&gt; None:\nself._store: dict[LocalStoreKey, bytes] = {}\nif store_dict is not None:\nself._store = store_dict\nsuper().__init__(\nname,\ncache_size=cache_size,\nstats=stats,\nkwargs={'store_dict': self._store},\n)\n</code></pre>"},{"location":"reference/store/multi/","title":"proxystore.store.multi","text":"<p>MultiStore Implementation.</p>"},{"location":"reference/store/multi/#proxystore.store.multi.PolicyDict","title":"PolicyDict","text":"<p>         Bases: <code>TypedDict</code></p> <p>JSON compatible representation of a <code>Policy</code>.</p>"},{"location":"reference/store/multi/#proxystore.store.multi.Policy","title":"Policy  <code>dataclass</code>","text":"<p>Policy that allows validating a set of constraints.</p>"},{"location":"reference/store/multi/#proxystore.store.multi.Policy.is_valid","title":"is_valid","text":"<pre><code>is_valid(\n*,\nsize: int | None = None,\nsubset_tags: Iterable[str] | None = None,\nsuperset_tags: Iterable[str] | None = None\n) -&gt; bool\n</code></pre> <p>Check if set of contstraints is valid for this policy.</p> Note <p>All arguments are optional keyword arguments that default to <code>None</code>. If left as the default, that constraint will not be checked against the policy.</p> <p>Parameters:</p> <ul> <li> size             (<code>int | None</code>)         \u2013 <p>Object size.</p> </li> <li> subset_tags             (<code>Iterable[str] | None</code>)         \u2013 <p>Set of tags that must be a subset of the Policy's <code>subset_tags</code> to be valid.</p> </li> <li> superset_tags             (<code>Iterable[str] | None</code>)         \u2013 <p>Set of tags that must be a superset of the Policy's <code>superset_tags</code> to be valid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the provided constraints are valid for the policy.</p> </li> </ul> Source code in <code>proxystore/store/multi.py</code> <pre><code>def is_valid(\nself,\n*,\nsize: int | None = None,\nsubset_tags: Iterable[str] | None = None,\nsuperset_tags: Iterable[str] | None = None,\n) -&gt; bool:\n\"\"\"Check if set of contstraints is valid for this policy.\n    Note:\n        All arguments are optional keyword arguments that default to\n        `None`. If left as the default, that constraint will not be\n        checked against the policy.\n    Args:\n        size: Object size.\n        subset_tags: Set of tags that must be a subset\n            of the Policy's `subset_tags` to be valid.\n        superset_tags: Set of tags that must be a superset\n            of the Policy's `superset_tags` to be valid.\n    Returns:\n        If the provided constraints are valid for the policy.\n    \"\"\"\nif size is not None and (size &lt; self.min_size or size &gt; self.max_size):\nreturn False\nif subset_tags is not None and not set(subset_tags).issubset(\nself.subset_tags,\n):\nreturn False\nif superset_tags is not None and not set(superset_tags).issuperset(\nself.superset_tags,\n):\nreturn False\nreturn True\n</code></pre>"},{"location":"reference/store/multi/#proxystore.store.multi.Policy.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; PolicyDict\n</code></pre> <p>Convert the Policy to a JSON compatible dict.</p> Usage <p>policy = Policy(...) policy_dict = policy.as_dict() Policy(**policy_dict) == policy True</p> Source code in <code>proxystore/store/multi.py</code> <pre><code>def as_dict(self) -&gt; PolicyDict:\n\"\"\"Convert the Policy to a JSON compatible dict.\n    Usage:\n        &gt;&gt;&gt; policy = Policy(...)\n        &gt;&gt;&gt; policy_dict = policy.as_dict()\n        &gt;&gt;&gt; Policy(**policy_dict) == policy\n        True\n    \"\"\"\n# We could use dataclasses.asdict(self) but this gives us the benefit\n# of typing on the return dict.\nreturn PolicyDict(\npriority=self.priority,\nmin_size=self.min_size,\nmax_size=self.max_size,\nsubset_tags=self.subset_tags,\nsuperset_tags=self.superset_tags,\n)\n</code></pre>"},{"location":"reference/store/multi/#proxystore.store.multi.MultiStoreKey","title":"MultiStoreKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in a MultiStore.</p>"},{"location":"reference/store/multi/#proxystore.store.multi.MultiStore","title":"MultiStore","text":"<pre><code>MultiStore(\nname: str,\n*,\nstores: dict[str, Policy]\n| dict[Store[Any], Policy]\n| Sequence[_StorePolicyArgs],\ncache_size: int = 0,\nstats: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[MultiStoreKey]</code></p> <p>Policy based manager for a collection of <code>Store</code>.</p> Note <p>This store does not implement <code>get_bytes()</code> or <code>set_bytes()</code> because <code>MultiStore.get()</code> and <code>MultiStore.set()</code> forward operations to the corresponding store.</p> Warning <p><code>MultiStore.close()</code> will call <code>Store.close()</code> on all the stores managed by the instance and unregister them.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of this store instance.</p> </li> <li> stores             (<code>dict[str, Policy] | dict[Store[Any], Policy] | Sequence[_StorePolicyArgs]</code>)         \u2013 <p>Mapping of stores (either <code>Store</code> instances or string names of registered stores) to the corresponding <code>Policy</code>. If <code>Store</code> instances are passed, the instances will be registered.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>collect stats on store operations.</p> </li> </ul> Source code in <code>proxystore/store/multi.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\nstores: dict[str, Policy]\n| dict[Store[Any], Policy]\n| Sequence[_StorePolicyArgs],\ncache_size: int = 0,\nstats: bool = False,\n) -&gt; None:\n# Cache and stats are controlled by the wrapped Stores.\nsuper().__init__(\nname,\ncache_size=0,\nstats=False,\n# We override the kwargs property so no need to pass here\nkwargs={},\n)\nself._stores: dict[str, _StorePolicy] = {}\nif isinstance(stores, dict):\nfor store, policy in stores.items():\nif isinstance(store, str):\npossible_store = get_store(store)\nif possible_store is None:\nraise RuntimeError(\nf'A store named \"{store}\" is not registered.',\n)\nactual_store = possible_store\nelse:\nactual_store = store\nself._stores[actual_store.name] = _StorePolicy(\nstore=actual_store,\npolicy=policy,\n)\nelif isinstance(stores, Sequence):\nfor store_args in stores:\npossible_store = get_store(store_args['name'])\nif possible_store is None:\nactual_store = store_args['kind'](\nstore_args['name'],\n**store_args['kwargs'],\n)\nelse:\nactual_store = possible_store\npolicy = store_args['policy']\nself._stores[actual_store.name] = _StorePolicy(\nstore=actual_store,\npolicy=policy,\n)\nelse:\nraise AssertionError('Unreachable.')\n# Register so multiple instances of `MultiStore` in a process\n# use the same underlying stores for caching/efficiency.\nfor store, _ in self._stores.values():\nregister_store(store, exist_ok=True)\nself._stores_by_priority = sorted(\nself._stores,\nkey=lambda name: self._stores[name].policy.priority,\nreverse=True,\n)\n</code></pre>"},{"location":"reference/store/multi/#proxystore.store.multi.MultiStore.proxy","title":"proxy","text":"<pre><code>proxy(\nobj: T,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n**kwargs: Any\n) -&gt; Proxy[T]\n</code></pre> <p>Create a proxy that will resolve to an object in the store.</p> Warning <p>If the factory requires reinstantiating the store to correctly resolve the object, the factory should reinstantiate the store with the same arguments used to instantiate the store that created the proxy/factory. I.e. the <code>proxy()</code> method should pass any arguments given to <code>Store</code> along to the factory so the factory can correctly recreate the store if the factory is resolved in a different Python process.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T</code>)         \u2013 <p>Object to place in store and return proxy for.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> subset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a subset of a store policy's <code>subset_tags</code> to match that store.</p> </li> <li> superset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a superset of a store policy's <code>superset_tags</code> to match that store.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional arguments to pass to the factory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Proxy[T]</code>         \u2013 <p>A proxy of the object.</p> </li> </ul> Source code in <code>proxystore/store/multi.py</code> <pre><code>def proxy(\nself,\nobj: T,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n**kwargs: Any,\n) -&gt; Proxy[T]:\n\"\"\"Create a proxy that will resolve to an object in the store.\n    Warning:\n        If the factory requires reinstantiating the store to correctly\n        resolve the object, the factory should reinstantiate the store\n        with the same arguments used to instantiate the store that\n        created the proxy/factory. I.e. the\n        [`proxy()`][proxystore.store.multi.MultiStore.proxy] method\n        should pass any arguments given to\n        [`Store`][proxystore.store.base.Store]\n        along to the factory so the factory can correctly recreate the\n        store if the factory is resolved in a different Python process.\n    Args:\n        obj: Object to place in store and return proxy for.\n        serializer: optional callable which serializes the\n            object. If `None`, the default serializer\n            ([`serialize()`][proxystore.serialize.serialize]) will be used.\n        deserializer: Optional callable used by the factory\n            to deserialize the byte string. If `None`, the default\n            deserializer ([`deserialize()`][proxystore.serialize.deserialize])\n            will be used.\n        subset_tags: Iterable of tags that must be a subset\n            of a store policy's `subset_tags` to match that store.\n        superset_tags: Iterable of tags that must be a\n            superset of a store policy's `superset_tags` to match that\n            store.\n        kwargs: Additional arguments to pass to the factory.\n    Returns:\n        A proxy of the object.\n    \"\"\"\nkey = self.set(\nobj,\nserializer=serializer,\nsubset_tags=subset_tags,\nsuperset_tags=superset_tags,\n)\nreturn self.proxy_from_key(key, deserializer=deserializer, **kwargs)\n</code></pre>"},{"location":"reference/store/multi/#proxystore.store.multi.MultiStore.proxy_batch","title":"proxy_batch","text":"<pre><code>proxy_batch(\nobjs: Sequence[T],\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n**kwargs: Any\n) -&gt; list[Proxy[T]]\n</code></pre> <p>Create proxies for batch of objects in the store.</p> <p>See <code>Store.proxy()</code> for more details.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[object]</code>)         \u2013 <p>Objects to place in store and return proxies for.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> subset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a subset of a store policy's <code>subset_tags</code> to match that store.</p> </li> <li> superset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a superset of a store policy's <code>superset_tags</code> to match that store.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional arguments to pass to the Factory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Proxy[T]]</code>         \u2013 <p>A list of proxies of the objects.</p> </li> </ul> Source code in <code>proxystore/store/multi.py</code> <pre><code>def proxy_batch(\nself,\nobjs: Sequence[T],\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n**kwargs: Any,\n) -&gt; list[Proxy[T]]:\n\"\"\"Create proxies for batch of objects in the store.\n    See [`Store.proxy()`][proxystore.store.base.Store.proxy] for more\n    details.\n    Args:\n        objs (Sequence[object]): Objects to place in store and return\n            proxies for.\n        serializer: Optional callable which serializes the\n            object. If `None`, the default serializer\n            ([`serialize()`][proxystore.serialize.serialize]) will be used.\n        deserializer: Optional callable used by the factory\n            to deserialize the byte string. If `None`, the default\n            deserializer\n            ([`deserialize()`][proxystore.serialize.deserialize]) will be\n            used.\n        subset_tags: Iterable of tags that must be a subset\n            of a store policy's `subset_tags` to match that store.\n        superset_tags: Iterable of tags that must be a\n            superset of a store policy's `superset_tags` to match that\n            store.\n        kwargs: Additional arguments to pass to the Factory.\n    Returns:\n        A list of proxies of the objects.\n    \"\"\"\nkeys = self.set_batch(\nobjs,\nserializer=serializer,\nsubset_tags=subset_tags,\nsuperset_tags=superset_tags,\n)\nreturn [\nself.proxy_from_key(key, deserializer=deserializer, **kwargs)\nfor key in keys\n]\n</code></pre>"},{"location":"reference/store/multi/#proxystore.store.multi.MultiStore.locked_proxy","title":"locked_proxy","text":"<pre><code>locked_proxy(\nobj: T,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n**kwargs: Any\n) -&gt; ProxyLocker[T]\n</code></pre> <p>Create a proxy locker that will prevent resolution.</p> <p>Parameters:</p> <ul> <li> obj             (<code>T</code>)         \u2013 <p>Object to place in store and create proxy of.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> deserializer             (<code>DeserializerT | None</code>)         \u2013 <p>Optional callable used by the factory to deserialize the byte string. If <code>None</code>, the default deserializer (<code>deserialize()</code>) will be used.</p> </li> <li> subset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a subset of a store policy's <code>subset_tags</code> to match that store.</p> </li> <li> superset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a superset of a store policy's <code>superset_tags</code> to match that store.</p> </li> <li> kwargs             (<code>Any</code>)         \u2013 <p>Additional arguments to pass to the Factory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ProxyLocker[T]</code>         \u2013 <p>A proxy wrapped in a <code>ProxyLocker</code>.</p> </li> </ul> Source code in <code>proxystore/store/multi.py</code> <pre><code>def locked_proxy(\nself,\nobj: T,\nserializer: SerializerT | None = None,\ndeserializer: DeserializerT | None = None,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n**kwargs: Any,\n) -&gt; ProxyLocker[T]:\n\"\"\"Create a proxy locker that will prevent resolution.\n    Args:\n        obj: Object to place in store and create proxy of.\n        serializer: Optional callable which serializes the\n            object. If `None`, the default serializer\n            ([`serialize()`][proxystore.serialize.serialize]) will be used.\n        deserializer: Optional callable used by the factory\n            to deserialize the byte string. If `None`, the default\n            deserializer\n            ([`deserialize()`][proxystore.serialize.deserialize]) will be\n            used.\n        subset_tags: Iterable of tags that must be a subset\n            of a store policy's `subset_tags` to match that store.\n        superset_tags: Iterable of tags that must be a\n            superset of a store policy's `superset_tags` to match that\n            store.\n        kwargs: Additional arguments to pass to the Factory.\n    Returns:\n        A proxy wrapped in a [`ProxyLocker`][proxystore.proxy.ProxyLocker].\n    \"\"\"\nreturn ProxyLocker(\nself.proxy(\nobj,\nserializer=serializer,\ndeserializer=deserializer,\nsubset_tags=subset_tags,\nsuperset_tags=superset_tags,\n**kwargs,\n),\n)\n</code></pre>"},{"location":"reference/store/multi/#proxystore.store.multi.MultiStore.set","title":"set","text":"<pre><code>set(\nobj: Any,\n*,\nserializer: SerializerT | None = None,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = ()\n) -&gt; MultiStoreKey\n</code></pre> <p>Set key-object pair in store.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>Object to be placed in the store.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> subset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a subset of a store policy's <code>subset_tags</code> to match that store.</p> </li> <li> superset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a superset of a store policy's <code>superset_tags</code> to match that store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MultiStoreKey</code>         \u2013 <p>A key that can be used to retrieve the object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If the output of <code>serializer</code> is not bytes.</p> </li> </ul> Source code in <code>proxystore/store/multi.py</code> <pre><code>def set(\nself,\nobj: Any,\n*,\nserializer: SerializerT | None = None,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n) -&gt; MultiStoreKey:\n\"\"\"Set key-object pair in store.\n    Args:\n        obj: Object to be placed in the store.\n        serializer: Optional callable which serializes the\n            object. If `None`, the default serializer\n            ([`serialize()`][proxystore.serialize.serialize]) will be used.\n        subset_tags: Iterable of tags that must be a subset\n            of a store policy's `subset_tags` to match that store.\n        superset_tags: Iterable of tags that must be a\n            superset of a store policy's `superset_tags` to match that\n            store.\n    Returns:\n        A key that can be used to retrieve the object.\n    Raises:\n        TypeError: If the output of `serializer` is not bytes.\n    \"\"\"\nif serializer is not None:\nobj = serializer(obj)\nelse:\nobj = default_serializer(obj)\nif not isinstance(obj, bytes):\nraise TypeError('Serializer must produce bytes.')\nfor store_name in self._stores_by_priority:\nstore, policy = self._stores[store_name]\nif policy.is_valid(\nsize=len(obj),\nsubset_tags=subset_tags,\nsuperset_tags=superset_tags,\n):\n# We already serialized object so pass identity\n# function to avoid duplicate serialization\nkey = store.set(obj, serializer=_identity)\nreturn MultiStoreKey(\nstore_name=store.name,\nstore_key=key,\n)\nelse:\nraise ValueError(\n'No store policy was suitable for the constraints: '\nf'subset_tags={subset_tags}, superset_tags={superset_tags}.',\n)\n</code></pre>"},{"location":"reference/store/multi/#proxystore.store.multi.MultiStore.set_batch","title":"set_batch","text":"<pre><code>set_batch(\nobjs: Sequence[Any],\n*,\nserializer: SerializerT | None = None,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = ()\n) -&gt; list[MultiStoreKey]\n</code></pre> <p>Set objects in store.</p> <p>Parameters:</p> <ul> <li> objs             (<code>Sequence[Any]</code>)         \u2013 <p>An iterable of objects to be placed in the store.</p> </li> <li> serializer             (<code>SerializerT | None</code>)         \u2013 <p>Optional callable which serializes the object. If <code>None</code>, the default serializer (<code>serialize()</code>) will be used.</p> </li> <li> subset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a subset of a store policy's <code>subset_tags</code> to match that store.</p> </li> <li> superset_tags             (<code>Iterable[str]</code>)         \u2013 <p>Iterable of tags that must be a superset of a store policy's <code>superset_tags</code> to match that store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[MultiStoreKey]</code>         \u2013 <p>List of keys that can be used to retrieve the objects.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>If the output of <code>serializer</code> is not bytes.</p> </li> </ul> Source code in <code>proxystore/store/multi.py</code> <pre><code>def set_batch(\nself,\nobjs: Sequence[Any],\n*,\nserializer: SerializerT | None = None,\nsubset_tags: Iterable[str] = (),\nsuperset_tags: Iterable[str] = (),\n) -&gt; list[MultiStoreKey]:\n\"\"\"Set objects in store.\n    Args:\n        objs: An iterable of objects to be placed in the store.\n        serializer: Optional callable which serializes the\n            object. If `None`, the default serializer\n            ([`serialize()`][proxystore.serialize.serialize]) will be used.\n        subset_tags: Iterable of tags that must be a subset\n            of a store policy's `subset_tags` to match that store.\n        superset_tags: Iterable of tags that must be a\n            superset of a store policy's `superset_tags` to match that\n            store.\n    Returns:\n        List of keys that can be used to retrieve the objects.\n    Raises:\n        TypeError: If the output of `serializer` is not bytes.\n    \"\"\"\nreturn [\nself.set(\nobj,\nserializer=serializer,\nsubset_tags=subset_tags,\nsuperset_tags=superset_tags,\n)\nfor obj in objs\n]\n</code></pre>"},{"location":"reference/store/redis/","title":"proxystore.store.redis","text":"<p>RedisStore Implementation.</p>"},{"location":"reference/store/redis/#proxystore.store.redis.RedisStoreKey","title":"RedisStoreKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in a RedisStore.</p>"},{"location":"reference/store/redis/#proxystore.store.redis.RedisStoreKey.redis_key","title":"redis_key  <code>class-attribute</code>","text":"<pre><code>redis_key: str\n</code></pre> <p>Unique object ID.</p>"},{"location":"reference/store/redis/#proxystore.store.redis.RedisStore","title":"RedisStore","text":"<pre><code>RedisStore(\nname: str,\n*,\nhostname: str,\nport: int,\ncache_size: int = 16,\nstats: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[RedisStoreKey]</code></p> <p>Redis backend class.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> hostname             (<code>str</code>)         \u2013 <p>Redis server hostname.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Redis server port.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Collect stats on store operations.</p> </li> </ul> Source code in <code>proxystore/store/redis.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\nhostname: str,\nport: int,\ncache_size: int = 16,\nstats: bool = False,\n) -&gt; None:\nself.hostname = hostname\nself.port = port\nself._redis_client = redis.StrictRedis(host=hostname, port=port)\nsuper().__init__(\nname,\ncache_size=cache_size,\nstats=stats,\nkwargs={'hostname': self.hostname, 'port': self.port},\n)\n</code></pre>"},{"location":"reference/store/stats/","title":"proxystore.store.stats","text":"<p>Utilities for Tracking Stats on Store Operations.</p>"},{"location":"reference/store/stats/#proxystore.store.stats.Event","title":"Event","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Event corresponding to a function called with a specific key.</p>"},{"location":"reference/store/stats/#proxystore.store.stats.TimeStats","title":"TimeStats  <code>dataclass</code>","text":"<p>Helper class for tracking time stats of an operation.</p>"},{"location":"reference/store/stats/#proxystore.store.stats.TimeStats.add_time","title":"add_time","text":"<pre><code>add_time(\ntime_ms: float, size_bytes: int | None = None\n) -&gt; None\n</code></pre> <p>Add a new time to the stats.</p> <p>Parameters:</p> <ul> <li> time_ms             (<code>float</code>)         \u2013 <p>Time (milliseconds) of a method execution.</p> </li> <li> size_bytes             (<code>int | None</code>)         \u2013 <p>Optionally note the data size associated with the operation that produced these statistics.</p> </li> </ul> Source code in <code>proxystore/store/stats.py</code> <pre><code>def add_time(self, time_ms: float, size_bytes: int | None = None) -&gt; None:\n\"\"\"Add a new time to the stats.\n    Args:\n        time_ms: Time (milliseconds) of a method execution.\n        size_bytes: Optionally note the data size associated with\n            the operation that produced these statistics.\n    \"\"\"\nself.avg_time_ms = self._weighted_avg(\nself.avg_time_ms,\nself.calls,\ntime_ms,\n1,\n)\nself.min_time_ms = min(time_ms, self.min_time_ms)\nself.max_time_ms = max(time_ms, self.max_time_ms)\nself.calls += 1\nself.size_bytes = size_bytes\n</code></pre>"},{"location":"reference/store/stats/#proxystore.store.stats.FunctionEventStats","title":"FunctionEventStats","text":"<pre><code>FunctionEventStats() -&gt; None\n</code></pre> <p>         Bases: <code>MutableMapping</code></p> <p>Class for tracking stats of calls of functions that take a key.</p> Source code in <code>proxystore/store/stats.py</code> <pre><code>def __init__(self) -&gt; None:\nself._events: dict[Event, TimeStats] = {}\n</code></pre>"},{"location":"reference/store/stats/#proxystore.store.stats.FunctionEventStats.keys","title":"keys","text":"<pre><code>keys() -&gt; KeysView[Event]\n</code></pre> <p>Return list of events being tracked.</p> Source code in <code>proxystore/store/stats.py</code> <pre><code>def keys(self) -&gt; KeysView[Event]:\n\"\"\"Return list of events being tracked.\"\"\"\nreturn self._events.keys()\n</code></pre>"},{"location":"reference/store/stats/#proxystore.store.stats.FunctionEventStats.wrap","title":"wrap","text":"<pre><code>wrap(\nfunction: GenericCallable,\n*,\nkey_is_result: bool = False,\npreset_key: NamedTuple | None = None\n) -&gt; GenericCallable\n</code></pre> <p>Wrap a method to log stats on calls to the function.</p> <p>Parameters:</p> <ul> <li> function             (<code>GenericCallable</code>)         \u2013 <p>Function to wrap.</p> </li> <li> key_is_result             (<code>bool</code>)         \u2013 <p>If <code>True</code>, the key is the return value of <code>function</code> rather than the first argument.</p> </li> <li> preset_key             (<code>NamedTuple | None</code>)         \u2013 <p>Optionally preset the key associated with any calls to <code>function</code>. This overrides <code>key_is_returned</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GenericCallable</code>         \u2013 <p>Callable with same interface as <code>function</code>.</p> </li> </ul> Source code in <code>proxystore/store/stats.py</code> <pre><code>def wrap(\nself,\nfunction: GenericCallable,\n*,\nkey_is_result: bool = False,\npreset_key: NamedTuple | None = None,\n) -&gt; GenericCallable:\n\"\"\"Wrap a method to log stats on calls to the function.\n    Args:\n        function: Function to wrap.\n        key_is_result: If `True`, the key is the return value of\n            `function` rather than the first argument.\n        preset_key: Optionally preset the key associated with any calls to\n            `function`. This overrides `key_is_returned`.\n    Returns:\n        Callable with same interface as `function`.\n    \"\"\"\nout_fun = partial(self._function, function, key_is_result, preset_key)\nreturn cast(GenericCallable, out_fun)\n</code></pre>"},{"location":"reference/store/utils/","title":"proxystore.store.utils","text":"<p>Store utilities.</p>"},{"location":"reference/store/utils/#proxystore.store.utils.get_key","title":"get_key","text":"<pre><code>get_key(proxy: Proxy[T]) -&gt; NamedTuple\n</code></pre> <p>Extract the key from the proxy's factory.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>Proxy[T]</code>)         \u2013 <p>Proxy instance to get key from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NamedTuple</code>         \u2013 <p>The key, a NamedTuple unique to the</p> </li> <li> <code>NamedTuple</code>         \u2013 <p><code>Store</code> that created the proxy..</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ProxyStoreFactoryError</code>           \u2013         <p>If the proxy's factory is not an instance of <code>StoreFactory</code>.</p> </li> </ul> Source code in <code>proxystore/store/utils.py</code> <pre><code>def get_key(proxy: Proxy[T]) -&gt; NamedTuple:\n\"\"\"Extract the key from the proxy's factory.\n    Args:\n        proxy: Proxy instance to get key from.\n    Returns:\n        The key, a NamedTuple unique to the\n        [`Store`][proxystore.store.base.Store] that created the proxy..\n    Raises:\n        ProxyStoreFactoryError: If the proxy's factory is not an instance of\n            [`StoreFactory`][proxystore.store.base.StoreFactory].\n    \"\"\"\nfactory = proxy.__factory__\nif isinstance(factory, base.StoreFactory):\nreturn factory.key\nelse:\nraise ProxyStoreFactoryError(\n'The proxy must contain a factory with type '\nf'{type(base.StoreFactory).__name__}. {type(factory).__name__} '\n'is not supported.',\n)\n</code></pre>"},{"location":"reference/store/utils/#proxystore.store.utils.resolve_async","title":"resolve_async","text":"<pre><code>resolve_async(proxy: Proxy[T]) -&gt; None\n</code></pre> <p>Begin resolving proxy asynchronously.</p> <p>Useful if the user knows a proxy will be needed soon and wants to resolve the proxy concurrently with other computation.</p> <pre><code>from proxystore.store.utils import resolve_async\nresolve_async(my_proxy)\ncomputation_without_proxy(...)\n# p is hopefully resolved\ncomputation_with_proxy(my_proxy, ...)\n</code></pre> Note <p>The asynchronous resolving functionality is implemented by <code>StoreFactory</code>. Factories that are not of this type will error when used with this function.</p> <p>Parameters:</p> <ul> <li> proxy             (<code>Proxy[T]</code>)         \u2013 <p>Proxy instance to begin asynchronously resolving.</p> </li> </ul> Source code in <code>proxystore/store/utils.py</code> <pre><code>def resolve_async(proxy: Proxy[T]) -&gt; None:\n\"\"\"Begin resolving proxy asynchronously.\n    Useful if the user knows a proxy will be needed soon and wants to\n    resolve the proxy concurrently with other computation.\n    ```python\n    from proxystore.store.utils import resolve_async\n    resolve_async(my_proxy)\n    computation_without_proxy(...)\n    # p is hopefully resolved\n    computation_with_proxy(my_proxy, ...)\n    ```\n    Note:\n        The asynchronous resolving functionality is implemented\n        by [`StoreFactory`][proxystore.store.base.StoreFactory]. Factories that\n        are not of this type will error when used with this function.\n    Args:\n        proxy: Proxy instance to begin asynchronously resolving.\n    \"\"\"\nif not is_resolved(proxy):\nproxy.__factory__.resolve_async()\n</code></pre>"},{"location":"reference/store/dim/","title":"proxystore.store.dim","text":"<p>Distributed in-memory stores.</p>"},{"location":"reference/store/dim/margo/","title":"proxystore.store.dim.margo","text":"<p>MargoStore implementation.</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.Protocol","title":"Protocol","text":"<p>         Bases: <code>Enum</code></p> <p>Available Mercury plugins and transports.</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.Protocol.OFI_TCP","title":"OFI_TCP  <code>class-attribute</code>","text":"<pre><code>OFI_TCP = 'ofi+tcp'\n</code></pre> <p>libfabric tcp provider (TCP/IP)</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.Protocol.OFI_VERBS","title":"OFI_VERBS  <code>class-attribute</code>","text":"<pre><code>OFI_VERBS = 'ofi+verbs'\n</code></pre> <p>libfabric Verbs provider (InfiniBand or RoCE)</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.Protocol.OFI_GNI","title":"OFI_GNI  <code>class-attribute</code>","text":"<pre><code>OFI_GNI = 'ofi+gni'\n</code></pre> <p>libfabric GNI provider (Cray Aries)</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.Protocol.UCX_TCP","title":"UCX_TCP  <code>class-attribute</code>","text":"<pre><code>UCX_TCP = 'ucx+tcp'\n</code></pre> <p>UCX TCP/IP</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.Protocol.UCX_VERBS","title":"UCX_VERBS  <code>class-attribute</code>","text":"<pre><code>UCX_VERBS = 'ucx+verbs'\n</code></pre> <p>UCX Verbs</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.Protocol.SM_SHM","title":"SM_SHM  <code>class-attribute</code>","text":"<pre><code>SM_SHM = 'sm+shm'\n</code></pre> <p>Shared memory shm</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.Protocol.BMI_TCP","title":"BMI_TCP  <code>class-attribute</code>","text":"<pre><code>BMI_TCP = 'bmi+tcp'\n</code></pre> <p>BMI tcp module (TCP/IP)</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoStoreKey","title":"MargoStoreKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in a MargoStore.</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoStoreKey.margo_key","title":"margo_key  <code>class-attribute</code>","text":"<pre><code>margo_key: str\n</code></pre> <p>Unique object key.</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoStoreKey.obj_size","title":"obj_size  <code>class-attribute</code>","text":"<pre><code>obj_size: int\n</code></pre> <p>Object size in bytes.</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoStoreKey.peer","title":"peer  <code>class-attribute</code>","text":"<pre><code>peer: str\n</code></pre> <p>Peer where object is located.</p>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoStore","title":"MargoStore","text":"<pre><code>MargoStore(\nname: str,\n*,\ninterface: str,\nport: int,\nprotocol: Protocol = Protocol.OFI_VERBS,\ncache_size: int = 16,\nstats: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[MargoStoreKey]</code></p> <p>MargoStore implementation for intrasite communication.</p> <p>This client will initialize a local Margo server (Peer service) that it will store data to.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> interface             (<code>str</code>)         \u2013 <p>The network interface to use.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The desired port for the Margo server.</p> </li> <li> protocol             (<code>Protocol</code>)         \u2013 <p>The communication protocol to use.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Collect stats on store operations.</p> </li> </ul> Source code in <code>proxystore/store/dim/margo.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\ninterface: str,\nport: int,\nprotocol: Protocol = Protocol.OFI_VERBS,\ncache_size: int = 16,\nstats: bool = False,\n) -&gt; None:\nglobal server_process\nglobal client_pids\nglobal engine\nglobal _rpcs\n# raise error if modules not properly loaded\nif pymargo_import_error is not None:  # pragma: no cover\nraise pymargo_import_error\nself.protocol = protocol\nself.host = get_ip_address(interface)\nself.port = port\nself.addr = f'{self.protocol}://{self.host}:{port}'\nif server_process is None:\nserver_process = Process(target=self._start_server)\nserver_process.start()\nif engine is None:\n# start client\nengine = Engine(\nself.protocol,\nmode=pymargo.client,\nuse_progress_thread=True,\n)\n_rpcs = {\n'set': engine.register('set'),\n'get': engine.register('get'),\n'exists': engine.register('exists'),\n'evict': engine.register('evict'),\n}\nself.engine = engine\nself._rpcs = _rpcs\nself.server_started()\nself._pid = getpid()\nclient_pids.add(self._pid)\nsuper().__init__(\nname,\ncache_size=cache_size,\nstats=stats,\nkwargs={\n'interface': interface,\n'port': self.port,\n'protocol': self.protocol,\n},\n)\n</code></pre>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoStore.server_started","title":"server_started","text":"<pre><code>server_started() -&gt; None\n</code></pre> <p>Loop until server has started.</p> Source code in <code>proxystore/store/dim/margo.py</code> <pre><code>def server_started(self) -&gt; None:  # pragma: no cover\n\"\"\"Loop until server has started.\"\"\"\nlogger.debug('Checking if server has started')\nwhile True:\nassert engine is not None\ntry:\nself._mochi_addr = engine.lookup(self.addr)\nbreak\nexcept MargoException:\npass\n</code></pre>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoStore.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Terminate Peer server process.</p> Source code in <code>proxystore/store/dim/margo.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Terminate Peer server process.\"\"\"\nglobal server_process\nglobal client_pids\nglobal engine\nclient_pids.discard(self._pid)\nlogger.info('Clean up requested')\nif len(client_pids) == 0 and server_process is not None:\nengine = None\nself._mochi_addr.shutdown()\nself.engine.finalize()\nserver_process.join()\nserver_process = None\n</code></pre>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoStore.call_rpc_on","title":"call_rpc_on  <code>staticmethod</code>","text":"<pre><code>call_rpc_on(\nengine: Engine,\naddr: str,\nrpc: RemoteFunction,\narray_str: Bulk,\nkey: str,\nsize: int,\n) -&gt; Status\n</code></pre> <p>Initiate the desired RPC call on the specified provider.</p> <p>Parameters:</p> <ul> <li> engine             (<code>Engine</code>)         \u2013 <p>The client-side engine.</p> </li> <li> addr             (<code>str</code>)         \u2013 <p>The address of Margo provider to access (e.g. tcp://172.21.2.203:6367).</p> </li> <li> rpc             (<code>RemoteFunction</code>)         \u2013 <p>The rpc to issue to the server.</p> </li> <li> array_str             (<code>Bulk</code>)         \u2013 <p>The serialized data/buffer to send to the server.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>The identifier of the data stored on the server.</p> </li> <li> size             (<code>int</code>)         \u2013 <p>The size of the the data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>A string denoting whether the communication was successful</p> </li> </ul> Source code in <code>proxystore/store/dim/margo.py</code> <pre><code>@staticmethod\ndef call_rpc_on(\nengine: Engine,\naddr: str,\nrpc: RemoteFunction,\narray_str: Bulk,\nkey: str,\nsize: int,\n) -&gt; Status:\n\"\"\"Initiate the desired RPC call on the specified provider.\n    Arguments:\n        engine: The client-side engine.\n        addr: The address of Margo provider to access\n            (e.g. tcp://172.21.2.203:6367).\n        rpc: The rpc to issue to the server.\n        array_str: The serialized data/buffer to send to the server.\n        key: The identifier of the data stored on the server.\n        size: The size of the the data.\n    Returns:\n        A string denoting whether the communication was successful\n    \"\"\"\nserver_addr = engine.lookup(addr)\nreturn deserialize(rpc.on(server_addr)(array_str, size, key))\n</code></pre>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoServer","title":"MargoServer","text":"<pre><code>MargoServer(engine: Engine) -&gt; None\n</code></pre> <p>MargoServer implementation.</p> <p>Parameters:</p> <ul> <li> engine             (<code>Engine</code>)         \u2013 <p>The server engine created at the specified network address.</p> </li> </ul> Source code in <code>proxystore/store/dim/margo.py</code> <pre><code>def __init__(self, engine: Engine) -&gt; None:\nself.data = {}\nself.engine = engine\nlogger.debug('Server initialized')\n</code></pre>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoServer.set","title":"set","text":"<pre><code>set(\nhandle: Handle, bulk_str: Bulk, bulk_size: int, key: str\n) -&gt; None\n</code></pre> <p>Obtain data from the client and store it in local dictionary.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>Bulk</code>)         \u2013 <p>The buffer containing the data to be shared.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data being transferred.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>The data key.</p> </li> </ul> Source code in <code>proxystore/store/dim/margo.py</code> <pre><code>def set(\nself,\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: str,\n) -&gt; None:\n\"\"\"Obtain data from the client and store it in local dictionary.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer containing the data to be shared.\n        bulk_size: The size of the data being transferred.\n        key: The data key.\n    \"\"\"\nlogger.debug(f'Received set RPC for key {key}.')\ns = Status(True, None)\nlocal_buffer = bytearray(bulk_size)\nlocal_bulk = self.engine.create_bulk(local_buffer, bulk.write_only)\nself.engine.transfer(\nbulk.pull,\nhandle.get_addr(),\nbulk_str,\n0,\nlocal_bulk,\n0,\nbulk_size,\n)\nself.data[key] = local_buffer\nhandle.respond(serialize(s))\n</code></pre>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoServer.get","title":"get","text":"<pre><code>get(\nhandle: Handle, bulk_str: Bulk, bulk_size: int, key: str\n) -&gt; None\n</code></pre> <p>Return data at a given key back to the client.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>Bulk</code>)         \u2013 <p>The buffer that will store shared data.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data to be received.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>The data's key.</p> </li> </ul> Source code in <code>proxystore/store/dim/margo.py</code> <pre><code>def get(\nself,\nhandle: Handle,\nbulk_str: Bulk,\nbulk_size: int,\nkey: str,\n) -&gt; None:\n\"\"\"Return data at a given key back to the client.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\nlogger.debug(f'Received get RPC for key {key}.')\ns = Status(True, None)\ntry:\nlocal_array = self.data[key]\nlocal_bulk = self.engine.create_bulk(local_array, bulk.read_only)\nself.engine.transfer(\nbulk.push,\nhandle.get_addr(),\nbulk_str,\n0,\nlocal_bulk,\n0,\nbulk_size,\n)\nexcept KeyError as error:\nlogger.error(f'key {error} not found.')\ns = Status(False, error)\nhandle.respond(serialize(s))\n</code></pre>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoServer.evict","title":"evict","text":"<pre><code>evict(\nhandle: Handle, bulk_str: str, bulk_size: int, key: str\n) -&gt; None\n</code></pre> <p>Remove key from local dictionary.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>str</code>)         \u2013 <p>The buffer that will store shared data.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data to be received.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>The data's key.</p> </li> </ul> Source code in <code>proxystore/store/dim/margo.py</code> <pre><code>def evict(\nself,\nhandle: Handle,\nbulk_str: str,\nbulk_size: int,\nkey: str,\n) -&gt; None:\n\"\"\"Remove key from local dictionary.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\nlogger.debug(f'Received exists RPC for key {key}')\nself.data.pop(key, None)\ns = Status(True, None)\nhandle.respond(serialize(s))\n</code></pre>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.MargoServer.exists","title":"exists","text":"<pre><code>exists(\nhandle: Handle, bulk_str: str, bulk_size: int, key: str\n) -&gt; None\n</code></pre> <p>Check if key exists within local dictionary.</p> <p>Parameters:</p> <ul> <li> handle             (<code>Handle</code>)         \u2013 <p>The client handle.</p> </li> <li> bulk_str             (<code>str</code>)         \u2013 <p>The buffer that will store shared data.</p> </li> <li> bulk_size             (<code>int</code>)         \u2013 <p>The size of the data to be received.</p> </li> <li> key             (<code>str</code>)         \u2013 <p>The data's key.</p> </li> </ul> Source code in <code>proxystore/store/dim/margo.py</code> <pre><code>def exists(\nself,\nhandle: Handle,\nbulk_str: str,\nbulk_size: int,\nkey: str,\n) -&gt; None:\n\"\"\"Check if key exists within local dictionary.\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\nlogger.debug(f'Received exists RPC for key {key}')\ns = Status(True, None)\n# converting to int then string because length appears to be 7 for\n# True with pickle protocol 4 and cannot always guarantee that that\n# protocol will be selected\nlocal_array = serialize(str(int(key in self.data)))\nlocal_bulk = self.engine.create_bulk(local_array, bulk.read_only)\nsize = len(local_array)\nself.engine.transfer(\nbulk.push,\nhandle.get_addr(),\nbulk_str,\n0,\nlocal_bulk,\n0,\nsize,\n)\nhandle.respond(serialize(s))\n</code></pre>"},{"location":"reference/store/dim/margo/#proxystore.store.dim.margo.when_finalize","title":"when_finalize","text":"<pre><code>when_finalize() -&gt; None\n</code></pre> <p>Print a statement advising that engine finalization was triggered.</p> Source code in <code>proxystore/store/dim/margo.py</code> <pre><code>def when_finalize() -&gt; None:\n\"\"\"Print a statement advising that engine finalization was triggered.\"\"\"\nlogger.info('Finalize was called. Cleaning up.')\n</code></pre>"},{"location":"reference/store/dim/ucx/","title":"proxystore.store.dim.ucx","text":"<p>UCXStore implementation.</p>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXStoreKey","title":"UCXStoreKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in a MargoStore.</p>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXStoreKey.ucx_key","title":"ucx_key  <code>class-attribute</code>","text":"<pre><code>ucx_key: str\n</code></pre> <p>Unique object key.</p>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXStoreKey.obj_size","title":"obj_size  <code>class-attribute</code>","text":"<pre><code>obj_size: int\n</code></pre> <p>Object size in bytes.</p>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXStoreKey.peer","title":"peer  <code>class-attribute</code>","text":"<pre><code>peer: str\n</code></pre> <p>Peer where object is located.</p>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXStore","title":"UCXStore","text":"<pre><code>UCXStore(\nname: str,\n*,\ninterface: str,\nport: int,\ncache_size: int = 16,\nstats: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[UCXStoreKey]</code></p> <p>Implementation for the client-facing component of UCXStore.</p> <p>This client will initialize a local UCX server (Peer service) to store data to.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> interface             (<code>str</code>)         \u2013 <p>The network interface to use.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The desired port for the UCX server.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Collect stats on store operations.</p> </li> </ul> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\ninterface: str,\nport: int,\ncache_size: int = 16,\nstats: bool = False,\n) -&gt; None:\nglobal server_process\nif ucx_import_error is not None:  # pragma: no cover\nraise ucx_import_error\nlogger.debug('Instantiating client and server')\nself.host = get_ip_address(interface)\nself.port = port\nself.addr = f'{self.host}:{self.port}'\ntry:\nself._loop = asyncio.get_running_loop()\nexcept RuntimeError:\nself._loop = asyncio.new_event_loop()\nif server_process is None:\nserver_process = Process(\ntarget=launch_server,\nargs=(self.host, self.port),\n)\nserver_process.start()\nself._loop.run_until_complete(\nwait_for_server(self.host, self.port),\n)\n# TODO: Verify if create_endpoint error handling will successfully\n# connect to endpoint or if error handling needs to be done here\nsuper().__init__(\nname,\ncache_size=cache_size,\nstats=stats,\nkwargs={'interface': interface, 'port': self.port},\n)\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXStore.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Terminate Peer server process.</p> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Terminate Peer server process.\"\"\"\nglobal server_process\nlogger.info('Clean up requested')\nif server_process is not None:\nserver_process.terminate()\nserver_process.join()\nserver_process = None\nlogger.debug('Clean up completed')\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXServer","title":"UCXServer","text":"<pre><code>UCXServer(host: str, port: int) -&gt; None\n</code></pre> <p>UCXServer implementation.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>The server host.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The server port.</p> </li> </ul> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\nself.host = host\nself.port = port\nself.data = {}\nself.ucp_listener = None\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXServer.set","title":"set","text":"<pre><code>set(key: str, data: bytes) -&gt; Status\n</code></pre> <p>Obtain data from the client and store it in local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object key to use.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>The data to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>def set(self, key: str, data: bytes) -&gt; Status:\n\"\"\"Obtain data from the client and store it in local dictionary.\n    Args:\n        key: The object key to use.\n        data: The data to store.\n    Returns:\n        Operation status.\n    \"\"\"\nself.data[key] = data\nreturn Status(success=True, error=None)\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXServer.get","title":"get","text":"<pre><code>get(key: str) -&gt; bytes | Status\n</code></pre> <p>Return data at a given key back to the client.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>def get(self, key: str) -&gt; bytes | Status:\n\"\"\"Return data at a given key back to the client.\n    Args:\n        key: The object key.\n    Returns:\n        Operation status.\n    \"\"\"\ntry:\nreturn self.data[key]\nexcept KeyError as e:\nreturn Status(success=False, error=e)\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXServer.evict","title":"evict","text":"<pre><code>evict(key: str) -&gt; Status\n</code></pre> <p>Remove key from local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object to evict's key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>def evict(self, key: str) -&gt; Status:\n\"\"\"Remove key from local dictionary.\n    Args:\n        key: The object to evict's key.\n    Returns:\n        Operation status.\n    \"\"\"\nself.data.pop(key, None)\nreturn Status(success=True, error=None)\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXServer.exists","title":"exists","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if a key exists within local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object's key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the object exists.</p> </li> </ul> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n\"\"\"Check if a key exists within local dictionary.\n    Args:\n        key: The object's key.\n    Returns:\n        If the object exists.\n    \"\"\"\nreturn key in self.data\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXServer.handler","title":"handler  <code>async</code>","text":"<pre><code>handler(ep: ucp.Endpoint) -&gt; None\n</code></pre> <p>Handle endpoint requests.</p> <p>Parameters:</p> <ul> <li> ep             (<code>ucp.Endpoint</code>)         \u2013 <p>The endpoint to communicate with.</p> </li> </ul> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>async def handler(self, ep: ucp.Endpoint) -&gt; None:\n\"\"\"Handle endpoint requests.\n    Args:\n        ep: The endpoint to communicate with.\n    \"\"\"\njson_kv = await ep.recv_obj()\nif json_kv == bytes(1):\nawait ep.send_obj(bytes(1))\nreturn\nkv = deserialize(bytes(json_kv))\nkey = kv['key']\ndata = kv['data']\nfunc = kv['op']\nif func == 'set':\nres = self.set(key, data)\nelse:\nif func == 'get':\nfunc = self.get\nelif func == 'exists':\nfunc = self.exists\nelif func == 'evict':\nfunc = self.evict\nelse:\nraise AssertionError('Unreachable.')\nres = func(key)\nif isinstance(res, Status) or isinstance(res, bool):\nserialized_res = serialize(res)\nelse:\nserialized_res = res\nawait ep.send_obj(serialized_res)\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.UCXServer.run","title":"run  <code>async</code>","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run this UCXServer forever.</p> <p>Creates a listener for the handler method and waits on SIGINT/TERM events to exit. Also handles cleaning up UCP objects.</p> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>async def run(self) -&gt; None:\n\"\"\"Run this UCXServer forever.\n    Creates a listener for the handler method and waits on SIGINT/TERM\n    events to exit. Also handles cleaning up UCP objects.\n    \"\"\"\nself.ucp_listener = ucp.create_listener(self.handler, self.port)\n# Set the stop condition when receiving SIGINT (ctrl-C) and SIGTERM.\nloop = asyncio.get_running_loop()\nstop = loop.create_future()\nloop.add_signal_handler(signal.SIGINT, stop.set_result, None)\nloop.add_signal_handler(signal.SIGTERM, stop.set_result, None)\nawait stop\nself.close()\nawait reset_ucp_async()\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.launch_server","title":"launch_server","text":"<pre><code>launch_server(host: str, port: int) -&gt; None\n</code></pre> <p>Launch the UCXServer in asyncio.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>The host for server to listen on.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The port for server to listen on.</p> </li> </ul> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>def launch_server(host: str, port: int) -&gt; None:\n\"\"\"Launch the UCXServer in asyncio.\n    Args:\n        host: The host for server to listen on.\n        port: The port for server to listen on.\n    \"\"\"\nlogger.info(f'starting server on host {host} with port {port}')\nps = UCXServer(host, port)\n# CI occasionally timeouts when starting this server in the\n# store_implementation session fixture. It seems to not happen when\n# debug=True, but this is just a temporary fix.\nasyncio.run(ps.run(), debug=True)\nlogger.info(f'server running at address {host}:{port}')\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.reset_ucp","title":"reset_ucp","text":"<pre><code>reset_ucp() -&gt; None\n</code></pre> <p>Hard reset all of UCP.</p> <p>UCP provides <code>ucp.reset()</code>; however, this function does not correctly shutdown all asyncio tasks and readers. This function wraps <code>ucp.reset()</code> and additionally removes all readers on the event loop and cancels/awaits all asyncio tasks.</p> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>def reset_ucp() -&gt; None:  # pragma: no cover\n\"\"\"Hard reset all of UCP.\n    UCP provides `ucp.reset()`; however, this function does not correctly\n    shutdown all asyncio tasks and readers. This function wraps\n    `ucp.reset()` and additionally removes all readers on the event loop\n    and cancels/awaits all asyncio tasks.\n    \"\"\"\ndef inner_context() -&gt; None:\nctx = ucp.core._get_ctx()\nfor task in ctx.progress_tasks:\nif task is None:\ncontinue\ntask.event_loop.remove_reader(ctx.epoll_fd)\nif task.asyncio_task is not None:\ntry:\ntask.asyncio_task.cancel()\ntask.event_loop.run_until_complete(task.asyncio_task)\nexcept asyncio.CancelledError:\npass\n# We access ucp.core._get_ctx() inside this nested function so our local\n# reference to the UCP context goes out of scope before calling\n# ucp.reset(). ucp.reset() will fail if there are any weak references to\n# to the UCP context because it assumes those may be Listeners or\n# Endpoints that were not properly closed.\ninner_context()\ntry:\nucp.reset()\nexcept ucp.UCXError:\npass\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.reset_ucp_async","title":"reset_ucp_async  <code>async</code>","text":"<pre><code>reset_ucp_async() -&gt; None\n</code></pre> <p>Hard reset all of UCP.</p> <p>UCP provides <code>ucp.reset()</code>; however, this function does not correctly shutdown all asyncio tasks and readers. This function wraps <code>ucp.reset()</code> and additionally removes all readers on the event loop and cancels/awaits all asyncio tasks.</p> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>async def reset_ucp_async() -&gt; None:  # pragma: no cover\n\"\"\"Hard reset all of UCP.\n    UCP provides `ucp.reset()`; however, this function does not correctly\n    shutdown all asyncio tasks and readers. This function wraps\n    `ucp.reset()` and additionally removes all readers on the event loop\n    and cancels/awaits all asyncio tasks.\n    \"\"\"\nasync def inner_context() -&gt; None:\nctx = ucp.core._get_ctx()\nfor task in ctx.progress_tasks:\nif task is None:\ncontinue\ntask.event_loop.remove_reader(ctx.epoll_fd)\nif task.asyncio_task is not None:\ntry:\ntask.asyncio_task.cancel()\nawait task.asyncio_task\nexcept asyncio.CancelledError:\npass\n# We access ucp.core._get_ctx() inside this nested function so our local\n# reference to the UCP context goes out of scope before calling\n# ucp.reset(). ucp.reset() will fail if there are any weak references to\n# to the UCP context because it assumes those may be Listeners or\n# Endpoints that were not properly closed.\nawait inner_context()\ntry:\nucp.reset()\nexcept ucp.UCXError:\npass\n</code></pre>"},{"location":"reference/store/dim/ucx/#proxystore.store.dim.ucx.wait_for_server","title":"wait_for_server  <code>async</code>","text":"<pre><code>wait_for_server(\nhost: str, port: int, timeout: float = 5.0\n) -&gt; None\n</code></pre> <p>Wait until the UCXServer responds.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>The host of UCXServer to ping.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>Theport of UCXServer to ping.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>The max time in seconds to wait for server response.</p> </li> </ul> Source code in <code>proxystore/store/dim/ucx.py</code> <pre><code>async def wait_for_server(host: str, port: int, timeout: float = 5.0) -&gt; None:\n\"\"\"Wait until the UCXServer responds.\n    Args:\n        host: The host of UCXServer to ping.\n        port: Theport of UCXServer to ping.\n        timeout: The max time in seconds to wait for server response.\n    \"\"\"\nsleep_time = 0.01\ntime_waited = 0.0\nwhile True:\ntry:\nep = await ucp.create_endpoint(host, port)\nexcept ucp._libs.exceptions.UCXNotConnected as e:  # pragma: no cover\nif time_waited &gt;= timeout:\nraise RuntimeError(\n'Failed to connect to server within timeout '\nf'({timeout} seconds).',\n) from e\nawait asyncio.sleep(sleep_time)\ntime_waited += sleep_time\nelse:\nbreak  # pragma: no cover\nawait ep.send_obj(bytes(1))\n_ = await ep.recv_obj()\nawait ep.close()\nassert ep.closed()\n</code></pre>"},{"location":"reference/store/dim/utils/","title":"proxystore.store.dim.utils","text":"<p>Shared functions used by DIM stores.</p>"},{"location":"reference/store/dim/utils/#proxystore.store.dim.utils.Status","title":"Status","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Task status response.</p>"},{"location":"reference/store/dim/utils/#proxystore.store.dim.utils.get_ip_address","title":"get_ip_address","text":"<pre><code>get_ip_address(ifname: str) -&gt; str\n</code></pre> <p>Get ip address provided an interface name.</p> <p>Parameters:</p> <ul> <li> ifname             (<code>str</code>)         \u2013 <p>The interface name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The IP address.</p> </li> </ul> Source code in <code>proxystore/store/dim/utils.py</code> <pre><code>def get_ip_address(ifname: str) -&gt; str:\n\"\"\"Get ip address provided an interface name.\n    Args:\n        ifname: The interface name.\n    Returns:\n        The IP address.\n    \"\"\"\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\ntry:\nreturn socket.inet_ntoa(\nfcntl.ioctl(\ns.fileno(),\n0x8915,\nstruct.pack(\n'256s',\nbytes(ifname[:15], 'utf-8'),\n),  # SIOCGIFADDR\n)[20:24],\n)\nexcept OSError:\n# Not a solution, but the above doesn't work with Macs\n# need to provide IP rather than the interface name for the time being\nif ifname == 'localhost':\nifname = '127.0.0.1'\nreturn ifname\n</code></pre>"},{"location":"reference/store/dim/websockets/","title":"proxystore.store.dim.websockets","text":"<p>Websockets implementation.</p>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketStoreKey","title":"WebsocketStoreKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in a WebsocketStore.</p>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketStoreKey.websocket_key","title":"websocket_key  <code>class-attribute</code>","text":"<pre><code>websocket_key: str\n</code></pre> <p>Unique object key.</p>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketStoreKey.obj_size","title":"obj_size  <code>class-attribute</code>","text":"<pre><code>obj_size: int\n</code></pre> <p>Object size in bytes.</p>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketStoreKey.peer","title":"peer  <code>class-attribute</code>","text":"<pre><code>peer: str\n</code></pre> <p>Peer where object is located.</p>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketStore","title":"WebsocketStore","text":"<pre><code>WebsocketStore(\nname: str,\n*,\ninterface: str,\nport: int,\nmax_size: int = MAX_SIZE_DEFAULT,\ncache_size: int = 16,\nstats: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[WebsocketStoreKey]</code></p> <p>Distributed in-memory store using websockets.</p> <p>This client will initialize a local Websocket server (Peer service) that it will store data to.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> interface             (<code>str</code>)         \u2013 <p>The network interface to use.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The desired port for communication.</p> </li> <li> max_size             (<code>int</code>)         \u2013 <p>The maximum size to be communicated via websockets.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Collect stats on store operations.</p> </li> </ul> Source code in <code>proxystore/store/dim/websockets.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\ninterface: str,\nport: int,\nmax_size: int = MAX_SIZE_DEFAULT,\ncache_size: int = 16,\nstats: bool = False,\n) -&gt; None:\nglobal server_process\n# Websockets is not a default dependency so we don't want to raise\n# an error unless the user actually tries to use this code\nif websockets_import_error is not None:  # pragma: no cover\nraise websockets_import_error\nlogger.debug('Instantiating client and server')\nself.max_size = max_size\nself.chunk_size = MAX_CHUNK_LENGTH\nself.host = get_ip_address(interface)\nself.port = port\nself.addr = f'ws://{self.host}:{self.port}'\nif server_process is None:\nserver_process = Process(target=self._start_server)\nserver_process.start()\ntry:\nself._loop = asyncio.get_running_loop()\nexcept RuntimeError:\nself._loop = asyncio.new_event_loop()\nself._loop.run_until_complete(self.server_started())\nsuper().__init__(\nname,\ncache_size=cache_size,\nstats=stats,\nkwargs={\n'interface': interface,\n'port': self.port,\n'max_size': self.max_size,\n},\n)\n</code></pre>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketStore.handler","title":"handler  <code>async</code>","text":"<pre><code>handler(event: bytes, addr: str) -&gt; bytes\n</code></pre> <p>Websocket handler function implementation.</p> <p>Parameters:</p> <ul> <li> event             (<code>bytes</code>)         \u2013 <p>A pickled dictionary consisting of the data, its key and the operation to perform on the data</p> </li> <li> addr             (<code>str</code>)         \u2013 <p>The address of the server to connect to</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>         \u2013 <p>The result of the operation on the data.</p> </li> </ul> Source code in <code>proxystore/store/dim/websockets.py</code> <pre><code>async def handler(self, event: bytes, addr: str) -&gt; bytes:\n\"\"\"Websocket handler function implementation.\n    Args:\n        event: A pickled dictionary consisting of the data,\n            its key and the operation to perform on the data\n        addr: The address of the server to connect to\n    Returns:\n        The result of the operation on the data.\n    \"\"\"\nasync with connect(\naddr,\nmax_size=self.max_size,\n) as websocket:\nawait websocket.send(utils.chunk_bytes(event, self.chunk_size))\nres = await websocket.recv()\nassert isinstance(res, bytes)\nreturn res\n</code></pre>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketStore.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Terminate Peer server process.</p> Source code in <code>proxystore/store/dim/websockets.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Terminate Peer server process.\"\"\"\nglobal server_process\nlogger.info('Clean up requested')\nif server_process is not None:\nserver_process.terminate()\nserver_process.join()\nserver_process = None\nlogger.debug('Clean up completed')\n</code></pre>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketServer","title":"WebsocketServer","text":"<pre><code>WebsocketServer(\nhost: str, port: int, max_size: int\n) -&gt; None\n</code></pre> <p>WebsocketServer implementation.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>IP address of the location to start the server.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The port to initiate communication on.</p> </li> <li> max_size             (<code>int</code>)         \u2013 <p>The maximum size allowed for websocket communication.</p> </li> </ul> Source code in <code>proxystore/store/dim/websockets.py</code> <pre><code>def __init__(\nself,\nhost: str,\nport: int,\nmax_size: int,\n) -&gt; None:\nself.host = host\nself.port = port\nself.max_size = max_size\nself.chunk_size = MAX_CHUNK_LENGTH\nself.data = {}\nsuper().__init__()\n</code></pre>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketServer.set","title":"set","text":"<pre><code>set(key: str, data: bytes) -&gt; Status\n</code></pre> <p>Obtain and store locally data from client.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Object key to use.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Data to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/store/dim/websockets.py</code> <pre><code>def set(self, key: str, data: bytes) -&gt; Status:\n\"\"\"Obtain and store locally data from client.\n    Args:\n        key: Object key to use.\n        data: Data to store.\n    Returns:\n        Operation status.\n    \"\"\"\nself.data[key] = data\nreturn Status(success=True, error=None)\n</code></pre>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketServer.get","title":"get","text":"<pre><code>get(key: str) -&gt; bytes | Status\n</code></pre> <p>Return data at a given key back to the client.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object key,</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/store/dim/websockets.py</code> <pre><code>def get(self, key: str) -&gt; bytes | Status:\n\"\"\"Return data at a given key back to the client.\n    Args:\n        key: The object key,\n    Returns:\n        Operation status.\n    \"\"\"\ntry:\nreturn self.data[key]\nexcept KeyError as e:\nreturn Status(False, e)\n</code></pre>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketServer.evict","title":"evict","text":"<pre><code>evict(key: str) -&gt; Status\n</code></pre> <p>Remove key from local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object to evict's key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/store/dim/websockets.py</code> <pre><code>def evict(self, key: str) -&gt; Status:\n\"\"\"Remove key from local dictionary.\n    Args:\n        key: The object to evict's key.\n    Returns:\n        Operation status.\n    \"\"\"\nself.data.pop(key, None)\nreturn Status(success=True, error=None)\n</code></pre>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketServer.exists","title":"exists","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if a key exists within local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object's key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>Operations status.</p> </li> </ul> Source code in <code>proxystore/store/dim/websockets.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n\"\"\"Check if a key exists within local dictionary.\n    Args:\n        key: The object's key.\n    Returns:\n        Operations status.\n    \"\"\"\nreturn key in self.data\n</code></pre>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketServer.handler","title":"handler  <code>async</code>","text":"<pre><code>handler(websocket: WebSocketServerProtocol) -&gt; None\n</code></pre> <p>Handle websocket connection requests.</p> <p>Parameters:</p> <ul> <li> websocket             (<code>WebSocketServerProtocol</code>)         \u2013 <p>The websocket server.</p> </li> </ul> Source code in <code>proxystore/store/dim/websockets.py</code> <pre><code>async def handler(self, websocket: WebSocketServerProtocol) -&gt; None:\n\"\"\"Handle websocket connection requests.\n    Args:\n        websocket: The websocket server.\n    \"\"\"\nasync for pkv in websocket:\nassert isinstance(pkv, bytes)\nkv = deserialize(pkv)\nkey = kv['key']\ndata = kv['data']\nfunc = kv['op']\nif func == 'set':\nres = self.set(key, data)\nelse:\nif func == 'get':\nfunc = self.get\nelif func == 'exists':\nfunc = self.exists\nelif func == 'evict':\nfunc = self.evict\nelse:\nraise AssertionError('Unreachable.')\nres = func(key)\nif isinstance(res, Status) or isinstance(res, bool):\nserialized_res = serialize(res)\nelse:\nserialized_res = res\nawait websocket.send(\nutils.chunk_bytes(serialized_res, self.chunk_size),\n)\n</code></pre>"},{"location":"reference/store/dim/websockets/#proxystore.store.dim.websockets.WebsocketServer.launch","title":"launch  <code>async</code>","text":"<pre><code>launch() -&gt; None\n</code></pre> <p>Launch the server.</p> Source code in <code>proxystore/store/dim/websockets.py</code> <pre><code>async def launch(self) -&gt; None:\n\"\"\"Launch the server.\"\"\"\nloop = asyncio.get_running_loop()\nstop = loop.create_future()\nloop.add_signal_handler(signal.SIGINT, stop.set_result, None)\nloop.add_signal_handler(signal.SIGTERM, stop.set_result, None)\nasync with serve(\nself.handler,\nself.host,\nself.port,\nmax_size=self.max_size,\n):\nawait stop  # run forever\n</code></pre>"},{"location":"reference/store/dim/zmq/","title":"proxystore.store.dim.zmq","text":"<p>ZeroMQ implementation.</p>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQStoreKey","title":"ZeroMQStoreKey","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Key to objects in a ZeroMQStore.</p>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQStoreKey.zmq_key","title":"zmq_key  <code>class-attribute</code>","text":"<pre><code>zmq_key: str\n</code></pre> <p>Unique object key.</p>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQStoreKey.obj_size","title":"obj_size  <code>class-attribute</code>","text":"<pre><code>obj_size: int\n</code></pre> <p>Object size in bytes.</p>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQStoreKey.peer","title":"peer  <code>class-attribute</code>","text":"<pre><code>peer: str\n</code></pre> <p>Peer where object is located.</p>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQStore","title":"ZeroMQStore","text":"<pre><code>ZeroMQStore(\nname: str,\n*,\ninterface: str,\nport: int,\nmax_size: int = MAX_SIZE_DEFAULT,\ncache_size: int = 16,\nstats: bool = False\n) -&gt; None\n</code></pre> <p>         Bases: <code>Store[ZeroMQStoreKey]</code></p> <p>Distributed in-memory store using Zero MQ.</p> <p>This client will initialize a local ZeroMQ server (Peer service) that it will store data to.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>Name of the store instance.</p> </li> <li> interface             (<code>str</code>)         \u2013 <p>The network interface to use.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The desired port for communication.</p> </li> <li> max_size             (<code>int</code>)         \u2013 <p>The maximum size to be communicated via zmq.</p> </li> <li> cache_size             (<code>int</code>)         \u2013 <p>Size of LRU cache (in # of objects). If 0, the cache is disabled. The cache is local to the Python process.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Collect stats on store operations.</p> </li> </ul> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>def __init__(\nself,\nname: str,\n*,\ninterface: str,\nport: int,\nmax_size: int = MAX_SIZE_DEFAULT,\ncache_size: int = 16,\nstats: bool = False,\n) -&gt; None:\nglobal server_process\n# ZMQ is not a default dependency so we don't want to raise\n# an error unless the user actually tries to use this code\nif zmq_import_error is not None:  # pragma: no cover\nraise zmq_import_error\nlogger.debug('Instantiating client and server')\nself.max_size = max_size\nself.chunk_size = MAX_CHUNK_LENGTH\nself.host = get_ip_address(interface)\nself.port = port\nself.addr = f'tcp://{self.host}:{self.port}'\nif server_process is None:\nserver_process = Process(target=self._start_server)\nserver_process.start()\nself.context = zmq.asyncio.Context()\nself.socket = self.context.socket(zmq.REQ)\ntry:\nself._loop = asyncio.get_running_loop()\nexcept RuntimeError:\nself._loop = asyncio.new_event_loop()\nself._loop.run_until_complete(wait_for_server(self.host, self.port))\nsuper().__init__(\nname,\ncache_size=cache_size,\nstats=stats,\nkwargs={\n'interface': interface,\n'port': self.port,\n'max_size': self.max_size,\n},\n)\n</code></pre>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQStore.handler","title":"handler  <code>async</code>","text":"<pre><code>handler(event: bytes, addr: str) -&gt; bytes\n</code></pre> <p>ZeroMQ handler function implementation.</p> <p>Parameters:</p> <ul> <li> event             (<code>bytes</code>)         \u2013 <p>A pickled dictionary consisting of the data, its key, and the operation to perform on the data.</p> </li> <li> addr             (<code>str</code>)         \u2013 <p>The address of the server to connect to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>         \u2013 <p>The serialized result of the operation on the data.</p> </li> </ul> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>async def handler(self, event: bytes, addr: str) -&gt; bytes:\n\"\"\"ZeroMQ handler function implementation.\n    Args:\n        event: A pickled dictionary consisting of the data,\n            its key, and the operation to perform on the data.\n        addr: The address of the server to connect to.\n    Returns:\n        The serialized result of the operation on the data.\n    \"\"\"\nwith self.socket.connect(addr):\nawait self.socket.send_multipart(\nlist(utils.chunk_bytes(event, self.chunk_size)),\n)\nres = b''.join(await self.socket.recv_multipart())\nassert isinstance(res, bytes)\nreturn res\n</code></pre>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQStore.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Terminate Peer server process.</p> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Terminate Peer server process.\"\"\"\nglobal server_process\nlogger.info('Clean up requested')\nif server_process is not None:  # pragma: no cover\nserver_process.terminate()\nserver_process.join()\nserver_process = None\nlogger.debug('Clean up completed')\n</code></pre>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQServer","title":"ZeroMQServer","text":"<pre><code>ZeroMQServer(host: str, port: int, max_size: int) -&gt; None\n</code></pre> <p>ZeroMQServer implementation.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>IP address of the location to start the server.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The port to initiate communication on.</p> </li> <li> max_size             (<code>int</code>)         \u2013 <p>The maximum size allowed for zmq communication.</p> </li> </ul> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>def __init__(self, host: str, port: int, max_size: int) -&gt; None:\nself.host = host\nself.port = port\nself.max_size = max_size\nself.chunk_size = MAX_CHUNK_LENGTH\nself.data = {}\nself.context = zmq.asyncio.Context()\nself.socket = self.context.socket(zmq.REP)\nself.socket.bind(f'tcp://{self.host}:{self.port}')\n</code></pre>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQServer.set","title":"set","text":"<pre><code>set(key: str, data: bytes) -&gt; Status\n</code></pre> <p>Obtain and store locally data from client.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>Object key to use.</p> </li> <li> data             (<code>bytes</code>)         \u2013 <p>Data to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>def set(self, key: str, data: bytes) -&gt; Status:\n\"\"\"Obtain and store locally data from client.\n    Args:\n        key: Object key to use.\n        data: Data to store.\n    Returns:\n        Operation status.\n    \"\"\"\nself.data[key] = data\nreturn Status(success=True, error=None)\n</code></pre>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQServer.get","title":"get","text":"<pre><code>get(key: str) -&gt; bytes | Status\n</code></pre> <p>Return data at a given key back to the client.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>def get(self, key: str) -&gt; bytes | Status:\n\"\"\"Return data at a given key back to the client.\n    Args:\n        key: The object key.\n    Returns:\n        Operation status.\n    \"\"\"\ntry:\nreturn self.data[key]\nexcept KeyError as e:\nreturn Status(False, e)\n</code></pre>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQServer.evict","title":"evict","text":"<pre><code>evict(key: str) -&gt; Status\n</code></pre> <p>Remove key from local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object to evict's key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Status</code>         \u2013 <p>Operation status.</p> </li> </ul> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>def evict(self, key: str) -&gt; Status:\n\"\"\"Remove key from local dictionary.\n    Args:\n        key: The object to evict's key.\n    Returns:\n        Operation status.\n    \"\"\"\nself.data.pop(key, None)\nreturn Status(success=True, error=None)\n</code></pre>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQServer.exists","title":"exists","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if a key exists within local dictionary.</p> <p>Parameters:</p> <ul> <li> key             (<code>str</code>)         \u2013 <p>The object's key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the key exists.</p> </li> </ul> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n\"\"\"Check if a key exists within local dictionary.\n    Args:\n        key: The object's key.\n    Returns:\n        If the key exists.\n    \"\"\"\nreturn key in self.data\n</code></pre>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQServer.handler","title":"handler  <code>async</code>","text":"<pre><code>handler() -&gt; None\n</code></pre> <p>Handle zmq connection requests.</p> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>async def handler(self) -&gt; None:\n\"\"\"Handle zmq connection requests.\"\"\"\nwhile not self.socket.closed:  # pragma: no branch\ntry:\nfor pkv in await self.socket.recv_multipart():\nassert isinstance(pkv, bytes)\nif pkv == b'ping':\nself.socket.send(b'pong')\ncontinue\nkv = deserialize(pkv)\nkey = kv['key']\ndata = kv['data']\nfunc = kv['op']\nif func == 'set':\nres = self.set(key, data)\nelse:\nif func == 'get':\nfunc = self.get\nelif func == 'exists':\nfunc = self.exists\nelif func == 'evict':\nfunc = self.evict\nelse:\nraise AssertionError('Unreachable.')\nres = func(key)\nif isinstance(res, Status) or isinstance(res, bool):\nserialized_res = serialize(res)\nelse:\nserialized_res = res\nawait self.socket.send_multipart(\nlist(\nutils.chunk_bytes(serialized_res, self.chunk_size),\n),\n)\nexcept zmq.ZMQError as e:  # pragma: no cover\nlogger.exception(e)\nawait asyncio.sleep(0.01)\nexcept asyncio.exceptions.CancelledError:  # pragma: no cover\nlogger.debug('loop terminated')\n</code></pre>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.ZeroMQServer.launch","title":"launch  <code>async</code>","text":"<pre><code>launch() -&gt; None\n</code></pre> <p>Launch the server.</p> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>async def launch(self) -&gt; None:\n\"\"\"Launch the server.\"\"\"\nloop = asyncio.get_running_loop()\nloop.create_future()\nloop.add_signal_handler(signal.SIGINT, self.socket.close, None)\nloop.add_signal_handler(signal.SIGTERM, self.socket.close, None)\nawait self.handler()\n</code></pre>"},{"location":"reference/store/dim/zmq/#proxystore.store.dim.zmq.wait_for_server","title":"wait_for_server  <code>async</code>","text":"<pre><code>wait_for_server(\nhost: str, port: int, timeout: float = 5.0\n) -&gt; None\n</code></pre> <p>Wait until the ZeroMQServer responds.</p> <p>Parameters:</p> <ul> <li> host             (<code>str</code>)         \u2013 <p>The host of the server to ping.</p> </li> <li> port             (<code>int</code>)         \u2013 <p>The port of the server to ping.</p> </li> <li> timeout             (<code>float</code>)         \u2013 <p>The max time in seconds to wait for server response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013         <p>if the server does not respond within the timeout.</p> </li> </ul> Source code in <code>proxystore/store/dim/zmq.py</code> <pre><code>async def wait_for_server(host: str, port: int, timeout: float = 5.0) -&gt; None:\n\"\"\"Wait until the ZeroMQServer responds.\n    Args:\n        host: The host of the server to ping.\n        port: The port of the server to ping.\n        timeout: The max time in seconds to wait for server response.\n    Raises:\n        RuntimeError: if the server does not respond within the timeout.\n    \"\"\"\nstart = time.time()\ncontext = zmq.asyncio.Context()\nsocket = context.socket(zmq.REQ)\nsocket.setsockopt(zmq.LINGER, 0)\nwith socket.connect(f'tcp://{host}:{port}'):\nawait socket.send(b'ping')\npoller = zmq.asyncio.Poller()\npoller.register(socket, zmq.POLLIN)\nwhile time.time() - start &lt; timeout:\nevent = await poller.poll(timeout)\nif len(event) != 0:\nresponse = await socket.recv()\nassert response == b'pong'\nsocket.close()\nreturn\nsocket.close()\nraise RuntimeError(\n'Failed to connect to server within timeout ({timeout} seconds).',\n)\n</code></pre>"}]}